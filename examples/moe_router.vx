// Mixture of Experts (MoE) Router Example
// Implements token routing to top-k experts with load balancing

// Linear layer: y = x * W (manual dot product per output)
fn linear(input: Any, weights: Any) -> Any {
    let n_out = len(weights)
    var result = []
    for j in 0..n_out {
        let w = weights[j]
        var dot = 0.0
        for i in 0..len(input) {
            dot = dot + input[i] * w[i]
        }
        result = push(result, dot)
    }
    return result
}

// ReLU activation
fn relu(x: Any) -> Any {
    return map(x, |v| if v > 0.0 { v } else { 0.0 })
}

// Expert MLP: two linear layers with ReLU
fn expert_forward(input: Any, w1: Any, w2: Any) -> Any {
    let hidden = relu(linear(input, w1))
    return linear(hidden, w2)
}

// Scale a vector by a scalar
fn scale_vec(v: Any, s: f64) -> Any {
    return map(v, |x| x * s)
}

// Add two vectors element-wise
fn add_vec(a: Any, b: Any) -> Any {
    var result = []
    for i in 0..len(a) {
        result = push(result, a[i] + b[i])
    }
    return result
}

// Find index of max value in array
fn argmax(arr: Any) -> i64 {
    var best_idx = 0
    var best_val = arr[0]
    for i in 1..len(arr) {
        if arr[i] > best_val {
            best_val = arr[i]
            best_idx = i
        }
    }
    return best_idx
}

// Find index of second largest value
fn arg_second(arr: Any, first_idx: i64) -> i64 {
    var best_idx = -1
    var best_val = -999999.0
    for i in 0..len(arr) {
        if i != first_idx {
            if arr[i] > best_val {
                best_val = arr[i]
                best_idx = i
            }
        }
    }
    return best_idx
}

fn main() {
    println("=== Mixture of Experts Router ===")
    println("")

    // Configuration
    let n_tokens = 8
    let d_model = 4
    let n_experts = 4
    let top_k = 2

    // --- Router weights (d_model -> n_experts) ---
    let router_weights = [
        [0.5, -0.3, 0.1, 0.2],
        [-0.2, 0.6, -0.1, 0.3],
        [0.1, -0.1, 0.7, -0.2],
        [-0.3, 0.2, -0.4, 0.8]
    ]

    // --- Expert weights (4 experts, each a 2-layer MLP) ---
    // Expert 0: specializes in feature 0
    let e0_w1 = [[0.8, 0.1, -0.1, 0.0], [0.1, 0.3, 0.0, 0.1], [-0.1, 0.0, 0.2, 0.1], [0.0, 0.1, 0.1, 0.4]]
    let e0_w2 = [[0.7, 0.0, 0.1, -0.1], [-0.1, 0.5, 0.0, 0.1], [0.1, 0.0, 0.3, 0.0], [0.0, 0.1, 0.0, 0.6]]

    // Expert 1: specializes in feature 1
    let e1_w1 = [[0.3, 0.1, 0.0, 0.1], [0.1, 0.9, -0.1, 0.0], [0.0, -0.1, 0.4, 0.1], [0.1, 0.0, 0.1, 0.2]]
    let e1_w2 = [[0.4, 0.1, 0.0, 0.0], [0.0, 0.8, 0.1, -0.1], [0.1, 0.0, 0.5, 0.0], [0.0, 0.1, 0.0, 0.3]]

    // Expert 2: specializes in feature 2
    let e2_w1 = [[0.2, 0.0, 0.1, 0.1], [0.0, 0.3, 0.1, 0.0], [0.1, 0.1, 0.9, -0.1], [-0.1, 0.0, 0.0, 0.4]]
    let e2_w2 = [[0.5, 0.0, 0.1, 0.0], [0.0, 0.4, 0.0, 0.1], [0.0, 0.1, 0.7, 0.0], [0.1, 0.0, 0.0, 0.5]]

    // Expert 3: specializes in feature 3
    let e3_w1 = [[0.4, 0.0, 0.0, 0.1], [0.0, 0.2, 0.1, 0.0], [0.1, 0.0, 0.3, 0.0], [0.0, 0.1, -0.1, 0.8]]
    let e3_w2 = [[0.3, 0.1, 0.0, 0.0], [0.1, 0.3, 0.0, 0.1], [0.0, 0.0, 0.4, 0.1], [0.0, 0.0, 0.1, 0.9]]

    // Store expert weights in arrays for dispatch
    let expert_w1 = [e0_w1, e1_w1, e2_w1, e3_w1]
    let expert_w2 = [e0_w2, e1_w2, e2_w2, e3_w2]

    // --- Input tokens (8 tokens, each d_model=4 dimensional) ---
    let tokens = [
        [1.0, 0.2, 0.1, 0.3],
        [0.1, 1.0, 0.3, 0.2],
        [0.2, 0.1, 1.0, 0.1],
        [0.3, 0.2, 0.1, 1.0],
        [0.8, 0.5, 0.1, 0.1],
        [0.1, 0.7, 0.6, 0.2],
        [0.3, 0.1, 0.8, 0.5],
        [0.5, 0.3, 0.2, 0.9]
    ]

    println(format("Tokens: {}, d_model: {}, Experts: {}, Top-k: {}", to_string(n_tokens), to_string(d_model), to_string(n_experts), to_string(top_k)))
    println("")

    // --- Step 1: Route each token ---
    println("--- Step 1: Router Scores & Expert Selection ---")
    var expert_load = [0, 0, 0, 0]
    var token_experts = []
    var token_weights = []

    for t in 0..n_tokens {
        let token = tokens[t]

        // Compute router logits
        let logits = linear(token, router_weights)

        // Softmax to get routing probabilities
        let probs = softmax(logits)

        // Top-2 selection
        let idx1 = argmax(probs)
        let idx2 = arg_second(probs, idx1)
        let w1 = probs[idx1]
        let w2 = probs[idx2]

        // Normalize weights so they sum to 1
        let w_sum = w1 + w2
        let nw1 = w1 / w_sum
        let nw2 = w2 / w_sum

        token_experts = push(token_experts, [idx1, idx2])
        token_weights = push(token_weights, [nw1, nw2])

        // Track load
        expert_load = [
            expert_load[0] + if idx1 == 0 { 1 } else { 0 } + if idx2 == 0 { 1 } else { 0 },
            expert_load[1] + if idx1 == 1 { 1 } else { 0 } + if idx2 == 1 { 1 } else { 0 },
            expert_load[2] + if idx1 == 2 { 1 } else { 0 } + if idx2 == 2 { 1 } else { 0 },
            expert_load[3] + if idx1 == 3 { 1 } else { 0 } + if idx2 == 3 { 1 } else { 0 }
        ]

        println(format("  Token {} -> Expert {} (w={}) + Expert {} (w={})", to_string(t), to_string(idx1), to_string(nw1), to_string(idx2), to_string(nw2)))
    }

    // --- Step 2: Run expert MLPs and combine ---
    println("")
    println("--- Step 2: Expert Computation & Weighted Combination ---")

    var outputs = []
    for t in 0..n_tokens {
        let token = tokens[t]
        let experts = token_experts[t]
        let weights = token_weights[t]

        let e1_idx = experts[0]
        let e2_idx = experts[1]
        let w1 = weights[0]
        let w2 = weights[1]

        // Run through selected experts
        let out1 = expert_forward(token, expert_w1[e1_idx], expert_w2[e1_idx])
        let out2 = expert_forward(token, expert_w1[e2_idx], expert_w2[e2_idx])

        // Weighted combination
        let combined = add_vec(scale_vec(out1, w1), scale_vec(out2, w2))

        outputs = push(outputs, combined)
        println(format("  Token {} output: [{}, {}, {}, {}]", to_string(t), to_string(combined[0]), to_string(combined[1]), to_string(combined[2]), to_string(combined[3])))
    }

    // --- Step 3: Load balancing analysis ---
    println("")
    println("--- Step 3: Load Balancing Analysis ---")
    let total_assignments = n_tokens * top_k
    let ideal_load = total_assignments / n_experts

    for e in 0..n_experts {
        let load = expert_load[e]
        let pct = (load * 100) / total_assignments
        println(format("  Expert {}: {} assignments ({}% of total, ideal={})", to_string(e), to_string(load), to_string(pct), to_string(ideal_load)))
    }

    // Check if any expert is overloaded or starved
    var balanced = true
    for e in 0..n_experts {
        if expert_load[e] > ideal_load * 3 {
            println(format("  WARNING: Expert {} is overloaded!", to_string(e)))
            balanced = false
        }
        if expert_load[e] == 0 {
            println(format("  WARNING: Expert {} got no tokens!", to_string(e)))
            balanced = false
        }
    }
    if balanced {
        println("  Load balancing: OK (no expert severely over/under-loaded)")
    }

    // --- Step 4: Validation ---
    println("")
    println("--- Step 4: Output Validation ---")
    var all_valid = true
    for t in 0..n_tokens {
        let out = outputs[t]
        for d in 0..d_model {
            let val = out[d]
            // Check not NaN (NaN != NaN)
            if val != val {
                println(format("  FAIL: Token {} dim {} is NaN", to_string(t), to_string(d)))
                all_valid = false
            }
        }
        if len(out) != d_model {
            println(format("  FAIL: Token {} has wrong dimension {}", to_string(t), to_string(len(out))))
            all_valid = false
        }
    }

    if all_valid {
        println(format("  All {} tokens produced valid {}-dimensional outputs", to_string(n_tokens), to_string(d_model)))
    }

    // --- Step 5: Demonstrate sparse_topk builtin ---
    println("")
    println("--- Step 5: Sparse Top-K Builtin Demo ---")
    let sample_logits = [0.1, 0.8, 0.3, 0.6]
    let topk_idx = sparse_topk(sample_logits, 2)
    let gathered = sparse_gather(sample_logits, topk_idx)
    println(format("  Logits: {}", to_string(sample_logits)))
    println(format("  Top-2 gathered: {}", to_string(gathered)))
    let scattered = sparse_scatter(gathered, topk_idx, 4)
    println(format("  Scattered back: {}", to_string(scattered)))

    println("")
    println("=== MoE Router Complete ===")
}
