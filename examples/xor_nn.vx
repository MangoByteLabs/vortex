// xor_nn.vx - First AI model trained and run in Vortex
// XOR Neural Network: 2 -> 2 hidden (tanh) -> 1 (sigmoid)
// Training via batch gradient descent with manual backprop

fn main() {
    println("=== XOR Neural Network ===")
    println("Architecture: 2 -> 2 (tanh) -> 1 (sigmoid)")
    println("Training: batch gradient descent")
    println("")

    // XOR data
    var x0s = [0.0, 0.0, 1.0, 1.0]
    var x1s = [0.0, 1.0, 0.0, 1.0]
    var ys  = [0.0, 1.0, 1.0, 0.0]

    // Weights: W1 2x2, b1 2, W2 2, b2 1 = 9 params
    // w00,w10 are weights for hidden unit 0 from x0,x1
    // w01,w11 are weights for hidden unit 1 from x0,x1
    var w00 = 1.5
    var w01 = -1.5
    var w10 = 1.5
    var w11 = -1.5
    var b0 = -0.7
    var b1 = 0.7
    var v0 = 2.0
    var v1 = 2.0
    var b2 = -1.0

    var lr = 3.0
    var epochs = 200

    var epoch = 0
    while epoch < epochs {
        var gw00 = 0.0
        var gw01 = 0.0
        var gw10 = 0.0
        var gw11 = 0.0
        var gb0 = 0.0
        var gb1 = 0.0
        var gv0 = 0.0
        var gv1 = 0.0
        var gb2 = 0.0
        var total_loss = 0.0

        var s = 0
        while s < 4 {
            var x0 = x0s[s]
            var x1 = x1s[s]
            var y = ys[s]

            // Forward: hidden with tanh
            var z0 = w00 * x0 + w10 * x1 + b0
            var e0p = exp(z0)
            var e0n = exp(0.0 - z0)
            var h0 = (e0p - e0n) / (e0p + e0n)

            var z1 = w01 * x0 + w11 * x1 + b1
            var e1p = exp(z1)
            var e1n = exp(0.0 - z1)
            var h1 = (e1p - e1n) / (e1p + e1n)

            // Output: sigmoid
            var zo = v0 * h0 + v1 * h1 + b2
            var o = 1.0 / (1.0 + exp(0.0 - zo))

            var err = o - y
            total_loss = total_loss + err * err

            // Backprop
            var d_zo = 2.0 * err * o * (1.0 - o)
            gv0 = gv0 + d_zo * h0
            gv1 = gv1 + d_zo * h1
            gb2 = gb2 + d_zo

            // tanh derivative: 1 - h^2
            var d_h0 = d_zo * v0 * (1.0 - h0 * h0)
            var d_h1 = d_zo * v1 * (1.0 - h1 * h1)

            gw00 = gw00 + d_h0 * x0
            gw01 = gw01 + d_h1 * x0
            gw10 = gw10 + d_h0 * x1
            gw11 = gw11 + d_h1 * x1
            gb0 = gb0 + d_h0
            gb1 = gb1 + d_h1

            s = s + 1
        }

        total_loss = total_loss / 4.0

        w00 = w00 - lr * gw00 / 4.0
        w01 = w01 - lr * gw01 / 4.0
        w10 = w10 - lr * gw10 / 4.0
        w11 = w11 - lr * gw11 / 4.0
        b0 = b0 - lr * gb0 / 4.0
        b1 = b1 - lr * gb1 / 4.0
        v0 = v0 - lr * gv0 / 4.0
        v1 = v1 - lr * gv1 / 4.0
        b2 = b2 - lr * gb2 / 4.0

        if epoch % 25 == 0 {
            println("Epoch " + to_string(epoch) + ": loss = " + to_string(total_loss))
        }

        epoch = epoch + 1
    }

    // Final predictions
    println("")
    println("=== Final Predictions ===")

    var s = 0
    var correct = 0
    while s < 4 {
        var x0 = x0s[s]
        var x1 = x1s[s]
        var y = ys[s]

        var z0 = w00 * x0 + w10 * x1 + b0
        var e0p = exp(z0)
        var e0n = exp(0.0 - z0)
        var h0 = (e0p - e0n) / (e0p + e0n)
        var z1 = w01 * x0 + w11 * x1 + b1
        var e1p = exp(z1)
        var e1n = exp(0.0 - z1)
        var h1 = (e1p - e1n) / (e1p + e1n)
        var zo = v0 * h0 + v1 * h1 + b2
        var o = 1.0 / (1.0 + exp(0.0 - zo))

        println(to_string(x0) + " XOR " + to_string(x1) + " = " + to_string(o) + " (expected " + to_string(y) + ")")

        if y < 0.5 {
            if o < 0.5 { correct = correct + 1 }
        } else {
            if o > 0.5 { correct = correct + 1 }
        }

        s = s + 1
    }

    println("")
    println("Accuracy: " + to_string(correct) + "/4")

    if correct == 4 {
        println("SUCCESS: Network learned XOR!")
    }
}
