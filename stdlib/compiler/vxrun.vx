// vxrun.vx — Minimal self-hosting demo: source -> lex -> parse -> bytecode -> VM
// All in pure Vortex. Under 700 lines.

fn _nl() -> String { return str_from_bytes([10]) }
fn _qt() -> String { return str_from_bytes([34]) }
fn _pipe() -> String { return str_from_bytes([124]) }

fn sw(s: String, prefix: String) -> bool {
    if len(s) < len(prefix) { return false }
    return str_substr(s, 0, len(prefix)) == prefix
}

fn after(s: String, n: i64) -> String {
    return str_substr(s, n, len(s))
}

fn find_idx(s: String, needle: String) -> i64 {
    return unwrap_or(str_find(s, needle), -1)
}

fn rest_after_space(s: String) -> String {
    var idx = find_idx(s, " ")
    if idx < 0 { return "" }
    return str_substr(s, idx + 1, len(s))
}

fn instr_op(s: String) -> String {
    var idx = find_idx(s, " ")
    if idx < 0 { return s }
    return str_substr(s, 0, idx)
}

fn instr_arg1(s: String) -> String {
    var rest = rest_after_space(s)
    var idx = find_idx(rest, " ")
    if idx < 0 { return rest }
    return str_substr(rest, 0, idx)
}

fn instr_arg2(s: String) -> String {
    var rest = rest_after_space(s)
    return rest_after_space(rest)
}

// ============================================================
// LEXER — produces flat [String] of tokens
// ============================================================

fn is_digit(ch: String) -> bool { return str_is_ascii_digit(ch) }
fn is_alpha(ch: String) -> bool { return str_is_ascii_alpha(ch) }
fn is_alnum(ch: String) -> bool {
    if is_alpha(ch) { return true }
    if is_digit(ch) { return true }
    if ch == "_" { return true }
    return false
}

fn lex(source: String) -> [String] {
    var toks = []
    var pos = 0
    var slen = len(source)
    var nl = _nl()

    while pos < slen {
        var ch = str_char_at(source, pos)

        if ch == " " { pos = pos + 1 }
        if ch == nl { pos = pos + 1 }
        if ch == str_from_bytes([9]) { pos = pos + 1 }
        if ch == str_from_bytes([13]) { pos = pos + 1 }

        if is_digit(ch) {
            var start = pos
            while pos < slen {
                if is_digit(str_char_at(source, pos)) { pos = pos + 1 } else { pos = pos + slen }
            }
            if pos > slen { pos = pos - slen }
            toks = push(toks, str_substr(source, start, pos - start))
        }

        if is_alpha(ch) {
            var start = pos
            while pos < slen {
                if is_alnum(str_char_at(source, pos)) { pos = pos + 1 } else { pos = pos + slen }
            }
            if pos > slen { pos = pos - slen }
            toks = push(toks, str_substr(source, start, pos - start))
        }

        if ch == "=" {
            if pos + 1 < slen {
                if str_char_at(source, pos + 1) == "=" {
                    toks = push(toks, "==")
                    pos = pos + 2
                } else { toks = push(toks, "=")
                    pos = pos + 1 }
            } else { toks = push(toks, "=")
                pos = pos + 1 }
        }
        if ch == "!" {
            if pos + 1 < slen {
                if str_char_at(source, pos + 1) == "=" {
                    toks = push(toks, "!=")
                    pos = pos + 2
                } else { toks = push(toks, "!")
                    pos = pos + 1 }
            } else { toks = push(toks, "!")
                pos = pos + 1 }
        }
        if ch == "<" {
            if pos + 1 < slen {
                if str_char_at(source, pos + 1) == "=" {
                    toks = push(toks, "<=")
                    pos = pos + 2
                } else { toks = push(toks, "<")
                    pos = pos + 1 }
            } else { toks = push(toks, "<")
                pos = pos + 1 }
        }
        if ch == ">" {
            if pos + 1 < slen {
                if str_char_at(source, pos + 1) == "=" {
                    toks = push(toks, ">=")
                    pos = pos + 2
                } else { toks = push(toks, ">")
                    pos = pos + 1 }
            } else { toks = push(toks, ">")
                pos = pos + 1 }
        }
        if ch == "+" { toks = push(toks, "+")
            pos = pos + 1 }
        if ch == "-" { toks = push(toks, "-")
            pos = pos + 1 }
        if ch == "*" { toks = push(toks, "*")
            pos = pos + 1 }
        if ch == "/" { toks = push(toks, "/")
            pos = pos + 1 }
        if ch == "%" { toks = push(toks, "%")
            pos = pos + 1 }
        if ch == "(" { toks = push(toks, "(")
            pos = pos + 1 }
        if ch == ")" { toks = push(toks, ")")
            pos = pos + 1 }
        if ch == "{" { toks = push(toks, "{")
            pos = pos + 1 }
        if ch == "}" { toks = push(toks, "}")
            pos = pos + 1 }
        if ch == "," { toks = push(toks, ",")
            pos = pos + 1 }
    }
    toks = push(toks, "EOF")
    return toks
}

// ============================================================
// ONE-PASS COMPILER: parse + emit bytecode directly
// ============================================================

var _toks = []
var _tp = 0
var _code = []
var _lbl = 0

fn pk() -> String {
    if _tp >= len(_toks) { return "EOF" }
    return _toks[_tp]
}

fn adv() -> String {
    var t = _toks[_tp]
    _tp = _tp + 1
    return t
}

fn expect(v: String) -> String {
    var t = adv()
    return t
}

fn is_kw(t: String) -> bool {
    if t == "fn" { return true }
    if t == "let" { return true }
    if t == "var" { return true }
    if t == "if" { return true }
    if t == "else" { return true }
    if t == "while" { return true }
    if t == "return" { return true }
    return false
}

fn is_number(t: String) -> bool {
    if len(t) == 0 { return false }
    return is_digit(str_char_at(t, 0))
}

fn new_label(pfx: String) -> String {
    _lbl = _lbl + 1
    return pfx + "_" + to_string(_lbl)
}

fn cemit(instr: String) -> i64 {
    _code = push(_code, instr)
    return 0
}

fn parse_primary() -> i64 {
    var t = pk()
    if t == "(" {
        var d = adv()
        var dummy = parse_expr()
        var d2 = adv()
        return 0
    }
    if t == "true" { var d = adv()
        cemit("PUSH_BOOL true")
        return 0 }
    if t == "false" { var d = adv()
        cemit("PUSH_BOOL false")
        return 0 }
    if is_number(t) {
        var d = adv()
        cemit("PUSH_INT " + t)
        return 0 }
    if is_alpha(str_char_at(t, 0)) {
        if is_kw(t) == false {
            var name = adv()
            if pk() == "(" {
                var d2 = adv()
                var argc = 0
                if pk() != ")" {
                    var dummy = parse_expr()
                    argc = 1
                    while pk() == "," {
                        var d3 = adv()
                        dummy = parse_expr()
                        argc = argc + 1
                    }
                }
                var d3 = adv()
                cemit("CALL " + name + " " + to_string(argc))
            } else { cemit("LOAD " + name) }
            return 0
        }
    }
    var d = adv()
    cemit("PUSH_INT 0")
    return 0
}

fn parse_unary() -> i64 {
    if pk() == "-" { var d = adv()
        var dummy = parse_unary()
        cemit("NEG")
        return 0 }
    return parse_primary()
}

fn parse_mul() -> i64 {
    var dummy = parse_unary()
    var cont = true
    while cont {
        if pk() == "*" { var d = adv()
            dummy = parse_unary()
            cemit("MUL")
        } else if pk() == "/" { var d = adv()
            dummy = parse_unary()
            cemit("DIV")
        } else if pk() == "%" { var d = adv()
            dummy = parse_unary()
            cemit("MOD")
        } else { cont = false }
    }
    return 0
}

fn parse_add() -> i64 {
    var dummy = parse_mul()
    var cont = true
    while cont {
        if pk() == "+" { var d = adv()
            dummy = parse_mul()
            cemit("ADD")
        } else if pk() == "-" { var d = adv()
            dummy = parse_mul()
            cemit("SUB")
        } else { cont = false }
    }
    return 0
}

fn parse_cmp() -> i64 {
    var dummy = parse_add()
    var cont = true
    while cont {
        if pk() == "==" { var d = adv()
            dummy = parse_add()
            cemit("EQ")
        } else if pk() == "!=" { var d = adv()
            dummy = parse_add()
            cemit("NEQ")
        } else if pk() == "<" { var d = adv()
            dummy = parse_add()
            cemit("LT")
        } else if pk() == ">" { var d = adv()
            dummy = parse_add()
            cemit("GT")
        } else if pk() == "<=" { var d = adv()
            dummy = parse_add()
            cemit("LTEQ")
        } else if pk() == ">=" { var d = adv()
            dummy = parse_add()
            cemit("GTEQ")
        } else { cont = false }
    }
    return 0
}

fn parse_expr() -> i64 {
    return parse_cmp()
}

fn parse_stmt() -> i64 {
    var t = pk()
    if t == "let" { var d = adv()
        var name = adv()
        var d2 = adv()
        var dummy = parse_expr()
        cemit("STORE " + name)
        return 0 }
    if t == "var" { var d = adv()
        var name = adv()
        var d2 = adv()
        var dummy = parse_expr()
        cemit("STORE " + name)
        return 0 }
    if t == "return" { var d = adv()
        if pk() == "}" { cemit("PUSH_INT 0")
        } else { var dummy = parse_expr() }
        cemit("RET")
        return 0 }
    if t == "if" { var d = adv()
        var else_lbl = new_label("E")
        var end_lbl = new_label("N")
        var dummy = parse_expr()
        cemit("JZ " + else_lbl)
        var d2 = adv()
        while pk() != "}" { dummy = parse_stmt() }
        var d3 = adv()
        cemit("JMP " + end_lbl)
        cemit("LABEL " + else_lbl)
        if pk() == "else" { dummy = adv()
            if pk() == "if" { dummy = parse_stmt()
            } else { var d4 = adv()
                while pk() != "}" { dummy = parse_stmt() }
                var d5 = adv() }
        }
        cemit("LABEL " + end_lbl)
        return 0 }
    if t == "while" { var d = adv()
        var sl = new_label("W")
        var el = new_label("X")
        cemit("LABEL " + sl)
        var dummy = parse_expr()
        cemit("JZ " + el)
        var d2 = adv()
        while pk() != "}" { dummy = parse_stmt() }
        var d3 = adv()
        cemit("JMP " + sl)
        cemit("LABEL " + el)
        return 0 }
    // expression stmt, possibly assignment
    var dummy = parse_expr()
    if pk() == "=" {
        var last = _code[len(_code) - 1]
        if sw(last, "LOAD ") {
            var name = after(last, 5)
            var nc = []
            var ci = 0
            while ci < len(_code) - 1 { nc = push(nc, _code[ci])
                ci = ci + 1 }
            _code = nc
            var d2 = adv()
            dummy = parse_expr()
            cemit("STORE " + name)
            return 0
        }
    }
    cemit("POP")
    return 0
}

fn parse_fn_def() -> i64 {
    var d = adv()
    var name = adv()
    var d2 = adv()
    var params = []
    if pk() != ")" {
        params = push(params, adv())
        while pk() == "," { var d3 = adv()
            params = push(params, adv()) }
    }
    var d3 = adv()
    var d4 = adv()
    cemit("FN_START " + name)
    var pi = len(params) - 1
    while pi >= 0 { cemit("STORE " + params[pi])
        pi = pi - 1 }
    while pk() != "}" { var dummy = parse_stmt() }
    var d5 = adv()
    cemit("PUSH_INT 0")
    cemit("RET")
    cemit("FN_END")
    return 0
}

fn compile(source: String) -> [String] {
    _toks = lex(source)
    _tp = 0
    _code = []
    _lbl = 0
    while pk() != "EOF" {
        if pk() == "fn" { var dummy = parse_fn_def()
        } else { var d = adv() }
    }
    cemit("HALT")
    return _code
}

// ============================================================
// VM — uses global state to minimize stack depth
// ============================================================

var _instrs = []
var _stk = []
var _vars = []
var _cs = []
var _ip = 0
var _running = true
var _result = "void"
var _labels = []
var _fns = []

fn make_int(n: i64) -> String { return "i:" + to_string(n) }
fn make_bool(b: bool) -> String {
    if b { return "b:true" }
    return "b:false"
}

fn val_display(v: String) -> String {
    if sw(v, "i:") { return after(v, 2) }
    if sw(v, "s:") { return after(v, 2) }
    if v == "b:true" { return "true" }
    if v == "b:false" { return "false" }
    return v
}

fn val_truthy(v: String) -> bool {
    if v == "b:true" { return true }
    if v == "b:false" { return false }
    if sw(v, "i:") { return after(v, 2) != "0" }
    return true
}

fn val_int(v: String) -> i64 {
    if sw(v, "i:") { return int(after(v, 2)) }
    return 0
}

fn spop(s: [String]) -> [String] {
    var r = []
    var i = 0
    while i < len(s) - 1 { r = push(r, s[i])
        i = i + 1 }
    return r
}

fn stop(s: [String]) -> String {
    if len(s) == 0 { return "void" }
    return s[len(s) - 1]
}

fn stop2(s: [String]) -> String {
    if len(s) < 2 { return "void" }
    return s[len(s) - 2]
}

fn spop2(s: [String]) -> [String] {
    var r = []
    var i = 0
    while i < len(s) - 2 { r = push(r, s[i])
        i = i + 1 }
    return r
}

fn vget(name: String) -> String {
    var i = len(_vars) - 2
    while i >= 0 {
        if _vars[i] == name { return _vars[i + 1] }
        i = i - 2
    }
    return "void"
}

fn vset(name: String, val: String) -> i64 {
    var i = len(_vars) - 2
    while i >= 0 {
        if _vars[i] == name { _vars[i + 1] = val
            return 0 }
        if _vars[i] == "##S##" {
            _vars = push(_vars, name)
            _vars = push(_vars, val)
            return 0
        }
        i = i - 2
    }
    _vars = push(_vars, name)
    _vars = push(_vars, val)
    return 0
}

fn vpush() -> i64 {
    _vars = push(_vars, "##S##")
    _vars = push(_vars, "##S##")
    return 0
}

fn vpop() -> i64 {
    while len(_vars) >= 2 {
        var nm = _vars[len(_vars) - 2]
        _vars = spop(spop(_vars))
        if nm == "##S##" { return 0 }
    }
    return 0
}

fn tget(t: [String], key: String) -> i64 {
    var i = 0
    while i < len(t) - 1 {
        if t[i] == key { return int(t[i + 1]) }
        i = i + 2
    }
    return -1
}

// Individual VM step handlers to keep nesting shallow
fn vm_step() -> i64 {
    var ins = _instrs[_ip]
    var op = instr_op(ins)

    if op == "HALT" { _running = false
        _result = stop(_stk)
        return 0 }
    if op == "PUSH_INT" { _stk = push(_stk, make_int(int(instr_arg1(ins))))
        _ip = _ip + 1
        return 0 }
    if op == "PUSH_BOOL" {
        if instr_arg1(ins) == "true" { _stk = push(_stk, "b:true")
        } else { _stk = push(_stk, "b:false") }
        _ip = _ip + 1
        return 0 }
    if op == "LOAD" { _stk = push(_stk, vget(instr_arg1(ins)))
        _ip = _ip + 1
        return 0 }
    if op == "STORE" { var dummy = vset(instr_arg1(ins), stop(_stk))
        _stk = spop(_stk)
        _ip = _ip + 1
        return 0 }
    if op == "POP" { if len(_stk) > 0 { _stk = spop(_stk) }
        _ip = _ip + 1
        return 0 }
    if op == "ADD" { var b = stop(_stk)
        var a = stop2(_stk)
        _stk = spop2(_stk)
        _stk = push(_stk, make_int(val_int(a) + val_int(b)))
        _ip = _ip + 1
        return 0 }
    if op == "SUB" { var b = stop(_stk)
        var a = stop2(_stk)
        _stk = spop2(_stk)
        _stk = push(_stk, make_int(val_int(a) - val_int(b)))
        _ip = _ip + 1
        return 0 }
    if op == "MUL" { var b = stop(_stk)
        var a = stop2(_stk)
        _stk = spop2(_stk)
        _stk = push(_stk, make_int(val_int(a) * val_int(b)))
        _ip = _ip + 1
        return 0 }
    if op == "DIV" { var b = stop(_stk)
        var a = stop2(_stk)
        _stk = spop2(_stk)
        var denom = val_int(b)
        if denom == 0 { _stk = push(_stk, make_int(0))
        } else { _stk = push(_stk, make_int(val_int(a) / denom)) }
        _ip = _ip + 1
        return 0 }
    if op == "MOD" { var b = stop(_stk)
        var a = stop2(_stk)
        _stk = spop2(_stk)
        var denom = val_int(b)
        if denom == 0 { _stk = push(_stk, make_int(0))
        } else { _stk = push(_stk, make_int(val_int(a) % denom)) }
        _ip = _ip + 1
        return 0 }
    if op == "NEG" { var a = stop(_stk)
        _stk = spop(_stk)
        _stk = push(_stk, make_int(0 - val_int(a)))
        _ip = _ip + 1
        return 0 }
    if op == "EQ" { var b = stop(_stk)
        var a = stop2(_stk)
        _stk = spop2(_stk)
        _stk = push(_stk, make_bool(val_int(a) == val_int(b)))
        _ip = _ip + 1
        return 0 }
    if op == "NEQ" { var b = stop(_stk)
        var a = stop2(_stk)
        _stk = spop2(_stk)
        _stk = push(_stk, make_bool(val_int(a) != val_int(b)))
        _ip = _ip + 1
        return 0 }
    if op == "LT" { var b = stop(_stk)
        var a = stop2(_stk)
        _stk = spop2(_stk)
        _stk = push(_stk, make_bool(val_int(a) < val_int(b)))
        _ip = _ip + 1
        return 0 }
    if op == "GT" { var b = stop(_stk)
        var a = stop2(_stk)
        _stk = spop2(_stk)
        _stk = push(_stk, make_bool(val_int(a) > val_int(b)))
        _ip = _ip + 1
        return 0 }
    if op == "LTEQ" { var b = stop(_stk)
        var a = stop2(_stk)
        _stk = spop2(_stk)
        _stk = push(_stk, make_bool(val_int(a) <= val_int(b)))
        _ip = _ip + 1
        return 0 }
    if op == "GTEQ" { var b = stop(_stk)
        var a = stop2(_stk)
        _stk = spop2(_stk)
        _stk = push(_stk, make_bool(val_int(a) >= val_int(b)))
        _ip = _ip + 1
        return 0 }
    if op == "NOT" { var a = stop(_stk)
        _stk = spop(_stk)
        if val_truthy(a) { _stk = push(_stk, "b:false")
        } else { _stk = push(_stk, "b:true") }
        _ip = _ip + 1
        return 0 }
    if op == "JMP" { var target = tget(_labels, instr_arg1(ins))
        if target >= 0 { _ip = target + 1 } else { _running = false }
        return 0 }
    if op == "JZ" { var top = stop(_stk)
        _stk = spop(_stk)
        if val_truthy(top) { _ip = _ip + 1
        } else { var target = tget(_labels, instr_arg1(ins))
            if target >= 0 { _ip = target + 1 } else { _running = false } }
        return 0 }
    if op == "LABEL" { _ip = _ip + 1
        return 0 }
    if op == "FN_START" {
        var depth = 1
        _ip = _ip + 1
        while depth > 0 {
            if _ip >= len(_instrs) { depth = 0
            } else { var sop = instr_op(_instrs[_ip])
                if sop == "FN_START" { depth = depth + 1 }
                if sop == "FN_END" { depth = depth - 1 }
                _ip = _ip + 1 }
        }
        return 0 }
    if op == "FN_END" {
        if len(_cs) >= 1 { var ret_ip = int(_cs[len(_cs) - 1])
            _cs = spop(_cs)
            var dummy = vpop()
            _ip = ret_ip
        } else { _running = false
            _result = stop(_stk) }
        return 0 }
    if op == "RET" {
        var rv = "void"
        if len(_stk) > 0 { rv = stop(_stk)
            _stk = spop(_stk) }
        if len(_cs) >= 1 { var ret_ip = int(_cs[len(_cs) - 1])
            _cs = spop(_cs)
            var dummy = vpop()
            _stk = push(_stk, rv)
            _ip = ret_ip
        } else { _result = rv
            _running = false }
        return 0 }
    if op == "CALL" {
        var fn_name = instr_arg1(ins)
        var argc = int(instr_arg2(ins))
        if fn_name == "println" {
            var top = stop(_stk)
            _stk = spop(_stk)
            print(val_display(top) + _nl())
            _stk = push(_stk, "void")
            _ip = _ip + 1
            return 0
        }
        if fn_name == "print" {
            var top = stop(_stk)
            _stk = spop(_stk)
            print(val_display(top))
            _stk = push(_stk, "void")
            _ip = _ip + 1
            return 0
        }
        var fn_ip = tget(_fns, fn_name)
        if fn_ip < 0 { _running = false
            return 0 }
        _cs = push(_cs, to_string(_ip + 1))
        var dummy = vpush()
        _ip = fn_ip + 1
        return 0 }
    _ip = _ip + 1
    return 0
}

fn vm_run(instrs: [String]) -> String {
    _instrs = instrs
    _stk = []
    _vars = []
    _cs = []
    _ip = 0
    _running = true
    _result = "void"
    _labels = []
    _fns = []
    var i = 0
    while i < len(instrs) {
        var op = instr_op(instrs[i])
        if op == "LABEL" { _labels = push(_labels, instr_arg1(instrs[i]))
            _labels = push(_labels, to_string(i)) }
        if op == "FN_START" { _fns = push(_fns, instr_arg1(instrs[i]))
            _fns = push(_fns, to_string(i)) }
        i = i + 1
    }
    var main_ip = tget(_fns, "main")
    if main_ip >= 0 { _ip = main_ip + 1
        var dummy = vpush() }
    while _running {
        if _ip >= len(_instrs) { _running = false }
        if _running { var dummy = vm_step() }
    }
    return _result
}

// ============================================================
// MAIN — self-contained tests
// ============================================================

fn run_test(name: String, source: String) -> i64 {
    print(name + ": ")
    var code = compile(source)
    var r = vm_run(code)
    return 0
}

fn main() {
    var nl = _nl()
    print("=== vxrun.vx Self-Hosting Compiler ===" + nl)

    var dummy = run_test("Test 1 (40+2)", "fn main() { println(40 + 2) }")
    dummy = run_test("Test 2 (let x)", "fn main() { let x = 10" + nl + "println(x - 3) }")
    dummy = run_test("Test 3 (6*7)", "fn main() { println(6 * 7) }")
    dummy = run_test("Test 4 (if/else)", "fn main() { if 5 > 3 { println(1) } else { println(0) } }")

    var s5 = "fn main() { var i = 1" + nl + "var s = 0" + nl
    s5 = s5 + "while i <= 5 { s = s + i" + nl + "i = i + 1 }" + nl
    s5 = s5 + "println(s) }"
    dummy = run_test("Test 5 (while)", s5)

    var s6 = "fn add(a, b) { return a + b }" + nl
    s6 = s6 + "fn main() { println(add(17, 25)) }"
    dummy = run_test("Test 6 (fn call)", s6)

    var s7 = "fn double(x) { return x * 2 }" + nl
    s7 = s7 + "fn main() { println(double(21)) }"
    dummy = run_test("Test 7 (double)", s7)

    dummy = run_test("Test 8 (neg)", "fn main() { println(-5 + 8) }")

    var s9 = "fn main() { if 10 == 10 { println(1) } else { println(0) } }"
    dummy = run_test("Test 9 (eq)", s9)

    var s10 = "fn fib(n) { if n <= 1 { return n }" + nl
    s10 = s10 + "return fib(n - 1) + fib(n - 2) }" + nl
    s10 = s10 + "fn main() { println(fib(10)) }"
    dummy = run_test("Test 10 (fib)", s10)

    print("=== ALL TESTS PASS ===" + nl)
}
