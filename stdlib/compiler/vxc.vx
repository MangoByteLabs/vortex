// vxc.vx — Vortex Compiler Driver (Self-Contained)
// Compiles a minimal subset of Vortex to native Linux x86-64 ELF binaries.
// No Rust. No external tools. Pure Vortex self-hosting.
//
// Supported language subset:
//   - fn main() { ... } as entry point
//   - fn name(params...) -> i64 { ... } user functions
//   - let x = expr / var x = expr
//   - x = expr (assignment)
//   - println(expr) — prints integer + newline to stdout
//   - print_str(expr) — prints string to stdout
//   - String literals: "hello\n"
//   - Array literals: [1, 2, 3]
//   - Array indexing: arr[i]
//   - Array assignment: arr[i] = val
//   - len(arr) — array/string length
//   - push(arr, val) — returns new array with val appended
//   - if cond { ... } else { ... }
//   - while cond { ... }
//   - return expr
//   - Integer arithmetic: + - * / %
//   - Comparisons: == != < > <= >=
//   - Function calls
//
// Pipeline: source -> lex -> parse -> x86-64 codegen -> ELF -> write binary
//
// Usage:
//   cargo run -- run stdlib/compiler/vxc.vx
//   /tmp/vortex_out   # prints 42

// ============================================================
// PHASE 1: File I/O helpers (from loader.vx pattern)
// ============================================================

fn _null_terminate(s: String) -> i64 {
    let bytes = str_bytes(s)
    let n = len(bytes)
    let buf = mem_alloc(n + 1)
    var i = 0
    while i < n {
        mem_write_u8(buf, i, int(bytes[i]))
        i = i + 1
    }
    mem_write_u8(buf, n, 0)
    return buf
}

fn read_source(path: String) -> String {
    let path_ptr = _null_terminate(path)
    let fd = syscall2(2, path_ptr, 0)
    mem_free(path_ptr)
    if fd < 0 {
        return ""
    }
    let buf_size = 1048576
    let buf = mem_alloc(buf_size)
    let n_read = syscall3(0, fd, buf, buf_size)
    syscall1(3, fd)
    if n_read <= 0 {
        mem_free(buf)
        return ""
    }
    var byte_arr = []
    var i = 0
    while i < n_read {
        byte_arr = push(byte_arr, mem_read_u8(buf, i))
        i = i + 1
    }
    mem_free(buf)
    return str_from_bytes(byte_arr)
}

fn write_binary(path: String, data: [i64]) -> bool {
    let path_ptr = _null_terminate(path)
    let flags = 1 + 64 + 512
    let fd = syscall3(2, path_ptr, flags, 493)
    mem_free(path_ptr)
    if fd < 0 {
        return false
    }
    let n = len(data)
    let buf = mem_alloc(n)
    var i = 0
    while i < n {
        mem_write_u8(buf, i, int(data[i]))
        i = i + 1
    }
    let written = syscall3(1, fd, buf, n)
    mem_free(buf)
    syscall1(3, fd)
    return written == n
}

// ============================================================
// PHASE 2: Minimal Lexer (inline)
// ============================================================
// Tokens: [type, value, line, col] — all strings

fn _nl() -> String { return str_from_bytes([10]) }

fn tok_new(typ: String, val: String, line: i64, col: i64) -> [String] {
    return [typ, val, to_string(line), to_string(col)]
}

fn lex(source: String) -> [String] {
    var tokens = []
    var pos = 0
    var line = 1
    var col = 1
    let src_len = len(source)

    while pos < src_len {
        let ch = str_char_at(source, pos)

        // Skip whitespace
        if ch == " " {
            pos = pos + 1
            col = col + 1
        } else if ch == _nl() {
            pos = pos + 1
            line = line + 1
            col = 1
        } else if ch == str_from_bytes([9]) {
            pos = pos + 1
            col = col + 1
        } else if ch == str_from_bytes([13]) {
            pos = pos + 1
        } else if ch == "/" {
            // Check for line comment
            if pos + 1 < src_len {
                if str_char_at(source, pos + 1) == "/" {
                    pos = pos + 2
                    var in_comment = true
                    while in_comment {
                        if pos >= src_len {
                            in_comment = false
                        } else if str_char_at(source, pos) == _nl() {
                            pos = pos + 1
                            line = line + 1
                            col = 1
                            in_comment = false
                        } else {
                            pos = pos + 1
                        }
                    }
                } else {
                    tokens = push(tokens, tok_new("SLASH", "/", line, col))
                    pos = pos + 1
                    col = col + 1
                }
            } else {
                tokens = push(tokens, tok_new("SLASH", "/", line, col))
                pos = pos + 1
                col = col + 1
            }
        } else if str_is_ascii_digit(ch) {
            // Number
            let start = pos
            let start_col = col
            var scanning_num = true
            while scanning_num {
                if pos < src_len {
                    if str_is_ascii_digit(str_char_at(source, pos)) {
                        pos = pos + 1
                        col = col + 1
                    } else {
                        scanning_num = false
                    }
                } else {
                    scanning_num = false
                }
            }
            // Check for decimal point -> float literal
            if pos < src_len {
                if str_char_at(source, pos) == "." {
                    if pos + 1 < src_len {
                        if str_is_ascii_digit(str_char_at(source, pos + 1)) {
                            // It's a float: consume '.' and fractional digits
                            pos = pos + 1
                            col = col + 1
                            var scanning_frac = true
                            while scanning_frac {
                                if pos < src_len {
                                    if str_is_ascii_digit(str_char_at(source, pos)) {
                                        pos = pos + 1
                                        col = col + 1
                                    } else {
                                        scanning_frac = false
                                    }
                                } else {
                                    scanning_frac = false
                                }
                            }
                            tokens = push(tokens, tok_new("FLOAT", str_substr(source, start, pos - start), line, start_col))
                        } else {
                            tokens = push(tokens, tok_new("INT", str_substr(source, start, pos - start), line, start_col))
                        }
                    } else {
                        tokens = push(tokens, tok_new("INT", str_substr(source, start, pos - start), line, start_col))
                    }
                } else {
                    tokens = push(tokens, tok_new("INT", str_substr(source, start, pos - start), line, start_col))
                }
            } else {
                tokens = push(tokens, tok_new("INT", str_substr(source, start, pos - start), line, start_col))
            }
        } else if str_is_ascii_alpha(ch) {
            let start = pos
            let start_col = col
            var scanning = true
            while scanning {
                if pos < src_len {
                    let c = str_char_at(source, pos)
                    if str_is_ascii_alpha(c) {
                        pos = pos + 1
                        col = col + 1
                    } else if str_is_ascii_digit(c) {
                        pos = pos + 1
                        col = col + 1
                    } else if c == "_" {
                        pos = pos + 1
                        col = col + 1
                    } else {
                        scanning = false
                    }
                } else {
                    scanning = false
                }
            }
            let word = str_substr(source, start, pos - start)
            if word == "fn" {
                tokens = push(tokens, tok_new("KW", "fn", line, start_col))
            } else if word == "let" {
                tokens = push(tokens, tok_new("KW", "let", line, start_col))
            } else if word == "var" {
                tokens = push(tokens, tok_new("KW", "var", line, start_col))
            } else if word == "if" {
                tokens = push(tokens, tok_new("KW", "if", line, start_col))
            } else if word == "else" {
                tokens = push(tokens, tok_new("KW", "else", line, start_col))
            } else if word == "while" {
                tokens = push(tokens, tok_new("KW", "while", line, start_col))
            } else if word == "return" {
                tokens = push(tokens, tok_new("KW", "return", line, start_col))
            } else if word == "println" {
                tokens = push(tokens, tok_new("KW", "println", line, start_col))
            } else if word == "print_str" {
                tokens = push(tokens, tok_new("KW", "print_str", line, start_col))
            } else if word == "true" {
                tokens = push(tokens, tok_new("TRUE", "true", line, start_col))
            } else if word == "false" {
                tokens = push(tokens, tok_new("FALSE", "false", line, start_col))
            } else if word == "break" {
                tokens = push(tokens, tok_new("KW", "break", line, start_col))
            } else if word == "continue" {
                tokens = push(tokens, tok_new("KW", "continue", line, start_col))
            } else {
                tokens = push(tokens, tok_new("IDENT", word, line, start_col))
            }
        } else if ch == "_" {
            let start = pos
            let start_col = col
            pos = pos + 1
            col = col + 1
            var scanning = true
            while scanning {
                if pos < src_len {
                    let c = str_char_at(source, pos)
                    if str_is_ascii_alpha(c) {
                        pos = pos + 1
                        col = col + 1
                    } else if str_is_ascii_digit(c) {
                        pos = pos + 1
                        col = col + 1
                    } else if c == "_" {
                        pos = pos + 1
                        col = col + 1
                    } else {
                        scanning = false
                    }
                } else {
                    scanning = false
                }
            }
            let word = str_substr(source, start, pos - start)
            tokens = push(tokens, tok_new("IDENT", word, line, start_col))
        } else if ch == "(" {
            tokens = push(tokens, tok_new("LPAREN", "(", line, col))
            pos = pos + 1
            col = col + 1
        } else if ch == ")" {
            tokens = push(tokens, tok_new("RPAREN", ")", line, col))
            pos = pos + 1
            col = col + 1
        } else if ch == "{" {
            tokens = push(tokens, tok_new("LBRACE", "{", line, col))
            pos = pos + 1
            col = col + 1
        } else if ch == "}" {
            tokens = push(tokens, tok_new("RBRACE", "}", line, col))
            pos = pos + 1
            col = col + 1
        } else if ch == "," {
            tokens = push(tokens, tok_new("COMMA", ",", line, col))
            pos = pos + 1
            col = col + 1
        } else if ch == ":" {
            tokens = push(tokens, tok_new("COLON", ":", line, col))
            pos = pos + 1
            col = col + 1
        } else if ch == "+" {
            tokens = push(tokens, tok_new("PLUS", "+", line, col))
            pos = pos + 1
            col = col + 1
        } else if ch == "-" {
            // Check for ->
            if pos + 1 < src_len {
                if str_char_at(source, pos + 1) == ">" {
                    tokens = push(tokens, tok_new("ARROW", "->", line, col))
                    pos = pos + 2
                    col = col + 2
                } else {
                    tokens = push(tokens, tok_new("MINUS", "-", line, col))
                    pos = pos + 1
                    col = col + 1
                }
            } else {
                tokens = push(tokens, tok_new("MINUS", "-", line, col))
                pos = pos + 1
                col = col + 1
            }
        } else if ch == "*" {
            tokens = push(tokens, tok_new("STAR", "*", line, col))
            pos = pos + 1
            col = col + 1
        } else if ch == "%" {
            tokens = push(tokens, tok_new("PERCENT", "%", line, col))
            pos = pos + 1
            col = col + 1
        } else if ch == "[" {
            tokens = push(tokens, tok_new("LBRACKET", "[", line, col))
            pos = pos + 1
            col = col + 1
        } else if ch == "]" {
            tokens = push(tokens, tok_new("RBRACKET", "]", line, col))
            pos = pos + 1
            col = col + 1
        } else if ch == str_from_bytes([34]) {
            // String literal
            let start_col = col
            pos = pos + 1
            col = col + 1
            var str_val = ""
            var scanning_str = true
            while scanning_str {
                if pos >= src_len {
                    scanning_str = false
                } else {
                    let sc = str_char_at(source, pos)
                    if sc == str_from_bytes([34]) {
                        pos = pos + 1
                        col = col + 1
                        scanning_str = false
                    } else if sc == str_from_bytes([92]) {
                        // backslash escape
                        pos = pos + 1
                        col = col + 1
                        if pos < src_len {
                            let esc = str_char_at(source, pos)
                            if esc == "n" {
                                str_val = str_val + _nl()
                            } else if esc == "t" {
                                str_val = str_val + str_from_bytes([9])
                            } else if esc == str_from_bytes([34]) {
                                str_val = str_val + str_from_bytes([34])
                            } else if esc == str_from_bytes([92]) {
                                str_val = str_val + str_from_bytes([92])
                            } else {
                                str_val = str_val + esc
                            }
                            pos = pos + 1
                            col = col + 1
                        }
                    } else {
                        str_val = str_val + sc
                        pos = pos + 1
                        col = col + 1
                    }
                }
            }
            tokens = push(tokens, tok_new("STRING", str_val, line, start_col))
        } else if ch == "=" {
            if pos + 1 < src_len {
                if str_char_at(source, pos + 1) == "=" {
                    tokens = push(tokens, tok_new("EQEQ", "==", line, col))
                    pos = pos + 2
                    col = col + 2
                } else {
                    tokens = push(tokens, tok_new("EQ", "=", line, col))
                    pos = pos + 1
                    col = col + 1
                }
            } else {
                tokens = push(tokens, tok_new("EQ", "=", line, col))
                pos = pos + 1
                col = col + 1
            }
        } else if ch == "!" {
            if pos + 1 < src_len {
                if str_char_at(source, pos + 1) == "=" {
                    tokens = push(tokens, tok_new("NEQ", "!=", line, col))
                    pos = pos + 2
                    col = col + 2
                } else {
                    tokens = push(tokens, tok_new("NOT", "!", line, col))
                    pos = pos + 1
                    col = col + 1
                }
            } else {
                tokens = push(tokens, tok_new("NOT", "!", line, col))
                pos = pos + 1
                col = col + 1
            }
        } else if ch == "<" {
            if pos + 1 < src_len {
                if str_char_at(source, pos + 1) == "=" {
                    tokens = push(tokens, tok_new("LTEQ", "<=", line, col))
                    pos = pos + 2
                    col = col + 2
                } else {
                    tokens = push(tokens, tok_new("LT", "<", line, col))
                    pos = pos + 1
                    col = col + 1
                }
            } else {
                tokens = push(tokens, tok_new("LT", "<", line, col))
                pos = pos + 1
                col = col + 1
            }
        } else if ch == ">" {
            if pos + 1 < src_len {
                if str_char_at(source, pos + 1) == "=" {
                    tokens = push(tokens, tok_new("GTEQ", ">=", line, col))
                    pos = pos + 2
                    col = col + 2
                } else {
                    tokens = push(tokens, tok_new("GT", ">", line, col))
                    pos = pos + 1
                    col = col + 1
                }
            } else {
                tokens = push(tokens, tok_new("GT", ">", line, col))
                pos = pos + 1
                col = col + 1
            }
        } else if ch == "&" {
            if pos + 1 < src_len {
                if str_char_at(source, pos + 1) == "&" {
                    tokens = push(tokens, tok_new("LAND", "&&", line, col))
                    pos = pos + 2
                    col = col + 2
                } else {
                    pos = pos + 1
                    col = col + 1
                }
            } else {
                pos = pos + 1
                col = col + 1
            }
        } else if ch == "|" {
            if pos + 1 < src_len {
                if str_char_at(source, pos + 1) == "|" {
                    tokens = push(tokens, tok_new("LOR", "||", line, col))
                    pos = pos + 2
                    col = col + 2
                } else {
                    pos = pos + 1
                    col = col + 1
                }
            } else {
                pos = pos + 1
                col = col + 1
            }
        } else {
            // Skip unknown character
            pos = pos + 1
            col = col + 1
        }
    }

    tokens = push(tokens, tok_new("EOF", "", line, col))
    return tokens
}

// ============================================================
// PHASE 3: Minimal Parser (inline)
// ============================================================
// AST nodes are heterogeneous arrays:
//   ["int", "42"]
//   ["ident", "x"]
//   ["+", left, right]  where left/right are nested arrays
//   ["call", "fname", arg1, arg2, ...]
//   ["println", expr]
//   ["let", "name", expr]
//   ["var", "name", expr]
//   ["assign", "name", expr]
//   ["return", expr]
//   ["if", cond, then_stmts, else_stmts]
//   ["while", cond, body_stmts]
//   ["fn", "name", ["param1", "param2"], body_stmts]
//   ["program", fn1, fn2, ...]
//   ["string", "hello"]
//   ["array", elem1, elem2, ...]
//   ["index", arr_expr, idx_expr]
//   ["len", expr]
//   ["push", arr_expr, val_expr]
//   ["print_str", expr]

// Parser state: global mutable
var _tokens = []
var _tpos = 0

fn p_peek_type() -> String {
    if _tpos >= len(_tokens) {
        return "EOF"
    }
    let tok = _tokens[_tpos]
    return tok[0]
}

fn p_peek_val() -> String {
    if _tpos >= len(_tokens) {
        return ""
    }
    let tok = _tokens[_tpos]
    return tok[1]
}

fn p_advance() -> [String] {
    let tok = _tokens[_tpos]
    _tpos = _tpos + 1
    return tok
}

fn p_expect(typ: String) -> [String] {
    if p_peek_type() != typ {
        println("Parse error: expected " + typ + " got " + p_peek_type() + " '" + p_peek_val() + "'")
    }
    return p_advance()
}

fn p_expect_kw(kw: String) -> [String] {
    if p_peek_type() != "KW" {
        println("Parse error: expected keyword " + kw + " got " + p_peek_type())
    }
    if p_peek_val() != kw {
        println("Parse error: expected keyword " + kw + " got " + p_peek_val())
    }
    return p_advance()
}

fn p_at(typ: String) -> bool {
    return p_peek_type() == typ
}

fn p_at_kw(kw: String) -> bool {
    return p_peek_type() == "KW" && p_peek_val() == kw
}

// --- Expression parsing with precedence ---

fn parse_expr() -> [String] {
    return parse_logical_or()
}

fn parse_logical_or() -> [String] {
    var left = parse_logical_and()
    while p_at("LOR") {
        p_advance()
        let right = parse_logical_and()
        left = ["||", left, right]
    }
    return left
}

fn parse_logical_and() -> [String] {
    var left = parse_comparison()
    while p_at("LAND") {
        p_advance()
        let right = parse_comparison()
        left = ["&&", left, right]
    }
    return left
}

fn parse_comparison() -> [String] {
    var left = parse_addition()
    var cont = true
    while cont {
        if p_at("EQEQ") {
            p_advance()
            let right = parse_addition()
            left = ["==", left, right]
        } else if p_at("NEQ") {
            p_advance()
            let right = parse_addition()
            left = ["!=", left, right]
        } else if p_at("LT") {
            p_advance()
            let right = parse_addition()
            left = ["<", left, right]
        } else if p_at("GT") {
            p_advance()
            let right = parse_addition()
            left = [">", left, right]
        } else if p_at("LTEQ") {
            p_advance()
            let right = parse_addition()
            left = ["<=", left, right]
        } else if p_at("GTEQ") {
            p_advance()
            let right = parse_addition()
            left = [">=", left, right]
        } else {
            cont = false
        }
    }
    return left
}

fn parse_addition() -> [String] {
    var left = parse_multiplication()
    var cont = true
    while cont {
        if p_at("PLUS") {
            p_advance()
            let right = parse_multiplication()
            left = ["+", left, right]
        } else if p_at("MINUS") {
            p_advance()
            let right = parse_multiplication()
            left = ["-", left, right]
        } else {
            cont = false
        }
    }
    return left
}

fn parse_multiplication() -> [String] {
    var left = parse_unary()
    var cont = true
    while cont {
        if p_at("STAR") {
            p_advance()
            let right = parse_unary()
            left = ["*", left, right]
        } else if p_at("SLASH") {
            p_advance()
            let right = parse_unary()
            left = ["/", left, right]
        } else if p_at("PERCENT") {
            p_advance()
            let right = parse_unary()
            left = ["%", left, right]
        } else {
            cont = false
        }
    }
    return left
}

fn parse_unary() -> [String] {
    if p_at("MINUS") {
        p_advance()
        let expr = parse_unary()
        return ["neg", expr]
    }
    if p_at("NOT") {
        p_advance()
        let expr = parse_unary()
        return ["not", expr]
    }
    return parse_primary()
}

fn parse_primary() -> [String] {
    if p_at("TRUE") {
        p_advance()
        return ["int", "1"]
    }

    if p_at("FALSE") {
        p_advance()
        return ["int", "0"]
    }

    if p_at("INT") {
        let tok = p_advance()
        return ["int", tok[1]]
    }

    if p_at("FLOAT") {
        let tok = p_advance()
        return ["float", tok[1]]
    }

    if p_at("STRING") {
        let tok = p_advance()
        return ["string", tok[1]]
    }

    if p_at("LPAREN") {
        p_advance()
        let expr = parse_expr()
        p_expect("RPAREN")
        return expr
    }

    // Array literal: [expr, expr, ...]
    if p_at("LBRACKET") {
        p_advance()
        var elems = []
        if p_at("RBRACKET") {
            p_advance()
            return ["array"]
        }
        elems = push(elems, parse_expr())
        while p_at("COMMA") {
            p_advance()
            elems = push(elems, parse_expr())
        }
        p_expect("RBRACKET")
        var node = ["array"]
        var ai = 0
        while ai < len(elems) {
            node = push(node, elems[ai])
            ai = ai + 1
        }
        return node
    }

    if p_at_kw("println") {
        p_advance()
        p_expect("LPAREN")
        let expr = parse_expr()
        p_expect("RPAREN")
        return ["println", expr]
    }

    if p_at_kw("print_str") {
        p_advance()
        p_expect("LPAREN")
        let expr = parse_expr()
        p_expect("RPAREN")
        return ["print_str", expr]
    }

    if p_at("IDENT") {
        let tok = p_advance()
        let name = tok[1]

        // len(expr) builtin
        if name == "len" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["len", arg]
            }
        }

        // push(arr, val) builtin
        if name == "push" {
            if p_at("LPAREN") {
                p_advance()
                let arr_arg = parse_expr()
                p_expect("COMMA")
                let val_arg = parse_expr()
                p_expect("RPAREN")
                return ["push", arr_arg, val_arg]
            }
        }

        // to_string(expr) builtin
        if name == "to_string" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["to_string", arg]
            }
        }

        // int(expr) builtin — string to int
        if name == "int" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["int_parse", arg]
            }
        }

        // str_char_at(s, i) builtin
        if name == "str_char_at" {
            if p_at("LPAREN") {
                p_advance()
                let s_arg = parse_expr()
                p_expect("COMMA")
                let i_arg = parse_expr()
                p_expect("RPAREN")
                return ["str_char_at", s_arg, i_arg]
            }
        }

        // str_substr(s, start, length) builtin
        if name == "str_substr" {
            if p_at("LPAREN") {
                p_advance()
                let s_arg = parse_expr()
                p_expect("COMMA")
                let start_arg = parse_expr()
                p_expect("COMMA")
                let len_arg = parse_expr()
                p_expect("RPAREN")
                return ["str_substr", s_arg, start_arg, len_arg]
            }
        }

        // str_bytes(s) builtin
        if name == "str_bytes" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["str_bytes", arg]
            }
        }

        // str_from_bytes(arr) builtin
        if name == "str_from_bytes" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["str_from_bytes", arg]
            }
        }

        // sqrt(x) builtin
        if name == "sqrt" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["sqrt", arg]
            }
        }

        // sin(x) builtin
        if name == "sin" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["sin", arg]
            }
        }

        // cos(x) builtin
        if name == "cos" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["cos", arg]
            }
        }

        // exp(x) builtin
        if name == "exp" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["exp", arg]
            }
        }

        // log(x) builtin
        if name == "log" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["log", arg]
            }
        }

        // pow(base, exp) builtin
        if name == "pow" {
            if p_at("LPAREN") {
                p_advance()
                let base_arg = parse_expr()
                p_expect("COMMA")
                let exp_arg = parse_expr()
                p_expect("RPAREN")
                return ["pow", base_arg, exp_arg]
            }
        }

        // type_of(x) builtin
        if name == "type_of" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["type_of", arg]
            }
        }

        // str_find(haystack, needle) builtin
        if name == "str_find" {
            if p_at("LPAREN") {
                p_advance()
                let h_arg = parse_expr()
                p_expect("COMMA")
                let n_arg = parse_expr()
                p_expect("RPAREN")
                return ["str_find", h_arg, n_arg]
            }
        }

        // unwrap_or(val, default) builtin
        if name == "unwrap_or" {
            if p_at("LPAREN") {
                p_advance()
                let v_arg = parse_expr()
                p_expect("COMMA")
                let d_arg = parse_expr()
                p_expect("RPAREN")
                return ["unwrap_or", v_arg, d_arg]
            }
        }

        // trim(s) builtin
        if name == "trim" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["trim", arg]
            }
        }

        // read_file(path) builtin
        if name == "read_file" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["read_file", arg]
            }
        }

        // write_file(path, content) builtin
        if name == "write_file" {
            if p_at("LPAREN") {
                p_advance()
                let p_arg = parse_expr()
                p_expect("COMMA")
                let c_arg = parse_expr()
                p_expect("RPAREN")
                return ["write_file", p_arg, c_arg]
            }
        }

        // file_exists(path) builtin
        if name == "file_exists" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["file_exists", arg]
            }
        }

        // print(expr) builtin — like println but no newline
        if name == "print" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["print", arg]
            }
        }

        // float(x) builtin — int to float
        if name == "float" {
            if p_at("LPAREN") {
                p_advance()
                let arg = parse_expr()
                p_expect("RPAREN")
                return ["float_conv", arg]
            }
        }

        // Check for function call
        if p_at("LPAREN") {
            p_advance()
            var args = []
            if p_at("RPAREN") {
                p_advance()
                return ["call", name]
            }
            args = push(args, parse_expr())
            while p_at("COMMA") {
                p_advance()
                args = push(args, parse_expr())
            }
            p_expect("RPAREN")
            // Build call node: ["call", name, arg1, arg2, ...]
            var node = ["call", name]
            var i = 0
            while i < len(args) {
                node = push(node, args[i])
                i = i + 1
            }
            return node
        }

        // Check for array indexing: ident[expr]
        if p_at("LBRACKET") {
            p_advance()
            let idx_expr = parse_expr()
            p_expect("RBRACKET")
            return ["index", ["ident", name], idx_expr]
        }

        return ["ident", name]
    }

    println("Parse error: unexpected token " + p_peek_type() + " '" + p_peek_val() + "'")
    p_advance()
    return ["int", "0"]
}

// --- Statement parsing ---

fn parse_stmt() -> [String] {
    if p_at_kw("let") {
        p_advance()
        let name_tok = p_expect("IDENT")
        // Skip optional type annotation
        if p_at("COLON") {
            p_advance()
            // Skip type tokens until = sign
            while p_peek_type() != "EQ" && p_peek_type() != "EOF" {
                p_advance()
            }
        }
        p_expect("EQ")
        let expr = parse_expr()
        return ["let", name_tok[1], expr]
    }

    if p_at_kw("var") {
        p_advance()
        let name_tok = p_expect("IDENT")
        if p_at("COLON") {
            p_advance()
            while p_peek_type() != "EQ" && p_peek_type() != "EOF" {
                p_advance()
            }
        }
        p_expect("EQ")
        let expr = parse_expr()
        return ["var", name_tok[1], expr]
    }

    if p_at_kw("return") {
        p_advance()
        if p_at("RBRACE") {
            return ["return", ["int", "0"]]
        }
        let expr = parse_expr()
        return ["return", expr]
    }

    if p_at_kw("break") {
        p_advance()
        return ["break"]
    }

    if p_at_kw("continue") {
        p_advance()
        return ["continue"]
    }

    if p_at_kw("if") {
        return parse_if_stmt()
    }

    if p_at_kw("while") {
        return parse_while_stmt()
    }

    // Expression statement (could be assignment or println or call)
    let expr = parse_expr()

    // Check for array indexing after expression (e.g. arr[i] = val)
    if p_at("LBRACKET") {
        if expr[0] == "ident" {
            p_advance()
            let idx_e = parse_expr()
            p_expect("RBRACKET")
            if p_at("EQ") {
                p_advance()
                let val2 = parse_expr()
                return ["index_assign", expr[1], idx_e, val2]
            }
            // It's just arr[i] as a statement
            let idx_node = ["index", expr, idx_e]
            return ["expr_stmt", idx_node]
        }
    }

    // Check for assignment
    if p_at("EQ") {
        p_advance()
        let val = parse_expr()
        // expr should be ["ident", name]
        if expr[0] == "ident" {
            return ["assign", expr[1], val]
        }
        println("Parse error: invalid assignment target")
        return ["assign", "?", val]
    }

    // println as expression-statement
    if expr[0] == "println" {
        return expr
    }

    // Function call as statement
    if expr[0] == "call" {
        return ["expr_stmt", expr]
    }

    return ["expr_stmt", expr]
}

fn parse_block() -> [String] {
    p_expect("LBRACE")
    var stmts = []
    while p_peek_type() != "RBRACE" && p_peek_type() != "EOF" {
        let s = parse_stmt()
        stmts = push(stmts, s)
    }
    p_expect("RBRACE")
    return stmts
}

fn parse_if_stmt() -> [String] {
    p_expect_kw("if")
    let cond = parse_expr()
    let then_block = parse_block()
    var else_block = []
    if p_at_kw("else") {
        p_advance()
        if p_at_kw("if") {
            // else if -> wrap in array
            let elif_stmt = parse_if_stmt()
            else_block = [elif_stmt]
        } else {
            else_block = parse_block()
        }
    }
    return ["if", cond, then_block, else_block]
}

fn parse_while_stmt() -> [String] {
    p_expect_kw("while")
    let cond = parse_expr()
    let body = parse_block()
    return ["while", cond, body]
}

fn parse_fn_def() -> [String] {
    p_expect_kw("fn")
    let name_tok = p_expect("IDENT")
    p_expect("LPAREN")
    var params = []
    if p_peek_type() != "RPAREN" {
        let p1 = p_expect("IDENT")
        params = push(params, p1[1])
        // Skip type annotation
        if p_at("COLON") {
            p_advance()
            while p_peek_type() != "COMMA" && p_peek_type() != "RPAREN" && p_peek_type() != "EOF" {
                p_advance()
            }
        }
        while p_at("COMMA") {
            p_advance()
            let pn = p_expect("IDENT")
            params = push(params, pn[1])
            if p_at("COLON") {
                p_advance()
                while p_peek_type() != "COMMA" && p_peek_type() != "RPAREN" && p_peek_type() != "EOF" {
                    p_advance()
                }
            }
        }
    }
    p_expect("RPAREN")
    // Skip return type annotation
    if p_at("ARROW") {
        p_advance()
        // Skip type tokens until {
        while p_peek_type() != "LBRACE" && p_peek_type() != "EOF" {
            p_advance()
        }
    }
    let body = parse_block()
    return ["fn", name_tok[1], params, body]
}

fn parse_program() -> [String] {
    var fns = []
    var global_stmts = []
    while p_peek_type() != "EOF" {
        if p_at_kw("fn") {
            fns = push(fns, parse_fn_def())
        } else if p_at_kw("var") {
            let s = parse_stmt()
            global_stmts = push(global_stmts, s)
        } else if p_at_kw("let") {
            let s = parse_stmt()
            global_stmts = push(global_stmts, s)
        } else {
            println("Parse error: expected fn/var/let at top level, got " + p_peek_type())
            p_advance()
        }
    }
    // Always create _vx_init_globals (may have empty body)
    let init_fn = ["fn", "_vx_init_globals", [], global_stmts]
    fns = push(fns, init_fn)
    return fns
}

// ============================================================
// PHASE 4: x86-64 Code Generator (inline)
// ============================================================

// Register constants
fn REG_RAX() -> i64 { return 0 }
fn REG_RCX() -> i64 { return 1 }
fn REG_RDX() -> i64 { return 2 }
fn REG_RBX() -> i64 { return 3 }
fn REG_RSP() -> i64 { return 4 }
fn REG_RBP() -> i64 { return 5 }
fn REG_RSI() -> i64 { return 6 }
fn REG_RDI() -> i64 { return 7 }

fn arg_reg(index: i64) -> i64 {
    if index == 0 { return 7 }
    if index == 1 { return 6 }
    if index == 2 { return 2 }
    if index == 3 { return 1 }
    return 0
}

// Byte emission
fn emit_u8(code: [i64], b: i64) -> [i64] {
    var val = b % 256
    if val < 0 {
        val = val + 256
    }
    return push(code, val)
}

fn emit_u32_le(code: [i64], val: i64) -> [i64] {
    var v = val
    if v < 0 {
        v = v + 4294967296
    }
    code = push(code, v % 256)
    v = v / 256
    code = push(code, v % 256)
    v = v / 256
    code = push(code, v % 256)
    v = v / 256
    code = push(code, v % 256)
    return code
}

fn emit_u64_le(code: [i64], val: i64) -> [i64] {
    var v = val
    if v < 0 {
        v = v + 4294967296 * 4294967296
    }
    var i = 0
    while i < 8 {
        code = push(code, v % 256)
        v = v / 256
        i = i + 1
    }
    return code
}

fn emit_u16_le(code: [i64], val: i64) -> [i64] {
    code = push(code, val % 256)
    code = push(code, (val / 256) % 256)
    return code
}

// REX prefix
fn rex_for_regs(reg: i64, rm: i64) -> i64 {
    var base = 72
    if reg >= 8 {
        base = base + 4
    }
    if rm >= 8 {
        base = base + 1
    }
    return base
}

fn modrm_reg(reg: i64, rm: i64) -> i64 {
    return 192 + (reg % 8) * 8 + (rm % 8)
}

fn modrm_disp8(reg: i64) -> i64 {
    return 64 + (reg % 8) * 8 + 5
}

// mov reg, imm64
fn emit_mov_reg_imm64(code: [i64], reg: i64, imm: i64) -> [i64] {
    if reg >= 8 {
        code = emit_u8(code, 73)
    } else {
        code = emit_u8(code, 72)
    }
    code = emit_u8(code, 184 + (reg % 8))
    code = emit_u64_le(code, imm)
    return code
}

// mov dst, src
fn emit_mov_reg_reg(code: [i64], dst: i64, src: i64) -> [i64] {
    code = emit_u8(code, rex_for_regs(src, dst))
    code = emit_u8(code, 137)
    code = emit_u8(code, modrm_reg(src, dst))
    return code
}

// push reg
fn emit_push_reg(code: [i64], reg: i64) -> [i64] {
    if reg >= 8 {
        code = emit_u8(code, 65)
        code = emit_u8(code, 80 + (reg % 8))
    } else {
        code = emit_u8(code, 80 + reg)
    }
    return code
}

// pop reg
fn emit_pop_reg(code: [i64], reg: i64) -> [i64] {
    if reg >= 8 {
        code = emit_u8(code, 65)
        code = emit_u8(code, 88 + (reg % 8))
    } else {
        code = emit_u8(code, 88 + reg)
    }
    return code
}

// add dst, src
fn emit_add_reg_reg(code: [i64], dst: i64, src: i64) -> [i64] {
    code = emit_u8(code, rex_for_regs(src, dst))
    code = emit_u8(code, 1)
    code = emit_u8(code, modrm_reg(src, dst))
    return code
}

// sub dst, src
fn emit_sub_reg_reg(code: [i64], dst: i64, src: i64) -> [i64] {
    code = emit_u8(code, rex_for_regs(src, dst))
    code = emit_u8(code, 41)
    code = emit_u8(code, modrm_reg(src, dst))
    return code
}

// imul dst, src
fn emit_imul_reg_reg(code: [i64], dst: i64, src: i64) -> [i64] {
    code = emit_u8(code, rex_for_regs(dst, src))
    code = emit_u8(code, 15)
    code = emit_u8(code, 175)
    code = emit_u8(code, modrm_reg(dst, src))
    return code
}

// cmp a, b
fn emit_cmp_reg_reg(code: [i64], a: i64, b: i64) -> [i64] {
    code = emit_u8(code, rex_for_regs(b, a))
    code = emit_u8(code, 57)
    code = emit_u8(code, modrm_reg(b, a))
    return code
}

// Store reg to [rbp - offset]
fn emit_store_local(code: [i64], reg: i64, offset: i64) -> [i64] {
    var neg_off = 0 - offset
    code = emit_u8(code, rex_for_regs(reg, 5))
    code = emit_u8(code, 137)
    code = emit_u8(code, modrm_disp8(reg))
    var byte_val = neg_off % 256
    if byte_val < 0 {
        byte_val = byte_val + 256
    }
    code = emit_u8(code, byte_val)
    return code
}

// Load [rbp - offset] to reg
fn emit_load_local(code: [i64], offset: i64, reg: i64) -> [i64] {
    var neg_off = 0 - offset
    code = emit_u8(code, rex_for_regs(reg, 5))
    code = emit_u8(code, 139)
    code = emit_u8(code, modrm_disp8(reg))
    var byte_val = neg_off % 256
    if byte_val < 0 {
        byte_val = byte_val + 256
    }
    code = emit_u8(code, byte_val)
    return code
}

// Function prologue: push rbp; mov rbp, rsp; sub rsp, N
fn emit_prologue(code: [i64], stack_size: i64) -> [i64] {
    code = emit_u8(code, 85)
    code = emit_u8(code, 72)
    code = emit_u8(code, 137)
    code = emit_u8(code, 229)
    if stack_size > 0 {
        code = emit_u8(code, 72)
        code = emit_u8(code, 131)
        code = emit_u8(code, 236)
        code = emit_u8(code, stack_size % 256)
    }
    return code
}

// Function epilogue: mov rsp, rbp; pop rbp; ret
fn emit_epilogue(code: [i64]) -> [i64] {
    code = emit_u8(code, 72)
    code = emit_u8(code, 137)
    code = emit_u8(code, 236)
    code = emit_u8(code, 93)
    code = emit_u8(code, 195)
    return code
}

// syscall instruction
fn emit_syscall_inst(code: [i64]) -> [i64] {
    code = emit_u8(code, 15)
    code = emit_u8(code, 5)
    return code
}

// --- SSE/float instructions ---

// movq xmm0, rax: 66 48 0F 6E C0
fn emit_movq_xmm0_rax(code: [i64]) -> [i64] {
    code = emit_u8(code, 102)
    code = emit_u8(code, 72)
    code = emit_u8(code, 15)
    code = emit_u8(code, 110)
    code = emit_u8(code, 192)
    return code
}

// movq rax, xmm0: 66 48 0F 7E C0
fn emit_movq_rax_xmm0(code: [i64]) -> [i64] {
    code = emit_u8(code, 102)
    code = emit_u8(code, 72)
    code = emit_u8(code, 15)
    code = emit_u8(code, 126)
    code = emit_u8(code, 192)
    return code
}

// movq xmm1, rax: 66 48 0F 6E C8
fn emit_movq_xmm1_rax(code: [i64]) -> [i64] {
    code = emit_u8(code, 102)
    code = emit_u8(code, 72)
    code = emit_u8(code, 15)
    code = emit_u8(code, 110)
    code = emit_u8(code, 200)
    return code
}

// addsd xmm0, xmm1: F2 0F 58 C1
fn emit_addsd(code: [i64]) -> [i64] {
    code = emit_u8(code, 242)
    code = emit_u8(code, 15)
    code = emit_u8(code, 88)
    code = emit_u8(code, 193)
    return code
}

// subsd xmm0, xmm1: F2 0F 5C C1
fn emit_subsd(code: [i64]) -> [i64] {
    code = emit_u8(code, 242)
    code = emit_u8(code, 15)
    code = emit_u8(code, 92)
    code = emit_u8(code, 193)
    return code
}

// mulsd xmm0, xmm1: F2 0F 59 C1
fn emit_mulsd(code: [i64]) -> [i64] {
    code = emit_u8(code, 242)
    code = emit_u8(code, 15)
    code = emit_u8(code, 89)
    code = emit_u8(code, 193)
    return code
}

// divsd xmm0, xmm1: F2 0F 5E C1
fn emit_divsd(code: [i64]) -> [i64] {
    code = emit_u8(code, 242)
    code = emit_u8(code, 15)
    code = emit_u8(code, 94)
    code = emit_u8(code, 193)
    return code
}

// cvttsd2si rax, xmm0: F2 48 0F 2C C0
fn emit_cvttsd2si_rax_xmm0(code: [i64]) -> [i64] {
    code = emit_u8(code, 242)
    code = emit_u8(code, 72)
    code = emit_u8(code, 15)
    code = emit_u8(code, 44)
    code = emit_u8(code, 192)
    return code
}

// cvtsi2sd xmm0, rax: F2 48 0F 2A C0
fn emit_cvtsi2sd_xmm0_rax(code: [i64]) -> [i64] {
    code = emit_u8(code, 242)
    code = emit_u8(code, 72)
    code = emit_u8(code, 15)
    code = emit_u8(code, 42)
    code = emit_u8(code, 192)
    return code
}

// --- Locals management ---
var _locals: [String] = []
var _local_types: [String] = []

// --- Global variables ---
var _global_names: [String] = []
var _global_types: [String] = []
var _compiling_globals = 0

fn globals_find(name: String) -> i64 {
    var i = 0
    while i < len(_global_names) {
        if _global_names[i] == name {
            return i
        }
        i = i + 1
    }
    return 0 - 1
}

fn globals_add(name: String) -> i64 {
    let existing = globals_find(name)
    if existing >= 0 {
        return existing
    }
    _global_names = push(_global_names, name)
    _global_types = push(_global_types, "int")
    return len(_global_names) - 1
}

fn GLOBAL_BASE_ADDR() -> i64 {
    // Fixed address for global variables (in .bss segment)
    return 6291456
}

fn globals_addr(idx: i64) -> i64 {
    return GLOBAL_BASE_ADDR() + idx * 8
}

fn locals_find(name: String) -> i64 {
    var i = 0
    while i < len(_locals) {
        if _locals[i] == name {
            return i
        }
        i = i + 1
    }
    return 0 - 1
}

fn locals_offset(idx: i64) -> i64 {
    return (idx + 1) * 8
}

fn locals_add(name: String) -> i64 {
    _locals = push(_locals, name)
    _local_types = push(_local_types, "int")
    return len(_locals) - 1
}

fn locals_set_type(idx: i64, typ: String) -> i64 {
    _local_types[idx] = typ
    return 0
}

fn locals_get_type(idx: i64) -> String {
    if idx >= 0 {
        if idx < len(_local_types) {
            return _local_types[idx]
        }
    }
    return "int"
}

// --- Loop label stack for break/continue ---
var _loop_break_labels: [String] = []
var _loop_continue_labels: [String] = []

// --- Label/fixup management ---
var _label_counter = 0
var _fixup_positions: [i64] = []
var _fixup_labels: [String] = []
var _label_names: [String] = []
var _label_addrs: [i64] = []

fn fresh_label(prefix: String) -> String {
    let lbl = prefix + "_" + to_string(_label_counter)
    _label_counter = _label_counter + 1
    return lbl
}

fn add_fixup(pos: i64, label: String) -> i64 {
    _fixup_positions = push(_fixup_positions, pos)
    _fixup_labels = push(_fixup_labels, label)
    return 0
}

fn add_label(name: String, addr: i64) -> i64 {
    _label_names = push(_label_names, name)
    _label_addrs = push(_label_addrs, addr)
    return 0
}

// --- Function table ---
var _func_names: [String] = []
var _func_addrs: [i64] = []

// --- String data section ---
// Collected during codegen, emitted after code
var _string_data: [String] = []
var _string_offsets: [i64] = []
var _string_lengths: [i64] = []

fn add_string_literal(s: String) -> i64 {
    // Check if already added
    var i = 0
    while i < len(_string_data) {
        if _string_data[i] == s {
            return i
        }
        i = i + 1
    }
    // Compute offset: sum of all previous string byte lengths
    var offset = 0
    var j = 0
    while j < len(_string_data) {
        offset = offset + _string_lengths[j]
        j = j + 1
    }
    let slen = len(s)
    _string_data = push(_string_data, s)
    _string_offsets = push(_string_offsets, offset)
    _string_lengths = push(_string_lengths, slen)
    return len(_string_data) - 1
}

fn register_function(name: String, addr: i64) -> i64 {
    _func_names = push(_func_names, name)
    _func_addrs = push(_func_addrs, addr)
    return 0
}

// --- Float string to IEEE 754 bits (pure integer math) ---
// Parses "3.14" -> IEEE 754 f64 bit pattern as i64
fn float_str_to_bits(s: String) -> i64 {
    // Find the dot position
    var dot_pos = 0 - 1
    var si = 0
    let slen = len(s)
    while si < slen {
        if str_char_at(s, si) == "." {
            dot_pos = si
        }
        si = si + 1
    }
    if dot_pos < 0 {
        // No dot, treat as integer float
        let ival = int(s)
        if ival == 0 {
            return 0
        }
        // Build float from integer
        var val = ival
        if val < 0 {
            val = 0 - val
        }
        var exp = 1023 + 52
        // Normalize: shift val so highest bit is at position 52
        // First find how many bits val has
        var bits_needed = 0
        var tmp = val
        while tmp > 0 {
            bits_needed = bits_needed + 1
            tmp = tmp / 2
        }
        // We need to shift to have exactly 53 bits (bit 52 is implicit 1)
        if bits_needed > 53 {
            var shift_right = bits_needed - 53
            var sr = 0
            while sr < shift_right {
                val = val / 2
                sr = sr + 1
            }
            exp = exp + shift_right
        } else if bits_needed < 53 {
            var shift_left = 53 - bits_needed
            var sl = 0
            while sl < shift_left {
                val = val * 2
                sl = sl + 1
            }
            exp = exp - shift_left
        }
        // Mantissa: lower 52 bits (remove implicit leading 1)
        let mantissa = val - 4503599627370496
        let result = exp * 4503599627370496 + mantissa
        if ival < 0 {
            return result + 9223372036854775807 + 1
        }
        return result
    }
    // Parse integer part
    let int_str = str_substr(s, 0, dot_pos)
    let frac_str = str_substr(s, dot_pos + 1, slen - dot_pos - 1)
    var int_part = 0
    if len(int_str) > 0 {
        int_part = int(int_str)
    }
    var frac_digits = len(frac_str)
    var frac_val = 0
    if frac_digits > 0 {
        frac_val = int(frac_str)
    }
    // Special case: 0.0
    if int_part == 0 {
        if frac_val == 0 {
            return 0
        }
    }
    // Compute the float value as a fixed-point number
    // We need to find: value = int_part + frac_val / 10^frac_digits
    // Then encode as IEEE 754 double
    // Strategy: compute mantissa * 2^(-exp) = value
    // Work with scaled integers: value_scaled = int_part * 10^frac_digits + frac_val
    // denominator = 10^frac_digits
    var denom = 1
    var di = 0
    while di < frac_digits {
        denom = denom * 10
        di = di + 1
    }
    var numerator = int_part * denom + frac_val
    // Now we have value = numerator / denom
    // Find exponent: how many times we multiply/divide by 2 to normalize
    if numerator == 0 {
        return 0
    }
    // We need to compute: mantissa_53bits * 2^(exp-52) = numerator / denom
    // So mantissa_53bits = numerator * 2^(52-exp) / denom
    // First find rough exponent by seeing how big numerator/denom is
    var biased_exp = 1023
    // Scale numerator/denom so that 1 <= numerator/denom < 2
    // Equivalent: 1*denom <= numerator < 2*denom
    while numerator >= 2 * denom {
        denom = denom * 2
        biased_exp = biased_exp + 1
    }
    while numerator < denom {
        numerator = numerator * 2
        biased_exp = biased_exp - 1
    }
    // Now denom <= numerator < 2*denom, meaning 1.xxx in binary
    // Extract 52 bits of mantissa after the leading 1
    // mantissa_frac = (numerator - denom) / denom, need 52 bits
    numerator = numerator - denom
    var mantissa = 0
    var bi = 0
    while bi < 52 {
        numerator = numerator * 2
        mantissa = mantissa * 2
        if numerator >= denom {
            mantissa = mantissa + 1
            numerator = numerator - denom
        }
        bi = bi + 1
    }
    // Round: if remainder >= denom/2, round up
    if numerator * 2 >= denom {
        mantissa = mantissa + 1
    }
    // Compose: [sign=0][exponent=11bits][mantissa=52bits]
    // sign * 2^63 + biased_exp * 2^52 + mantissa
    let result = biased_exp * 4503599627370496 + mantissa
    return result
}

// Check if an AST expression produces a float value
fn expr_is_float(expr: [String]) -> bool {
    let kind = expr[0]
    if kind == "float" {
        return true
    }
    if kind == "ident" {
        let idx = locals_find(expr[1])
        if idx >= 0 {
            return locals_get_type(idx) == "float"
        }
    }
    if kind == "+" {
        if expr_is_float(expr[1]) {
            return true
        }
        if expr_is_float(expr[2]) {
            return true
        }
    }
    if kind == "-" {
        if expr_is_float(expr[1]) {
            return true
        }
        if expr_is_float(expr[2]) {
            return true
        }
    }
    if kind == "*" {
        if expr_is_float(expr[1]) {
            return true
        }
        if expr_is_float(expr[2]) {
            return true
        }
    }
    if kind == "/" {
        if expr_is_float(expr[1]) {
            return true
        }
        if expr_is_float(expr[2]) {
            return true
        }
    }
    if kind == "neg" {
        return expr_is_float(expr[1])
    }
    if kind == "sqrt" {
        return true
    }
    if kind == "sin" {
        return true
    }
    if kind == "cos" {
        return true
    }
    if kind == "exp" {
        return true
    }
    if kind == "log" {
        return true
    }
    if kind == "pow" {
        return true
    }
    if kind == "float_conv" {
        return true
    }
    if kind == "call" {
        let fname = expr[1]
        if fname == "to_string" {
            return false
        }
        if fname == "str_char_at" {
            return false
        }
        if fname == "str_substr" {
            return false
        }
        return false
    }
    return false
}

fn expr_is_string(expr: [String]) -> bool {
    let kind = expr[0]
    if kind == "string" {
        return true
    }
    if kind == "ident" {
        let idx = locals_find(expr[1])
        if idx >= 0 {
            return locals_get_type(idx) == "string"
        }
    }
    if kind == "+" {
        if expr_is_string(expr[1]) {
            return true
        }
        if expr_is_string(expr[2]) {
            return true
        }
    }
    if kind == "to_string" {
        return true
    }
    if kind == "str_char_at" {
        return true
    }
    if kind == "str_substr" {
        return true
    }
    if kind == "str_from_bytes" {
        return true
    }
    if kind == "trim" {
        return true
    }
    if kind == "read_file" {
        return true
    }
    if kind == "type_of" {
        return true
    }
    if kind == "call" {
        let fname = expr[1]
        if fname == "to_string" {
            return true
        }
        if fname == "str_char_at" {
            return true
        }
        if fname == "str_substr" {
            return true
        }
        if fname == "str_from_bytes" {
            return true
        }
    }
    return false
}

// --- Expression compiler: result in RAX ---
fn compile_expr(code: [i64], expr: [String]) -> [i64] {
    let kind = expr[0]

    if kind == "int" {
        let val = int(expr[1])
        code = emit_mov_reg_imm64(code, REG_RAX(), val)
        return code
    }

    if kind == "float" {
        let bits = float_str_to_bits(expr[1])
        code = emit_mov_reg_imm64(code, REG_RAX(), bits)
        return code
    }

    if kind == "ident" {
        let name = expr[1]
        let idx = locals_find(name)
        if idx >= 0 {
            let off = locals_offset(idx)
            code = emit_load_local(code, off, REG_RAX())
        } else {
            let gidx = globals_find(name)
            if gidx >= 0 {
                let addr = globals_addr(gidx)
                code = emit_mov_reg_imm64(code, REG_RCX(), addr)
                // mov rax, [rcx]: 48 8B 01
                code = emit_u8(code, 72)
                code = emit_u8(code, 139)
                code = emit_u8(code, 1)
            } else {
                println("codegen error: undefined variable '" + name + "'")
                code = emit_mov_reg_imm64(code, REG_RAX(), 0)
            }
        }
        return code
    }

    if kind == "neg" {
        if expr_is_float(expr[1]) {
            // Float negation: XOR sign bit
            code = compile_expr(code, expr[1])
            // xor rax with sign bit (1<<63)
            // mov rcx, 0x8000000000000000; xor rax, rcx
            code = emit_mov_reg_imm64(code, REG_RCX(), 0 - 9223372036854775807 - 1)
            // xor rax, rcx: 48 31 C8
            code = emit_u8(code, 72)
            code = emit_u8(code, 49)
            code = emit_u8(code, 200)
            return code
        }
        code = compile_expr(code, expr[1])
        // neg rax: 48 F7 D8
        code = emit_u8(code, 72)
        code = emit_u8(code, 247)
        code = emit_u8(code, 216)
        return code
    }

    if kind == "not" {
        code = compile_expr(code, expr[1])
        // test rax, rax: 48 85 C0
        code = emit_u8(code, 72)
        code = emit_u8(code, 133)
        code = emit_u8(code, 192)
        // setz al: 0F 94 C0
        code = emit_u8(code, 15)
        code = emit_u8(code, 148)
        code = emit_u8(code, 192)
        // movzx rax, al: 48 0F B6 C0
        code = emit_u8(code, 72)
        code = emit_u8(code, 15)
        code = emit_u8(code, 182)
        code = emit_u8(code, 192)
        return code
    }

    if kind == "&&" {
        let false_label = fresh_label("land_false")
        let end_label = fresh_label("land_end")
        code = compile_expr(code, expr[1])
        // test rax, rax
        code = emit_u8(code, 72)
        code = emit_u8(code, 133)
        code = emit_u8(code, 192)
        // je false_label
        code = emit_u8(code, 15)
        code = emit_u8(code, 132)
        add_fixup(len(code), false_label)
        code = emit_u32_le(code, 0)
        code = compile_expr(code, expr[2])
        // test rax, rax; setne al; movzx rax, al
        code = emit_u8(code, 72)
        code = emit_u8(code, 133)
        code = emit_u8(code, 192)
        code = emit_u8(code, 15)
        code = emit_u8(code, 149)
        code = emit_u8(code, 192)
        code = emit_u8(code, 72)
        code = emit_u8(code, 15)
        code = emit_u8(code, 182)
        code = emit_u8(code, 192)
        // jmp end_label
        code = emit_u8(code, 233)
        add_fixup(len(code), end_label)
        code = emit_u32_le(code, 0)
        // false_label:
        add_label(false_label, len(code))
        code = emit_mov_reg_imm64(code, REG_RAX(), 0)
        // end_label:
        add_label(end_label, len(code))
        return code
    }

    if kind == "||" {
        let true_label = fresh_label("lor_true")
        let end_label = fresh_label("lor_end")
        code = compile_expr(code, expr[1])
        // test rax, rax
        code = emit_u8(code, 72)
        code = emit_u8(code, 133)
        code = emit_u8(code, 192)
        // jne true_label
        code = emit_u8(code, 15)
        code = emit_u8(code, 133)
        add_fixup(len(code), true_label)
        code = emit_u32_le(code, 0)
        code = compile_expr(code, expr[2])
        // test rax, rax; setne al; movzx rax, al
        code = emit_u8(code, 72)
        code = emit_u8(code, 133)
        code = emit_u8(code, 192)
        code = emit_u8(code, 15)
        code = emit_u8(code, 149)
        code = emit_u8(code, 192)
        code = emit_u8(code, 72)
        code = emit_u8(code, 15)
        code = emit_u8(code, 182)
        code = emit_u8(code, 192)
        // jmp end_label
        code = emit_u8(code, 233)
        add_fixup(len(code), end_label)
        code = emit_u32_le(code, 0)
        // true_label:
        add_label(true_label, len(code))
        code = emit_mov_reg_imm64(code, REG_RAX(), 1)
        // end_label:
        add_label(end_label, len(code))
        return code
    }

    if kind == "+" {
        if expr_is_float(expr) {
            // Float addition using SSE
            code = compile_expr(code, expr[2])
            code = emit_push_reg(code, REG_RAX())
            code = compile_expr(code, expr[1])
            // left result in RAX -> xmm0
            code = emit_movq_xmm0_rax(code)
            // right from stack -> RAX -> xmm1
            code = emit_pop_reg(code, REG_RAX())
            code = emit_movq_xmm1_rax(code)
            code = emit_addsd(code)
            // result in xmm0 -> RAX
            code = emit_movq_rax_xmm0(code)
            return code
        }
        if expr_is_string(expr) {
            // String concatenation: _vx_str_concat(a, b) -> new string ptr
            code = compile_expr(code, expr[2])
            code = emit_push_reg(code, REG_RAX())
            code = compile_expr(code, expr[1])
            code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
            code = emit_pop_reg(code, REG_RSI())
            code = emit_u8(code, 232)
            add_fixup(len(code), "_vx_str_concat")
            code = emit_u32_le(code, 0)
            return code
        }
        code = compile_expr(code, expr[2])
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])
        code = emit_pop_reg(code, REG_RCX())
        code = emit_add_reg_reg(code, REG_RAX(), REG_RCX())
        return code
    }

    if kind == "-" {
        if expr_is_float(expr) {
            code = compile_expr(code, expr[2])
            code = emit_push_reg(code, REG_RAX())
            code = compile_expr(code, expr[1])
            code = emit_movq_xmm0_rax(code)
            code = emit_pop_reg(code, REG_RAX())
            code = emit_movq_xmm1_rax(code)
            code = emit_subsd(code)
            code = emit_movq_rax_xmm0(code)
            return code
        }
        code = compile_expr(code, expr[2])
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])
        code = emit_pop_reg(code, REG_RCX())
        code = emit_sub_reg_reg(code, REG_RAX(), REG_RCX())
        return code
    }

    if kind == "*" {
        if expr_is_float(expr) {
            code = compile_expr(code, expr[2])
            code = emit_push_reg(code, REG_RAX())
            code = compile_expr(code, expr[1])
            code = emit_movq_xmm0_rax(code)
            code = emit_pop_reg(code, REG_RAX())
            code = emit_movq_xmm1_rax(code)
            code = emit_mulsd(code)
            code = emit_movq_rax_xmm0(code)
            return code
        }
        code = compile_expr(code, expr[2])
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])
        code = emit_pop_reg(code, REG_RCX())
        code = emit_imul_reg_reg(code, REG_RAX(), REG_RCX())
        return code
    }

    if kind == "/" {
        if expr_is_float(expr) {
            code = compile_expr(code, expr[2])
            code = emit_push_reg(code, REG_RAX())
            code = compile_expr(code, expr[1])
            code = emit_movq_xmm0_rax(code)
            code = emit_pop_reg(code, REG_RAX())
            code = emit_movq_xmm1_rax(code)
            code = emit_divsd(code)
            code = emit_movq_rax_xmm0(code)
            return code
        }
        // dividend in RAX, divisor in RCX
        // Need: compile divisor, push, compile dividend, pop rcx, cqo, idiv rcx
        code = compile_expr(code, expr[2])
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])
        code = emit_pop_reg(code, REG_RCX())
        // cqo: 48 99
        code = emit_u8(code, 72)
        code = emit_u8(code, 153)
        // idiv rcx: 48 F7 F9
        code = emit_u8(code, 72)
        code = emit_u8(code, 247)
        code = emit_u8(code, 249)
        return code
    }

    if kind == "%" {
        code = compile_expr(code, expr[2])
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])
        code = emit_pop_reg(code, REG_RCX())
        // cqo
        code = emit_u8(code, 72)
        code = emit_u8(code, 153)
        // idiv rcx
        code = emit_u8(code, 72)
        code = emit_u8(code, 247)
        code = emit_u8(code, 249)
        // remainder in RDX, move to RAX
        code = emit_mov_reg_reg(code, REG_RAX(), REG_RDX())
        return code
    }

    // Comparison operators: result 0 or 1 in RAX
    if kind == "==" {
        if expr_is_string(expr[1]) {
            // String equality: call _vx_str_eq(a, b) -> 0 or 1
            code = compile_expr(code, expr[2])
            code = emit_push_reg(code, REG_RAX())
            code = compile_expr(code, expr[1])
            code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
            code = emit_pop_reg(code, REG_RSI())
            code = emit_u8(code, 232)
            add_fixup(len(code), "_vx_str_eq")
            code = emit_u32_le(code, 0)
            return code
        }
        if expr_is_string(expr[2]) {
            code = compile_expr(code, expr[2])
            code = emit_push_reg(code, REG_RAX())
            code = compile_expr(code, expr[1])
            code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
            code = emit_pop_reg(code, REG_RSI())
            code = emit_u8(code, 232)
            add_fixup(len(code), "_vx_str_eq")
            code = emit_u32_le(code, 0)
            return code
        }
        code = compile_expr(code, expr[2])
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])
        code = emit_pop_reg(code, REG_RCX())
        code = emit_cmp_reg_reg(code, REG_RAX(), REG_RCX())
        // sete al: 0F 94 C0
        code = emit_u8(code, 15)
        code = emit_u8(code, 148)
        code = emit_u8(code, 192)
        // movzx rax, al: 48 0F B6 C0
        code = emit_u8(code, 72)
        code = emit_u8(code, 15)
        code = emit_u8(code, 182)
        code = emit_u8(code, 192)
        return code
    }

    if kind == "!=" {
        if expr_is_string(expr[1]) {
            // String inequality: call _vx_str_eq then invert
            code = compile_expr(code, expr[2])
            code = emit_push_reg(code, REG_RAX())
            code = compile_expr(code, expr[1])
            code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
            code = emit_pop_reg(code, REG_RSI())
            code = emit_u8(code, 232)
            add_fixup(len(code), "_vx_str_eq")
            code = emit_u32_le(code, 0)
            // xor rax, 1: 48 83 F0 01
            code = emit_u8(code, 72)
            code = emit_u8(code, 131)
            code = emit_u8(code, 240)
            code = emit_u8(code, 1)
            return code
        }
        if expr_is_string(expr[2]) {
            code = compile_expr(code, expr[2])
            code = emit_push_reg(code, REG_RAX())
            code = compile_expr(code, expr[1])
            code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
            code = emit_pop_reg(code, REG_RSI())
            code = emit_u8(code, 232)
            add_fixup(len(code), "_vx_str_eq")
            code = emit_u32_le(code, 0)
            // xor rax, 1
            code = emit_u8(code, 72)
            code = emit_u8(code, 131)
            code = emit_u8(code, 240)
            code = emit_u8(code, 1)
            return code
        }
        code = compile_expr(code, expr[2])
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])
        code = emit_pop_reg(code, REG_RCX())
        code = emit_cmp_reg_reg(code, REG_RAX(), REG_RCX())
        // setne al: 0F 95 C0
        code = emit_u8(code, 15)
        code = emit_u8(code, 149)
        code = emit_u8(code, 192)
        code = emit_u8(code, 72)
        code = emit_u8(code, 15)
        code = emit_u8(code, 182)
        code = emit_u8(code, 192)
        return code
    }

    if kind == "<" {
        code = compile_expr(code, expr[2])
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])
        code = emit_pop_reg(code, REG_RCX())
        code = emit_cmp_reg_reg(code, REG_RAX(), REG_RCX())
        // setl al: 0F 9C C0
        code = emit_u8(code, 15)
        code = emit_u8(code, 156)
        code = emit_u8(code, 192)
        code = emit_u8(code, 72)
        code = emit_u8(code, 15)
        code = emit_u8(code, 182)
        code = emit_u8(code, 192)
        return code
    }

    if kind == ">" {
        // a > b: swap and use setl
        code = compile_expr(code, expr[1])
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[2])
        code = emit_pop_reg(code, REG_RCX())
        code = emit_cmp_reg_reg(code, REG_RAX(), REG_RCX())
        code = emit_u8(code, 15)
        code = emit_u8(code, 156)
        code = emit_u8(code, 192)
        code = emit_u8(code, 72)
        code = emit_u8(code, 15)
        code = emit_u8(code, 182)
        code = emit_u8(code, 192)
        return code
    }

    if kind == "<=" {
        code = compile_expr(code, expr[1])
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[2])
        code = emit_pop_reg(code, REG_RCX())
        code = emit_cmp_reg_reg(code, REG_RAX(), REG_RCX())
        // setge al (swapped)
        code = emit_u8(code, 15)
        code = emit_u8(code, 157)
        code = emit_u8(code, 192)
        code = emit_u8(code, 72)
        code = emit_u8(code, 15)
        code = emit_u8(code, 182)
        code = emit_u8(code, 192)
        return code
    }

    if kind == ">=" {
        code = compile_expr(code, expr[2])
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])
        code = emit_pop_reg(code, REG_RCX())
        code = emit_cmp_reg_reg(code, REG_RAX(), REG_RCX())
        // setge al
        code = emit_u8(code, 15)
        code = emit_u8(code, 157)
        code = emit_u8(code, 192)
        code = emit_u8(code, 72)
        code = emit_u8(code, 15)
        code = emit_u8(code, 182)
        code = emit_u8(code, 192)
        return code
    }

    if kind == "println" {
        let inner = expr[1]
        if expr_is_float(inner) {
            // Float println: compile expr, move to RDI as bits, call _vx_print_float
            code = compile_expr(code, inner)
            code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
            code = emit_u8(code, 232)
            add_fixup(len(code), "_vx_print_float")
            code = emit_u32_le(code, 0)
            return code
        }
        if expr_is_string(inner) {
            // String println: compile expr, call _vx_println_str
            code = compile_expr(code, inner)
            code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
            code = emit_u8(code, 232)
            add_fixup(len(code), "_vx_println_str")
            code = emit_u32_le(code, 0)
            return code
        }
        // Compile the expression, result in RAX
        // Move to RDI, call _vx_print_int runtime stub
        code = compile_expr(code, expr[1])
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        // call _vx_print_int (fixup)
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_print_int")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "string" {
        // String literal: stored in data section as [u64 len][bytes...]
        // RAX = pointer to the struct (RIP-relative lea)
        let str_idx = add_string_literal(expr[1])
        // lea rax, [rip + disp32]: 48 8D 05 <rel32>
        code = emit_u8(code, 72)
        code = emit_u8(code, 141)
        code = emit_u8(code, 5)
        add_fixup(len(code), "_str_" + to_string(str_idx))
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "print_str" {
        // print_str(expr) — expr should be a string (ptr to [len, bytes...])
        code = compile_expr(code, expr[1])
        // RAX = ptr to string struct [u64 len, bytes...]
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        // call _vx_print_str
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_print_str")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "array" {
        // Array literal: allocate (n+1)*8 bytes using mmap, store len then elements
        let nelems = len(expr) - 1
        // call _vx_alloc with size = (nelems+1)*8 in RDI
        let alloc_size = (nelems + 1) * 8
        code = emit_mov_reg_imm64(code, REG_RDI(), alloc_size)
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_alloc")
        code = emit_u32_le(code, 0)
        // RAX = ptr to allocated memory
        // Store length at [RAX]
        code = emit_push_reg(code, REG_RAX())  // save base ptr
        // mov [rax], nelems: mov rcx, nelems; mov [rax], rcx
        code = emit_mov_reg_imm64(code, REG_RCX(), nelems)
        // mov [rax], rcx: 48 89 08
        code = emit_u8(code, 72)
        code = emit_u8(code, 137)
        code = emit_u8(code, 8)
        // Store each element at [RAX + (i+1)*8]
        var ei = 0
        while ei < nelems {
            // Save base ptr (it's on stack top)
            code = compile_expr(code, expr[ei + 1])
            // RAX = element value, base ptr is at [RSP]
            code = emit_mov_reg_reg(code, REG_RCX(), REG_RAX())
            // Load base ptr from stack (peek, don't pop)
            // mov rax, [rsp]: 48 8B 04 24
            code = emit_u8(code, 72)
            code = emit_u8(code, 139)
            code = emit_u8(code, 4)
            code = emit_u8(code, 36)
            // mov [rax + (ei+1)*8], rcx
            // Using: mov [rax + disp32], rcx -> 48 89 88 <disp32>
            let elem_off = (ei + 1) * 8
            code = emit_u8(code, 72)
            code = emit_u8(code, 137)
            code = emit_u8(code, 136)
            code = emit_u32_le(code, elem_off)
            ei = ei + 1
        }
        // Pop base ptr back to RAX
        code = emit_pop_reg(code, REG_RAX())
        return code
    }

    if kind == "index" {
        // Array indexing: arr[i]
        // Result = arr_ptr[(i+1)*8]
        code = compile_expr(code, expr[2])  // index -> RAX
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])  // array ptr -> RAX
        code = emit_pop_reg(code, REG_RCX())  // index -> RCX
        // Compute offset: (RCX+1)*8
        // add rcx, 1: 48 83 C1 01
        code = emit_u8(code, 72)
        code = emit_u8(code, 131)
        code = emit_u8(code, 193)
        code = emit_u8(code, 1)
        // shl rcx, 3: 48 C1 E1 03
        code = emit_u8(code, 72)
        code = emit_u8(code, 193)
        code = emit_u8(code, 225)
        code = emit_u8(code, 3)
        // add rax, rcx
        code = emit_add_reg_reg(code, REG_RAX(), REG_RCX())
        // mov rax, [rax]: 48 8B 00
        code = emit_u8(code, 72)
        code = emit_u8(code, 139)
        code = emit_u8(code, 0)
        return code
    }

    if kind == "len" {
        // len(arr): load first 8 bytes = length
        code = compile_expr(code, expr[1])
        // mov rax, [rax]: 48 8B 00
        code = emit_u8(code, 72)
        code = emit_u8(code, 139)
        code = emit_u8(code, 0)
        return code
    }

    if kind == "push" {
        // push(arr, val): call _vx_arr_push(arr_ptr, val) -> new arr ptr in RAX
        code = compile_expr(code, expr[2])  // val -> RAX
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])  // arr -> RAX
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_pop_reg(code, REG_RSI())
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_arr_push")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "to_string" {
        // to_string(int_expr) -> string ptr
        code = compile_expr(code, expr[1])
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_to_string")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "int_parse" {
        // int(string_expr) -> integer
        code = compile_expr(code, expr[1])
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_str_to_int")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "str_char_at" {
        // str_char_at(s, i) -> single-char string
        code = compile_expr(code, expr[2])  // index -> RAX
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])  // string -> RAX
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_pop_reg(code, REG_RSI())
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_str_char_at")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "str_substr" {
        // str_substr(s, start, len) -> substring
        code = compile_expr(code, expr[3])  // len -> RAX
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[2])  // start -> RAX
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])  // string -> RAX
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_pop_reg(code, REG_RSI())  // start
        code = emit_pop_reg(code, REG_RDX())  // len
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_str_substr")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "str_bytes" {
        // str_bytes(s) -> array of byte values
        code = compile_expr(code, expr[1])
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_str_bytes")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "str_from_bytes" {
        // str_from_bytes(arr) -> string
        code = compile_expr(code, expr[1])
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_str_from_bytes")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "str_find" {
        // str_find(haystack, needle) -> i64 index or -1
        code = compile_expr(code, expr[2])  // needle -> RAX
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])  // haystack -> RAX
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_pop_reg(code, REG_RSI())
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_str_find")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "unwrap_or" {
        // unwrap_or(val, default) -> val if >= 0, else default
        code = compile_expr(code, expr[2])  // default -> RAX
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])  // val -> RAX
        code = emit_pop_reg(code, REG_RCX())  // default in RCX
        // test rax, rax: 48 85 C0
        code = emit_u8(code, 72)
        code = emit_u8(code, 133)
        code = emit_u8(code, 192)
        // cmovs rax, rcx: 48 0F 48 C1 (if negative, use default)
        code = emit_u8(code, 72)
        code = emit_u8(code, 15)
        code = emit_u8(code, 72)
        code = emit_u8(code, 193)
        return code
    }

    if kind == "trim" {
        // trim(s) -> new trimmed string
        code = compile_expr(code, expr[1])
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_trim")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "read_file" {
        // read_file(path) -> string
        code = compile_expr(code, expr[1])
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_read_file")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "write_file" {
        // write_file(path, content)
        code = compile_expr(code, expr[2])  // content -> RAX
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])  // path -> RAX
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_pop_reg(code, REG_RSI())
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_write_file")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "file_exists" {
        // file_exists(path) -> 1 or 0
        code = compile_expr(code, expr[1])
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_file_exists")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "print" {
        let inner = expr[1]
        if expr_is_string(inner) {
            // String print without newline
            code = compile_expr(code, inner)
            code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
            code = emit_u8(code, 232)
            add_fixup(len(code), "_vx_print_str")
            code = emit_u32_le(code, 0)
            return code
        }
        // Integer print without newline
        code = compile_expr(code, inner)
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_print_int_no_nl")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "float_conv" {
        // float(x): int -> float bits in RAX
        code = compile_expr(code, expr[1])
        // cvtsi2sd xmm0, rax: F2 48 0F 2A C0
        code = emit_u8(code, 242)
        code = emit_u8(code, 72)
        code = emit_u8(code, 15)
        code = emit_u8(code, 42)
        code = emit_u8(code, 192)
        // movq rax, xmm0: 66 48 0F 7E C0
        code = emit_u8(code, 102)
        code = emit_u8(code, 72)
        code = emit_u8(code, 15)
        code = emit_u8(code, 126)
        code = emit_u8(code, 192)
        return code
    }

    if kind == "sqrt" {
        // sqrt(x): compile arg -> RAX (float bits), sqrtsd xmm0,xmm0, result -> RAX
        code = compile_expr(code, expr[1])
        code = emit_movq_xmm0_rax(code)
        // sqrtsd xmm0, xmm0: F2 0F 51 C0
        code = emit_u8(code, 242)
        code = emit_u8(code, 15)
        code = emit_u8(code, 81)
        code = emit_u8(code, 192)
        code = emit_movq_rax_xmm0(code)
        return code
    }

    if kind == "sin" {
        // sin(x): use x87 FPU fsin
        code = compile_expr(code, expr[1])
        // sub rsp, 8: 48 83 EC 08
        code = emit_u8(code, 72)
        code = emit_u8(code, 131)
        code = emit_u8(code, 236)
        code = emit_u8(code, 8)
        // mov [rsp], rax: 48 89 04 24
        code = emit_u8(code, 72)
        code = emit_u8(code, 137)
        code = emit_u8(code, 4)
        code = emit_u8(code, 36)
        // fld qword [rsp]: DD 04 24
        code = emit_u8(code, 221)
        code = emit_u8(code, 4)
        code = emit_u8(code, 36)
        // fsin: D9 FE
        code = emit_u8(code, 217)
        code = emit_u8(code, 254)
        // fstp qword [rsp]: DD 1C 24
        code = emit_u8(code, 221)
        code = emit_u8(code, 28)
        code = emit_u8(code, 36)
        // mov rax, [rsp]: 48 8B 04 24
        code = emit_u8(code, 72)
        code = emit_u8(code, 139)
        code = emit_u8(code, 4)
        code = emit_u8(code, 36)
        // add rsp, 8: 48 83 C4 08
        code = emit_u8(code, 72)
        code = emit_u8(code, 131)
        code = emit_u8(code, 196)
        code = emit_u8(code, 8)
        return code
    }

    if kind == "cos" {
        // cos(x): use x87 FPU fcos
        code = compile_expr(code, expr[1])
        // sub rsp, 8
        code = emit_u8(code, 72)
        code = emit_u8(code, 131)
        code = emit_u8(code, 236)
        code = emit_u8(code, 8)
        // mov [rsp], rax
        code = emit_u8(code, 72)
        code = emit_u8(code, 137)
        code = emit_u8(code, 4)
        code = emit_u8(code, 36)
        // fld qword [rsp]
        code = emit_u8(code, 221)
        code = emit_u8(code, 4)
        code = emit_u8(code, 36)
        // fcos: D9 FF
        code = emit_u8(code, 217)
        code = emit_u8(code, 255)
        // fstp qword [rsp]
        code = emit_u8(code, 221)
        code = emit_u8(code, 28)
        code = emit_u8(code, 36)
        // mov rax, [rsp]
        code = emit_u8(code, 72)
        code = emit_u8(code, 139)
        code = emit_u8(code, 4)
        code = emit_u8(code, 36)
        // add rsp, 8
        code = emit_u8(code, 72)
        code = emit_u8(code, 131)
        code = emit_u8(code, 196)
        code = emit_u8(code, 8)
        return code
    }

    if kind == "exp" {
        // exp(x): call _vx_exp runtime stub
        code = compile_expr(code, expr[1])
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_exp")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "log" {
        // log(x): call _vx_log runtime stub
        code = compile_expr(code, expr[1])
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_log")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "pow" {
        // pow(base, exp): call _vx_pow runtime stub
        code = compile_expr(code, expr[2])  // exp -> RAX
        code = emit_push_reg(code, REG_RAX())
        code = compile_expr(code, expr[1])  // base -> RAX
        code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
        code = emit_pop_reg(code, REG_RSI())
        code = emit_u8(code, 232)
        add_fixup(len(code), "_vx_pow")
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "type_of" {
        // type_of(x): resolve type at compile time, return string
        let arg = expr[1]
        var type_str = "int"
        if expr_is_float(arg) {
            type_str = "float"
        }
        if expr_is_string(arg) {
            type_str = "string"
        }
        let arg_kind = arg[0]
        if arg_kind == "array" {
            type_str = "array"
        }
        if arg_kind == "ident" {
            let tidx = locals_find(arg[1])
            if tidx >= 0 {
                let ttype = locals_get_type(tidx)
                if ttype == "array" {
                    type_str = "array"
                }
            }
        }
        // Emit as a string constant (lea rax, [rip+disp32])
        let str_idx = add_string_literal(type_str)
        code = emit_u8(code, 72)
        code = emit_u8(code, 141)
        code = emit_u8(code, 5)
        add_fixup(len(code), "_str_" + to_string(str_idx))
        code = emit_u32_le(code, 0)
        return code
    }

    if kind == "call" {
        let fname = expr[1]
        let argc = len(expr) - 2
        // Evaluate args right-to-left, push to stack
        var a = argc - 1
        while a >= 0 {
            code = compile_expr(code, expr[a + 2])
            code = emit_push_reg(code, REG_RAX())
            a = a - 1
        }
        // Pop into arg registers left-to-right
        var b = 0
        while b < argc {
            code = emit_pop_reg(code, arg_reg(b))
            b = b + 1
        }
        // Emit call with fixup
        code = emit_u8(code, 232)
        add_fixup(len(code), fname)
        code = emit_u32_le(code, 0)
        return code
    }

    println("codegen warning: unknown expression kind '" + kind + "'")
    return code
}

// --- Statement compiler ---
fn compile_stmt(code: [i64], stmt: [String]) -> [i64] {
    let kind = stmt[0]

    if kind == "let" {
        let name = stmt[1]
        if _compiling_globals == 1 {
            let gidx = globals_add(name)
            code = compile_expr(code, stmt[2])
            // mov rcx, addr; mov [rcx], rax
            let addr = globals_addr(gidx)
            code = emit_mov_reg_imm64(code, REG_RCX(), addr)
            // mov [rcx], rax: 48 89 01
            code = emit_u8(code, 72)
            code = emit_u8(code, 137)
            code = emit_u8(code, 1)
            return code
        }
        let idx = locals_add(name)
        if expr_is_float(stmt[2]) {
            locals_set_type(idx, "float")
        }
        if expr_is_string(stmt[2]) {
            locals_set_type(idx, "string")
        }
        code = compile_expr(code, stmt[2])
        let off = locals_offset(idx)
        code = emit_store_local(code, REG_RAX(), off)
        return code
    }

    if kind == "var" {
        let name = stmt[1]
        if _compiling_globals == 1 {
            let gidx = globals_add(name)
            code = compile_expr(code, stmt[2])
            // mov rcx, addr; mov [rcx], rax
            let addr = globals_addr(gidx)
            code = emit_mov_reg_imm64(code, REG_RCX(), addr)
            // mov [rcx], rax: 48 89 01
            code = emit_u8(code, 72)
            code = emit_u8(code, 137)
            code = emit_u8(code, 1)
            return code
        }
        let idx = locals_add(name)
        if expr_is_float(stmt[2]) {
            locals_set_type(idx, "float")
        }
        if expr_is_string(stmt[2]) {
            locals_set_type(idx, "string")
        }
        code = compile_expr(code, stmt[2])
        let off = locals_offset(idx)
        code = emit_store_local(code, REG_RAX(), off)
        return code
    }

    if kind == "assign" {
        let name = stmt[1]
        code = compile_expr(code, stmt[2])
        let idx = locals_find(name)
        if idx >= 0 {
            if expr_is_float(stmt[2]) {
                locals_set_type(idx, "float")
            }
            if expr_is_string(stmt[2]) {
                locals_set_type(idx, "string")
            }
            let off = locals_offset(idx)
            code = emit_store_local(code, REG_RAX(), off)
        } else {
            let gidx = globals_find(name)
            if gidx >= 0 {
                let addr = globals_addr(gidx)
                // save rax, load addr into rcx, store rax to [rcx]
                code = emit_push_reg(code, REG_RAX())
                code = emit_mov_reg_imm64(code, REG_RCX(), addr)
                code = emit_pop_reg(code, REG_RAX())
                // mov [rcx], rax: 48 89 01
                code = emit_u8(code, 72)
                code = emit_u8(code, 137)
                code = emit_u8(code, 1)
            } else {
                println("codegen error: undefined variable '" + name + "' in assignment")
            }
        }
        return code
    }

    if kind == "return" {
        code = compile_expr(code, stmt[1])
        code = emit_epilogue(code)
        return code
    }

    if kind == "println" {
        code = compile_expr(code, stmt)
        return code
    }

    if kind == "print_str" {
        code = compile_expr(code, stmt)
        return code
    }

    if kind == "print" {
        code = compile_expr(code, stmt)
        return code
    }

    if kind == "write_file" {
        code = compile_expr(code, stmt)
        return code
    }

    if kind == "index_assign" {
        // arr[i] = val
        let name = stmt[1]
        let idx_expr = stmt[2]
        let val_expr = stmt[3]
        // Compile value
        code = compile_expr(code, val_expr)
        code = emit_push_reg(code, REG_RAX())  // save val
        // Compile index
        code = compile_expr(code, idx_expr)
        code = emit_push_reg(code, REG_RAX())  // save index
        // Load array ptr
        let idx = locals_find(name)
        if idx >= 0 {
            let off = locals_offset(idx)
            code = emit_load_local(code, off, REG_RAX())
        } else {
            println("codegen error: undefined variable '" + name + "' in index assign")
            code = emit_mov_reg_imm64(code, REG_RAX(), 0)
        }
        // RAX = arr ptr, [RSP] = index, [RSP+8] = val
        code = emit_pop_reg(code, REG_RCX())  // index -> RCX
        // offset = (RCX+1)*8
        code = emit_u8(code, 72)
        code = emit_u8(code, 131)
        code = emit_u8(code, 193)
        code = emit_u8(code, 1)
        code = emit_u8(code, 72)
        code = emit_u8(code, 193)
        code = emit_u8(code, 225)
        code = emit_u8(code, 3)
        code = emit_add_reg_reg(code, REG_RAX(), REG_RCX())
        code = emit_pop_reg(code, REG_RCX())  // val -> RCX
        // mov [rax], rcx: 48 89 08
        code = emit_u8(code, 72)
        code = emit_u8(code, 137)
        code = emit_u8(code, 8)
        return code
    }

    if kind == "expr_stmt" {
        code = compile_expr(code, stmt[1])
        return code
    }

    if kind == "if" {
        let else_label = fresh_label("else")
        let end_label = fresh_label("endif")
        // Compile condition
        code = compile_expr(code, stmt[1])
        // cmp rax, 0: 48 83 F8 00
        code = emit_u8(code, 72)
        code = emit_u8(code, 131)
        code = emit_u8(code, 248)
        code = emit_u8(code, 0)
        // je else_label: 0F 84 <rel32>
        code = emit_u8(code, 15)
        code = emit_u8(code, 132)
        add_fixup(len(code), else_label)
        code = emit_u32_le(code, 0)
        // Compile then block
        let then_stmts = stmt[2]
        var ti = 0
        while ti < len(then_stmts) {
            code = compile_stmt(code, then_stmts[ti])
            ti = ti + 1
        }
        // jmp end_label: E9 <rel32>
        code = emit_u8(code, 233)
        add_fixup(len(code), end_label)
        code = emit_u32_le(code, 0)
        // else_label:
        add_label(else_label, len(code))
        // Compile else block
        let else_stmts = stmt[3]
        var ei = 0
        while ei < len(else_stmts) {
            code = compile_stmt(code, else_stmts[ei])
            ei = ei + 1
        }
        // end_label:
        add_label(end_label, len(code))
        return code
    }

    if kind == "break" {
        let nloops = len(_loop_break_labels)
        if nloops > 0 {
            let brk_lbl = _loop_break_labels[nloops - 1]
            code = emit_u8(code, 233)
            add_fixup(len(code), brk_lbl)
            code = emit_u32_le(code, 0)
        } else {
            println("codegen error: break outside of loop")
        }
        return code
    }

    if kind == "continue" {
        let nloops = len(_loop_continue_labels)
        if nloops > 0 {
            let cont_lbl = _loop_continue_labels[nloops - 1]
            code = emit_u8(code, 233)
            add_fixup(len(code), cont_lbl)
            code = emit_u32_le(code, 0)
        } else {
            println("codegen error: continue outside of loop")
        }
        return code
    }

    if kind == "while" {
        let loop_label = fresh_label("while")
        let end_label = fresh_label("endwhile")
        // Push loop labels for break/continue
        _loop_break_labels = push(_loop_break_labels, end_label)
        _loop_continue_labels = push(_loop_continue_labels, loop_label)
        // loop_label:
        add_label(loop_label, len(code))
        // Compile condition
        code = compile_expr(code, stmt[1])
        // cmp rax, 0
        code = emit_u8(code, 72)
        code = emit_u8(code, 131)
        code = emit_u8(code, 248)
        code = emit_u8(code, 0)
        // je end_label
        code = emit_u8(code, 15)
        code = emit_u8(code, 132)
        add_fixup(len(code), end_label)
        code = emit_u32_le(code, 0)
        // Compile body
        let body_stmts = stmt[2]
        var bi = 0
        while bi < len(body_stmts) {
            code = compile_stmt(code, body_stmts[bi])
            bi = bi + 1
        }
        // jmp loop_label
        code = emit_u8(code, 233)
        add_fixup(len(code), loop_label)
        code = emit_u32_le(code, 0)
        // end_label:
        add_label(end_label, len(code))
        // Pop loop labels
        var new_brk: [String] = []
        var new_cont: [String] = []
        var li = 0
        while li < len(_loop_break_labels) - 1 {
            new_brk = push(new_brk, _loop_break_labels[li])
            new_cont = push(new_cont, _loop_continue_labels[li])
            li = li + 1
        }
        _loop_break_labels = new_brk
        _loop_continue_labels = new_cont
        return code
    }

    println("codegen warning: unknown statement kind '" + kind + "'")
    return code
}

// --- Function compiler ---
fn compile_function(code: [i64], func: [String]) -> [i64] {
    let name = func[1]
    let params = func[2]
    let body = func[3]

    register_function(name, len(code))

    // Set globals flag for _vx_init_globals
    if name == "_vx_init_globals" {
        _compiling_globals = 1
    } else {
        _compiling_globals = 0
    }

    // Reset locals
    _locals = []
    _local_types = []

    // Add params as locals
    var p = 0
    while p < len(params) {
        locals_add(params[p])
        p = p + 1
    }

    // Stack size: room for 16 locals (128 bytes), aligned to 16
    let stack_size = 128

    // Emit prologue
    code = emit_prologue(code, stack_size)

    // Store argument registers to local slots
    var a = 0
    while a < len(params) {
        let off = locals_offset(a)
        code = emit_store_local(code, arg_reg(a), off)
        a = a + 1
    }

    // Compile body statements
    var si = 0
    while si < len(body) {
        code = compile_stmt(code, body[si])
        si = si + 1
    }

    // Default epilogue (return 0)
    code = emit_mov_reg_imm64(code, REG_RAX(), 0)
    code = emit_epilogue(code)

    return code
}

// --- Runtime: _vx_print_int stub ---
// Converts i64 in RDI to decimal string on stack, prints with newline
fn emit_print_int_stub() -> [i64] {
    var out: [i64] = []
    // sub rsp, 32
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 32)
    // mov rax, rdi
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 248)
    // lea rsi, [rsp+31]
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 116)
    out = push(out, 36)
    out = push(out, 31)
    // mov byte [rsi], 0x0a (newline)
    out = push(out, 198)
    out = push(out, 6)
    out = push(out, 10)
    // xor rcx, rcx (digit counter)
    out = push(out, 72)
    out = push(out, 49)
    out = push(out, 201)
    // mov r8, 10
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 10)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // test rax, rax
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 192)
    // jns +3 (skip neg)
    out = push(out, 121)
    out = push(out, 3)
    // neg rax
    out = push(out, 72)
    out = push(out, 247)
    out = push(out, 216)
    // .digit_loop:
    // xor rdx, rdx
    out = push(out, 72)
    out = push(out, 49)
    out = push(out, 210)
    // div r8
    out = push(out, 73)
    out = push(out, 247)
    out = push(out, 240)
    // add dl, 0x30
    out = push(out, 128)
    out = push(out, 194)
    out = push(out, 48)
    // dec rsi
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 206)
    // mov [rsi], dl
    out = push(out, 136)
    out = push(out, 22)
    // inc rcx
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 193)
    // test rax, rax
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 192)
    // jnz .digit_loop (-22 = 0xea)
    out = push(out, 117)
    out = push(out, 234)
    // Check if original was negative (rdi < 0)
    // test rdi, rdi
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 255)
    // jns +9 (skip dec rsi + movb + inc rcx = 3+3+3 bytes)
    out = push(out, 121)
    out = push(out, 9)
    // dec rsi
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 206)
    // mov byte [rsi], 0x2d (minus)
    out = push(out, 198)
    out = push(out, 6)
    out = push(out, 45)
    // inc rcx
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 193)
    // lea rdx, [rcx+1] (include newline)
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 81)
    out = push(out, 1)
    // mov rax, 1 (SYS_WRITE)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // mov rdi, 1 (stdout)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // syscall
    out = push(out, 15)
    out = push(out, 5)
    // add rsp, 32
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 196)
    out = push(out, 32)
    // ret
    out = push(out, 195)
    return out
}

// --- Runtime: _vx_print_str stub ---
// Prints string struct at [RDI]: first 8 bytes = length, then bytes
// write(1, rdi+8, [rdi])
fn emit_print_str_stub() -> [i64] {
    var out: [i64] = []
    // Save rdi
    // mov rsi, rdi+8 (data pointer): lea rsi, [rdi+8]
    out = push(out, 72)   // 48 8D 77 08 = lea rsi, [rdi+8]
    out = push(out, 141)
    out = push(out, 119)
    out = push(out, 8)
    // mov rdx, [rdi] (length)
    out = push(out, 72)   // 48 8B 17 = mov rdx, [rdi]
    out = push(out, 139)
    out = push(out, 23)
    // mov rax, 1 (SYS_WRITE)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // mov rdi, 1 (stdout)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // syscall
    out = push(out, 15)
    out = push(out, 5)
    // ret
    out = push(out, 195)
    return out
}

// --- Runtime: _vx_alloc stub ---
// Allocates `rdi` bytes using mmap(0, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
// Returns pointer in RAX
fn emit_alloc_stub() -> [i64] {
    var out: [i64] = []
    // Save size in r8
    // mov r8, rdi: 49 89 F8
    out = push(out, 73)
    out = push(out, 137)
    out = push(out, 248)
    // mov rax, 9 (SYS_MMAP)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 9)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // mov rdi, 0 (addr = NULL)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // mov rsi, r8 (size)
    out = push(out, 76)  // 4C 89 C6 = mov rsi, r8
    out = push(out, 137)
    out = push(out, 198)
    // mov rdx, 3 (PROT_READ | PROT_WRITE)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 194)
    out = push(out, 3)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // mov r10, 34 (MAP_PRIVATE | MAP_ANONYMOUS = 0x22)
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 194)
    out = push(out, 34)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // mov r8, -1 (fd)
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 255)
    out = push(out, 255)
    out = push(out, 255)
    out = push(out, 255)
    // mov r9, 0 (offset)
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 193)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // syscall
    out = push(out, 15)
    out = push(out, 5)
    // ret (result in RAX)
    out = push(out, 195)
    return out
}

// --- Runtime: _vx_arr_push stub ---
// RDI = old array ptr, RSI = value to push
// Allocates new array with len+1, copies old, appends val
// Returns new array ptr in RAX
fn emit_arr_push_stub() -> [i64] {
    var out: [i64] = []
    // push rbp; mov rbp, rsp; sub rsp, 48
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 48)
    // Save args: [rbp-8] = old_arr(rdi), [rbp-16] = val(rsi)
    // mov [rbp-8], rdi
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)  // -8
    // mov [rbp-16], rsi
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 117)
    out = push(out, 240)  // -16
    // Load old length: mov rax, [rdi]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 7)
    // Save old_len in [rbp-24]
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 232)  // -24
    // new_size = (old_len + 2) * 8  -> rdi for alloc
    // add rax, 2
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 192)
    out = push(out, 2)
    // shl rax, 3
    out = push(out, 72)
    out = push(out, 193)
    out = push(out, 224)
    out = push(out, 3)
    // mov rdi, rax
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 199)
    // call _vx_alloc — but we can't call by name here, so inline the mmap
    // Actually, we need a call. We'll use a near call with fixup.
    // Problem: stubs don't have fixup mechanism. Let's inline mmap.

    // mov rsi, rdi (size); mov rdi, 0; mov rax, 9; mov rdx, 3; mov r10, 34; mov r8, -1; mov r9, 0; syscall
    // rdi currently has size, move to rsi
    out = push(out, 72)    // mov rsi, rdi: 48 89 FE
    out = push(out, 137)
    out = push(out, 254)
    // mov rdi, 0
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // mov rax, 9
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 9)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // mov rdx, 3
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 194)
    out = push(out, 3)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // mov r10, 34
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 194)
    out = push(out, 34)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // mov r8, -1
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 255)
    out = push(out, 255)
    out = push(out, 255)
    out = push(out, 255)
    // mov r9, 0
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 193)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // syscall
    out = push(out, 15)
    out = push(out, 5)

    // RAX = new array ptr. Save in [rbp-32]
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 224)  // -32

    // Store new length = old_len + 1
    // mov rcx, [rbp-24] (old_len)
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 77)
    out = push(out, 232)
    // add rcx, 1
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 193)
    out = push(out, 1)
    // mov [rax], rcx
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 8)

    // Copy old elements: for i = 0..old_len: new[i+1] = old[i+1]
    // Actually copy (old_len+1)*8 bytes from old to new... wait, copy old_len elements
    // Use a loop: rcx = old_len (already in rcx-1, need to reload)
    // mov rcx, [rbp-24]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 77)
    out = push(out, 232)
    // test rcx, rcx
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 201)
    // jz skip_copy (+30 bytes approx) — we'll use a forward jump
    out = push(out, 116)
    let jz_skip = len(out)
    out = push(out, 0)  // placeholder for offset

    // r8 = 0 (loop counter)
    out = push(out, 73)
    out = push(out, 49)
    out = push(out, 192)
    // .copy_loop:
    let copy_loop_pos = len(out)
    // Load old_arr ptr
    // mov rdi, [rbp-8]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 125)
    out = push(out, 248)
    // mov rdx, r8
    out = push(out, 76)  // 4C 89 C2
    out = push(out, 137)
    out = push(out, 194)
    // add rdx, 1
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 194)
    out = push(out, 1)
    // shl rdx, 3
    out = push(out, 72)
    out = push(out, 193)
    out = push(out, 226)
    out = push(out, 3)
    // mov rsi, [rdi + rdx]
    out = push(out, 72)  // 48 8B 34 17 = mov rsi, [rdi+rdx]
    out = push(out, 139)
    out = push(out, 52)
    out = push(out, 23)
    // mov rdi, [rbp-32] (new arr)
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 125)
    out = push(out, 224)
    // mov [rdi + rdx], rsi
    out = push(out, 72)  // 48 89 34 17
    out = push(out, 137)
    out = push(out, 52)
    out = push(out, 23)
    // inc r8
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 192)
    // cmp r8, rcx
    out = push(out, 73)  // 49 39 C8 = cmp r8, rcx
    out = push(out, 57)
    out = push(out, 200)
    // jb .copy_loop
    let loop_delta = copy_loop_pos - len(out) - 2
    out = push(out, 114)
    var jb_off = loop_delta % 256
    if jb_off < 0 {
        jb_off = jb_off + 256
    }
    out = push(out, jb_off)

    // Patch jz_skip offset
    let skip_target = len(out)
    let skip_off = skip_target - jz_skip - 1
    out[jz_skip] = skip_off

    // Store new value at index old_len+1
    // mov rax, [rbp-32] (new arr)
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 69)
    out = push(out, 224)
    // mov rcx, [rbp-24] (old_len)
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 77)
    out = push(out, 232)
    // add rcx, 1
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 193)
    out = push(out, 1)
    // shl rcx, 3
    out = push(out, 72)
    out = push(out, 193)
    out = push(out, 225)
    out = push(out, 3)
    // mov rdx, [rbp-16] (val)
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 85)
    out = push(out, 240)
    // mov [rax + rcx], rdx
    out = push(out, 72)  // 48 89 14 08
    out = push(out, 137)
    out = push(out, 20)
    out = push(out, 8)

    // Return new arr ptr in RAX (already in rax)
    // epilogue
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 236)
    out = push(out, 93)
    out = push(out, 195)
    return out
}

// --- Runtime: _vx_print_float stub ---
// Input: float bits in RDI
// Prints the float as "integer.fraction\n" with 6 decimal places
fn emit_print_float_stub() -> [i64] {
    var out: [i64] = []
    // push rbp; mov rbp, rsp; sub rsp, 64
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 64)
    // Save rdi in [rbp-8]
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)
    // movq xmm0, rdi: 66 48 0F 6E C7
    out = push(out, 102)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 110)
    out = push(out, 199)
    // Check sign: test rdi, rdi; jns skip_neg
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 255)
    out = push(out, 121)  // jns +29
    out = push(out, 29)
    // Negative: print '-' character
    // mov byte [rbp-48], 0x2d
    out = push(out, 198)
    out = push(out, 69)
    out = push(out, 208)  // -48
    out = push(out, 45)
    // write(1, rbp-48, 1)
    out = push(out, 72)  // mov rax, 1
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 72)  // mov rdi, 1
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 72)  // lea rsi, [rbp-48]
    out = push(out, 141)
    out = push(out, 117)
    out = push(out, 208)
    out = push(out, 72)  // mov rdx, 1
    out = push(out, 199)
    out = push(out, 194)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // syscall
    out = push(out, 15)
    out = push(out, 5)
    // Negate xmm0: load sign mask, xorpd
    // Actually simpler: reload from [rbp-8], clear sign bit, movq back
    // mov rdi, [rbp-8]; btr rdi, 63; movq xmm0, rdi
    out = push(out, 72)  // mov rdi, [rbp-8]
    out = push(out, 139)
    out = push(out, 125)
    out = push(out, 248)
    // btr rdi, 63: 48 0F BA F7 3F
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 186)
    out = push(out, 247)
    out = push(out, 63)
    // movq xmm0, rdi: 66 48 0F 6E C7
    out = push(out, 102)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 110)
    out = push(out, 199)
    // skip_neg:
    // cvttsd2si rax, xmm0: F2 48 0F 2C C0
    out = push(out, 242)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 44)
    out = push(out, 192)
    // Save integer part in [rbp-16]
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 240)
    // Save xmm0 in [rbp-24]: movq [rbp-24], xmm0 -> movq rdi, xmm0; mov [rbp-24], rdi
    // movq rdi, xmm0: 66 48 0F 7E C7
    out = push(out, 102)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 126)
    out = push(out, 199)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 232)
    // Print integer part: convert to string on stack
    // Use same algorithm as print_int but no newline
    // sub rsp, 32
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 32)
    // mov rax, [rbp-16] (integer part)
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 69)
    out = push(out, 240)
    // lea rsi, [rsp+31]
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 116)
    out = push(out, 36)
    out = push(out, 31)
    // mov byte [rsi], '.' (0x2e) - we'll put dot after digits
    // Actually, let's point rsi to end of buffer, write digits backwards, then write(digits), write('.'), write(frac)
    // xor rcx, rcx
    out = push(out, 72)
    out = push(out, 49)
    out = push(out, 201)
    // mov r8, 10
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 10)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // test rax, rax; jnz digit_loop
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 192)
    out = push(out, 117)  // jnz +7
    out = push(out, 7)
    // rax is 0: put '0' and set rcx=1
    out = push(out, 72)  // dec rsi
    out = push(out, 255)
    out = push(out, 206)
    out = push(out, 198)  // mov byte [rsi], '0'
    out = push(out, 6)
    out = push(out, 48)
    out = push(out, 72)  // inc rcx (was xor'd to 0, now 1... actually need mov rcx, 1)
    // Hmm, inc rcx after xor rcx gives 1. Let me check.
    // Actually: xor rcx,rcx = 0, then inc rcx = 1. But we jump past digit_loop.
    // Need to jump past the loop. Let me use jmp.
    // Actually let me restructure: after test rax,rax, if zero, just write "0"
    // This is getting very long. Let me simplify by just putting a jump over the digit loop.

    // Scratch that complex approach. Let me restart the stub more simply.
    // I'll write it as a complete self-contained piece.
    return emit_print_float_stub_v2()
}

fn emit_print_float_stub_v2() -> [i64] {
    var out: [i64] = []
    // _vx_print_float: rdi = float bits
    // Strategy: use a 48-byte buffer on stack for output string
    // push rbp; mov rbp, rsp; sub rsp, 80
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 80)

    // Save float bits in [rbp-8]
    // mov [rbp-8], rdi
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)

    // r12 = output buffer pointer = rbp-72
    // lea r12, [rbp-72]: 4C 8D 65 B8
    out = push(out, 76)
    out = push(out, 141)
    out = push(out, 101)
    out = push(out, 184)

    // r13 = current write position (index)
    // xor r13, r13: 4D 31 ED
    out = push(out, 77)
    out = push(out, 49)
    out = push(out, 237)

    // Check sign bit: test rdi, rdi; jns .positive
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 255)
    out = push(out, 121)  // jns +7
    out = push(out, 7)

    // Write '-': mov byte [r12], 0x2d; inc r13
    // mov byte [r12+r13], 0x2d: 41 C6 04 2C 2D
    out = push(out, 65)
    out = push(out, 198)
    out = push(out, 4)
    out = push(out, 44)
    out = push(out, 45)
    // inc r13: 49 FF C5
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 197)

    // .positive: clear sign bit in rdi, movq xmm0
    // btr rdi, 63: 48 0F BA F7 3F
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 186)
    out = push(out, 247)
    out = push(out, 63)

    // movq xmm0, rdi: 66 48 0F 6E C7
    out = push(out, 102)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 110)
    out = push(out, 199)

    // cvttsd2si rax, xmm0: F2 48 0F 2C C0  (integer part)
    out = push(out, 242)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 44)
    out = push(out, 192)

    // Save xmm0 in [rbp-16] via rdi
    // movq rdi, xmm0: 66 48 0F 7E C7
    out = push(out, 102)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 126)
    out = push(out, 199)
    out = push(out, 72)  // mov [rbp-16], rdi
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 240)

    // Save integer part in [rbp-24]
    // mov [rbp-24], rax
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 232)

    // Convert integer part to decimal digits (backwards into temp area)
    // Use rbp-40 as temp buffer for int digits (8 bytes enough)
    // lea rsi, [rbp-33]: point to end of temp area
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 117)
    out = push(out, 223)  // rbp-33

    // xor rcx, rcx (digit count)
    out = push(out, 72)
    out = push(out, 49)
    out = push(out, 201)

    // mov r8, 10
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 10)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)

    // test rax, rax; jnz .int_loop
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 192)
    out = push(out, 117)  // jnz
    out = push(out, 10)   // skip to int_loop

    // rax == 0: write '0'
    out = push(out, 72)  // dec rsi
    out = push(out, 255)
    out = push(out, 206)
    out = push(out, 198)  // mov byte [rsi], '0'
    out = push(out, 6)
    out = push(out, 48)
    out = push(out, 72)  // mov rcx, 1
    out = push(out, 199)
    out = push(out, 193)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // jmp .int_done (+16 bytes for loop)
    out = push(out, 235)  // jmp short
    out = push(out, 18)   // offset to after loop

    // .int_loop: (at offset from jnz)
    // xor rdx, rdx
    out = push(out, 72)
    out = push(out, 49)
    out = push(out, 210)
    // div r8
    out = push(out, 73)
    out = push(out, 247)
    out = push(out, 240)
    // add dl, '0'
    out = push(out, 128)
    out = push(out, 194)
    out = push(out, 48)
    // dec rsi
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 206)
    // mov [rsi], dl
    out = push(out, 136)
    out = push(out, 22)
    // inc rcx
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 193)
    // test rax, rax; jnz .int_loop
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 192)
    out = push(out, 117)  // jnz
    out = push(out, 234)  // -22 (back to xor rdx)

    // .int_done:
    // Copy int digits to output buffer: memcpy r12+r13, rsi, rcx
    // Save rcx in r8
    // mov r8, rcx: 49 89 C8
    out = push(out, 73)
    out = push(out, 137)
    out = push(out, 200)

    // .copy_int: (loop: copy byte by byte)
    // test r8, r8; jz .copy_done
    out = push(out, 77)
    out = push(out, 133)
    out = push(out, 192)
    out = push(out, 116)  // jz
    out = push(out, 12)   // skip loop body

    // mov al, [rsi]: 8A 06
    out = push(out, 138)
    out = push(out, 6)
    // mov [r12+r13], al: 43 88 04 2C
    // Actually: 43 is REX.XB. Let me use: mov byte [r12+r13*1], al
    // 42 88 04 2C
    out = push(out, 66)
    out = push(out, 136)
    out = push(out, 4)
    out = push(out, 44)
    // inc rsi: 48 FF C6
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 198)
    // inc r13: 49 FF C5
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 197)
    // dec r8: 49 FF C8
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 200)
    // jmp .copy_int: EB -15
    out = push(out, 235)
    out = push(out, 238)  // -18... let me count: test(3)+jz(2)+mov(2)+mov(4)+inc(3)+inc(3)+dec(3)+jmp(2) = need to jump back 22 bytes
    // Actually let me recount the bytes from test r8,r8:
    // test r8,r8 = 4D 85 C0 = 3 bytes
    // jz = 74 0C = 2 bytes
    // mov al,[rsi] = 8A 06 = 2 bytes
    // mov [r12+r13],al = 42 88 04 2C = 4 bytes
    // inc rsi = 48 FF C6 = 3 bytes
    // inc r13 = 49 FF C5 = 3 bytes
    // dec r8 = 49 FF C8 = 3 bytes
    // jmp = EB xx = 2 bytes
    // Total loop body after test: 2+2+4+3+3+3+2 = 19
    // Jump back from end of jmp to test r8: -(19+3) = -22
    // Wait, from jmp instruction end to test start:
    // jmp is at offset 3+2+2+4+3+3+3 = 20 from test
    // After jmp (2 bytes), we're at offset 22 from test
    // So offset = -22, which is 256-22 = 234
    // Hmm I already put 238 above which is wrong. Let me fix.

    // Actually, let me just redo this. The bytes above after .copy_done jz offset are wrong.
    // Let me restart the copy loop more carefully.
    // I'll scrap the last few instructions and redo.

    // Actually this is getting way too complex byte by byte. Let me use a much simpler approach.
    // Instead of building the string in memory, I'll just do multiple write() syscalls:
    // 1. Write the integer part digits
    // 2. Write "."
    // 3. Write the fractional digits
    // 4. Write "\n"

    // Let me scrap the above and start completely fresh with a cleaner approach.
    return emit_print_float_simple()
}

fn emit_print_float_simple() -> [i64] {
    // Simple approach: call _vx_print_int for integer part (without newline - oh wait, print_int adds newline)
    // Even simpler: just convert the entire thing to an integer representation
    // Print as: integer_part * 1000000 + frac_part, formatted properly
    //
    // Simplest possible: multiply float by 1000000, convert to int, then:
    // print (result / 1000000), '.', zero-padded (result % 1000000), newline
    //
    // But we need to do this all in machine code...
    //
    // OK, let me just write the whole thing as x86 machine code step by step.
    // The function will:
    // 1. movq xmm0, rdi (get the float)
    // 2. Handle sign
    // 3. Multiply by 1000000.0
    // 4. cvttsd2si rax, xmm0 (get integer representation * 1000000)
    // 5. Use the print_int algorithm to print with a dot inserted at the right place

    var out: [i64] = []

    // push rbp; mov rbp, rsp; sub rsp, 48
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 48)

    // movq xmm0, rdi: 66 48 0F 6E C7
    out = push(out, 102)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 110)
    out = push(out, 199)

    // Save sign: test rdi, rdi; sets r14 to 1 if negative
    // xor r14, r14: 4D 31 F6
    out = push(out, 77)
    out = push(out, 49)
    out = push(out, 246)
    // test rdi, rdi
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 255)
    // jns +8
    out = push(out, 121)
    out = push(out, 8)
    // mov r14, 1: 49 C7 C6 01 00 00 00
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 198)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // Clear sign bit: btr rdi, 63; movq xmm0, rdi
    out = push(out, 72)  // btr rdi, 63
    out = push(out, 15)
    out = push(out, 186)
    out = push(out, 247)
    out = push(out, 63)
    out = push(out, 102)  // movq xmm0, rdi
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 110)
    out = push(out, 199)

    // Multiply xmm0 by 1000000.0
    // Load 1000000.0 bits into rax, movq xmm1, rax, mulsd xmm0, xmm1
    // 1000000.0 = 0x4124_0000_0000_0000 = 4696837146684686336
    // mov rax, 4696837146684686336: 48 B8 <8 bytes>
    out = push(out, 72)
    out = push(out, 184)
    // 0x41240000_00000000 in little-endian:
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 36)   // 0x24
    out = push(out, 65)   // 0x41

    // movq xmm1, rax: 66 48 0F 6E C8
    out = push(out, 102)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 110)
    out = push(out, 200)

    // mulsd xmm0, xmm1: F2 0F 59 C1
    out = push(out, 242)
    out = push(out, 15)
    out = push(out, 89)
    out = push(out, 193)

    // Add 0.5 for rounding: load 0.5 into xmm1, addsd
    // 0.5 = 0x3FE0_0000_0000_0000 = 4602678819172646912
    out = push(out, 72)
    out = push(out, 184)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 224)  // 0xE0
    out = push(out, 63)   // 0x3F
    out = push(out, 102)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 110)
    out = push(out, 200)
    // addsd xmm0, xmm1: F2 0F 58 C1
    out = push(out, 242)
    out = push(out, 15)
    out = push(out, 88)
    out = push(out, 193)

    // cvttsd2si rax, xmm0: F2 48 0F 2C C0
    out = push(out, 242)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 44)
    out = push(out, 192)

    // Now rax = value * 1000000 (as integer)
    // Save in [rbp-8]
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 248)

    // Now build the output string on stack: up to 32 bytes at [rsp]
    // We need to print: [sign] int_part . frac_part \n
    // int_part = rax / 1000000
    // frac_part = rax % 1000000 (zero-padded to 6 digits)

    // First, write all digits of the full number backwards, then insert dot
    // Actually easier: build string forward.
    // Use rsp as buffer base, r12 as write index

    // lea r12, [rbp-40]: 4C 8D 65 D8
    out = push(out, 76)
    out = push(out, 141)
    out = push(out, 101)
    out = push(out, 216)

    // xor r13, r13 (write index): 4D 31 ED
    out = push(out, 77)
    out = push(out, 49)
    out = push(out, 237)

    // If negative, write '-'
    // test r14, r14: 4D 85 F6
    out = push(out, 77)
    out = push(out, 133)
    out = push(out, 246)
    // jz +7
    out = push(out, 116)
    out = push(out, 7)
    // mov byte [r12], '-': 41 C6 04 24 2D
    out = push(out, 65)
    out = push(out, 198)
    out = push(out, 4)
    out = push(out, 36)
    out = push(out, 45)
    // inc r13: 49 FF C5
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 197)
    // Hmm wait - this approach is also getting very complex.
    // Let me just use multiple write() syscalls. That's much simpler.
    //
    // Plan:
    // 1. If negative, write('-')
    // 2. Compute int_part = total / 1000000, write digits of int_part
    // 3. Write('.')
    // 4. Compute frac = total % 1000000, write 6 digits (with leading zeros)
    // 5. Write('\n')
    //
    // For writing digits, I need a small subroutine. But in a flat stub,
    // I'll just inline the digit-writing loop twice.
    //
    // This is still complex. Let me take the simplest possible approach:
    // Build the entire string in a buffer, then one write() call.

    // Let me restart with a truly clean implementation.
    return emit_print_float_v3()
}

fn emit_print_float_v3() -> [i64] {
    // Approach: Build output in 32-byte buffer on stack, then single write() syscall
    // rdi = float bits on entry
    var out: [i64] = []

    // push rbp; mov rbp, rsp
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    // push r12; push r13; push r14; push r15 (callee-saved)
    out = push(out, 65)
    out = push(out, 84)
    out = push(out, 65)
    out = push(out, 85)
    out = push(out, 65)
    out = push(out, 86)
    out = push(out, 65)
    out = push(out, 87)
    // sub rsp, 48
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 48)

    // Clear sign bit, check negativity
    // mov r14, rdi (save original bits)
    out = push(out, 73)
    out = push(out, 137)
    out = push(out, 254)
    // btr rdi, 63 -> clear sign
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 186)
    out = push(out, 247)
    out = push(out, 63)
    // movq xmm0, rdi
    out = push(out, 102)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 110)
    out = push(out, 199)

    // Multiply by 1000000.0 (0x412E848000000000)
    out = push(out, 72)
    out = push(out, 184)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 128)
    out = push(out, 132)
    out = push(out, 46)
    out = push(out, 65)
    out = push(out, 102)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 110)
    out = push(out, 200)
    // mulsd
    out = push(out, 242)
    out = push(out, 15)
    out = push(out, 89)
    out = push(out, 193)
    // Add 0.5 for rounding (0x3FE0000000000000)
    out = push(out, 72)
    out = push(out, 184)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 224)
    out = push(out, 63)
    out = push(out, 102)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 110)
    out = push(out, 200)
    out = push(out, 242)
    out = push(out, 15)
    out = push(out, 88)
    out = push(out, 193)
    // cvttsd2si rax, xmm0
    out = push(out, 242)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 44)
    out = push(out, 192)
    // rax = val * 1000000 (integer, always positive)
    // r15 = rax (save total)
    out = push(out, 73)
    out = push(out, 137)
    out = push(out, 199)

    // Build string backwards from rsp+31
    // r12 = buffer end pointer
    // lea r12, [rsp+31]: 4C 8D 64 24 1F
    out = push(out, 76)
    out = push(out, 141)
    out = push(out, 100)
    out = push(out, 36)
    out = push(out, 31)

    // Write newline at end
    // mov byte [r12], 0x0a: 41 C6 04 24 0A
    out = push(out, 65)
    out = push(out, 198)
    out = push(out, 4)
    out = push(out, 36)
    out = push(out, 10)
    // dec r12: 49 FF CC
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 204)

    // Now write 6 fractional digits (rax % 1000000, but we have it in r15)
    // mov rax, r15: 4C 89 F8
    out = push(out, 76)
    out = push(out, 137)
    out = push(out, 248)
    // r8 = 10
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 10)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)

    // Write 6 decimal digits (from right to left)
    // rcx = 6
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 193)
    out = push(out, 6)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)

    // .frac_loop:
    let frac_loop_pos = len(out)
    // xor rdx, rdx
    out = push(out, 72)
    out = push(out, 49)
    out = push(out, 210)
    // div r8
    out = push(out, 73)
    out = push(out, 247)
    out = push(out, 240)
    // add dl, '0'
    out = push(out, 128)
    out = push(out, 194)
    out = push(out, 48)
    // mov [r12], dl: 41 88 14 24
    out = push(out, 65)
    out = push(out, 136)
    out = push(out, 20)
    out = push(out, 36)
    // dec r12
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 204)
    // dec rcx
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 201)
    // jnz .frac_loop
    let frac_jnz_pos = len(out)
    let frac_delta = frac_loop_pos - frac_jnz_pos - 2
    out = push(out, 117)
    var frac_off = frac_delta % 256
    if frac_off < 0 {
        frac_off = frac_off + 256
    }
    out = push(out, frac_off)

    // Write dot: mov byte [r12], '.': 41 C6 04 24 2E
    out = push(out, 65)
    out = push(out, 198)
    out = push(out, 4)
    out = push(out, 36)
    out = push(out, 46)
    // dec r12
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 204)

    // rax still has int_part (after dividing 6 times by 10 from total)
    // It's the quotient after removing 6 digits, which is total / 1000000 = int part
    // Write integer part digits
    // If rax == 0, write '0'
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 192)
    out = push(out, 117)  // jnz
    out = push(out, 10)   // skip to int_loop (5+3+2=10 bytes)
    // Write '0'
    out = push(out, 65)
    out = push(out, 198)
    out = push(out, 4)
    out = push(out, 36)
    out = push(out, 48)
    // dec r12
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 204)
    // jmp .int_done
    out = push(out, 235)
    out = push(out, 21)  // skip int_loop (3+3+3+4+3+3+2=21 bytes)

    // .int_loop:
    let int_loop_pos = len(out)
    // xor rdx, rdx
    out = push(out, 72)
    out = push(out, 49)
    out = push(out, 210)
    // div r8
    out = push(out, 73)
    out = push(out, 247)
    out = push(out, 240)
    // add dl, '0'
    out = push(out, 128)
    out = push(out, 194)
    out = push(out, 48)
    // mov [r12], dl
    out = push(out, 65)
    out = push(out, 136)
    out = push(out, 20)
    out = push(out, 36)
    // dec r12
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 204)
    // test rax, rax
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 192)
    // jnz .int_loop
    let int_jnz_pos = len(out)
    let int_delta = int_loop_pos - int_jnz_pos - 2
    out = push(out, 117)
    var int_off = int_delta % 256
    if int_off < 0 {
        int_off = int_off + 256
    }
    out = push(out, int_off)

    // .int_done:
    // If negative, write '-'
    // test r14, r14: 4D 85 F6
    out = push(out, 77)
    out = push(out, 133)
    out = push(out, 246)
    // jns +8 (skip writing minus if not negative)
    out = push(out, 121)
    out = push(out, 8)
    // Write '-'
    out = push(out, 65)
    out = push(out, 198)
    out = push(out, 4)
    out = push(out, 36)
    out = push(out, 45)
    // dec r12
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 204)

    // Now write(1, r12+1, rsp+32 - (r12+1))
    // r12 points one before the first char
    // First char is at r12+1
    // Last char (newline) is at rsp+31
    // Length = rsp+31 - r12  (since r12 is one before first char, and last is at rsp+31)
    // lea rsi, [r12+1]: 49 8D 74 24 01
    out = push(out, 73)
    out = push(out, 141)
    out = push(out, 116)
    out = push(out, 36)
    out = push(out, 1)

    // rdx = length: lea rdx, [rsp+32]; sub rdx, rsi
    // lea rdx, [rsp+32]: 48 8D 54 24 20
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 84)
    out = push(out, 36)
    out = push(out, 32)
    // sub rdx, rsi: 48 29 F2
    out = push(out, 72)
    out = push(out, 41)
    out = push(out, 242)

    // mov rax, 1 (SYS_WRITE)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // mov rdi, 1 (stdout)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // syscall
    out = push(out, 15)
    out = push(out, 5)

    // Epilogue: add rsp, 48; pop r15; pop r14; pop r13; pop r12; pop rbp; ret
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 196)
    out = push(out, 48)
    out = push(out, 65)
    out = push(out, 95)
    out = push(out, 65)
    out = push(out, 94)
    out = push(out, 65)
    out = push(out, 93)
    out = push(out, 65)
    out = push(out, 92)
    out = push(out, 93)
    out = push(out, 195)

    return out
}

// --- Helper: emit inline mmap(size in rdi) -> rax ---
fn emit_inline_mmap(out: [i64]) -> [i64] {
    out = push(out, 72)    // mov rsi, rdi
    out = push(out, 137)
    out = push(out, 254)
    out = push(out, 72)    // mov rdi, 0
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 72)    // mov rax, 9
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 9)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 72)    // mov rdx, 3
    out = push(out, 199)
    out = push(out, 194)
    out = push(out, 3)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 73)    // mov r10, 34
    out = push(out, 199)
    out = push(out, 194)
    out = push(out, 34)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 73)    // mov r8, -1
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 255)
    out = push(out, 255)
    out = push(out, 255)
    out = push(out, 255)
    out = push(out, 73)    // mov r9, 0
    out = push(out, 199)
    out = push(out, 193)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 15)    // syscall
    out = push(out, 5)
    return out
}

// --- Runtime: _vx_println_str stub ---
fn emit_println_str_stub() -> [i64] {
    var out: [i64] = []
    out = push(out, 85)    // push rbp
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)   // mov rbp, rsp
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 32)   // sub rsp, 32
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)  // mov [rbp-8], rdi
    // write(1, rdi+8, [rdi])
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 119)
    out = push(out, 8)    // lea rsi, [rdi+8]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 23)   // mov rdx, [rdi]
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)    // mov rax, 1
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)    // mov rdi, 1
    out = push(out, 15)
    out = push(out, 5)    // syscall
    // write newline
    out = push(out, 198)
    out = push(out, 69)
    out = push(out, 240)
    out = push(out, 10)   // mov byte [rbp-16], 10
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 117)
    out = push(out, 240)  // lea rsi, [rbp-16]
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 194)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)    // mov rdx, 1
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)    // mov rax, 1
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)    // mov rdi, 1
    out = push(out, 15)
    out = push(out, 5)    // syscall
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 236)  // mov rsp, rbp
    out = push(out, 93)   // pop rbp
    out = push(out, 195)  // ret
    return out
}

// --- Runtime: _vx_str_eq stub ---
fn emit_str_eq_stub() -> [i64] {
    var out: [i64] = []
    out = push(out, 85)    // push rbp
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)   // mov rbp, rsp
    // len_a = [rdi]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 7)    // mov rax, [rdi]
    // len_b = [rsi]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 14)   // mov rcx, [rsi]
    // cmp rax, rcx
    out = push(out, 72)
    out = push(out, 57)
    out = push(out, 200)
    // jne .not_equal
    out = push(out, 117)
    let jne_patch = len(out)
    out = push(out, 0)
    // lengths equal, compare bytes
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 193)  // mov rcx, rax
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 199)
    out = push(out, 8)    // add rdi, 8
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 198)
    out = push(out, 8)    // add rsi, 8
    // test rcx, rcx; jz .equal
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 201)
    out = push(out, 116)
    let jz_eq = len(out)
    out = push(out, 0)
    // .loop:
    let loop_pos = len(out)
    out = push(out, 138)
    out = push(out, 7)    // mov al, [rdi]
    out = push(out, 58)
    out = push(out, 6)    // cmp al, [rsi]
    out = push(out, 117)
    let jne2 = len(out)
    out = push(out, 0)    // jne .not_equal
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 199)  // inc rdi
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 198)  // inc rsi
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 201)  // dec rcx
    out = push(out, 117)  // jnz .loop
    var loop_off = (loop_pos - len(out) - 1) % 256
    if loop_off < 0 {
        loop_off = loop_off + 256
    }
    out = push(out, loop_off)
    // .equal:
    out[jz_eq] = len(out) - jz_eq - 1
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)    // mov rax, 1
    out = push(out, 235)  // jmp .done
    let jmp_done = len(out)
    out = push(out, 0)
    // .not_equal:
    let ne_pos = len(out)
    out[jne_patch] = ne_pos - jne_patch - 1
    out[jne2] = ne_pos - jne2 - 1
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)    // mov rax, 0
    // .done:
    out[jmp_done] = len(out) - jmp_done - 1
    out = push(out, 93)   // pop rbp
    out = push(out, 195)  // ret
    return out
}

// --- Runtime: _vx_str_concat stub ---
fn emit_str_concat_stub() -> [i64] {
    var out: [i64] = []
    out = push(out, 85)    // push rbp
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)   // mov rbp, rsp
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 48)   // sub rsp, 48
    // [rbp-8]=a, [rbp-16]=b
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 117)
    out = push(out, 240)
    // len_a, save [rbp-24]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 7)    // mov rax, [rdi]
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 232)
    // len_b
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 14)   // mov rcx, [rsi]
    // new_len = rax + rcx
    out = push(out, 72)
    out = push(out, 1)
    out = push(out, 200)  // add rax, rcx
    // save [rbp-32]
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 224)
    // alloc new_len + 8
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 192)
    out = push(out, 8)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 199)  // mov rdi, rax
    out = emit_inline_mmap(out)
    // save [rbp-40]
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 216)
    // store new_len
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 77)
    out = push(out, 224)  // mov rcx, [rbp-32]
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 8)    // mov [rax], rcx
    // copy a: dst=rax+8, src=[rbp-8]+8, count=[rbp-24]
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 120)
    out = push(out, 8)    // lea rdi, [rax+8]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 117)
    out = push(out, 248)  // mov rsi, [rbp-8]
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 198)
    out = push(out, 8)    // add rsi, 8
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 77)
    out = push(out, 232)  // mov rcx, [rbp-24]
    out = push(out, 243)
    out = push(out, 164)  // rep movsb
    // copy b: src=[rbp-16]+8, count=new_len-len_a
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 117)
    out = push(out, 240)  // mov rsi, [rbp-16]
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 198)
    out = push(out, 8)    // add rsi, 8
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 77)
    out = push(out, 224)  // mov rcx, [rbp-32]
    out = push(out, 72)
    out = push(out, 43)
    out = push(out, 77)
    out = push(out, 232)  // sub rcx, [rbp-24]
    out = push(out, 243)
    out = push(out, 164)  // rep movsb
    // return
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 69)
    out = push(out, 216)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 236)
    out = push(out, 93)
    out = push(out, 195)
    return out
}

// --- Runtime: _vx_to_string stub ---
fn emit_to_string_stub() -> [i64] {
    var out: [i64] = []
    out = push(out, 85)    // push rbp
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)   // mov rbp, rsp
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 48)   // sub rsp, 48
    // save input [rbp-8]
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)
    // alloc 32 bytes
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 32)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = emit_inline_mmap(out)
    // save buf [rbp-16]
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 240)
    // r8 = value
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 69)
    out = push(out, 248)  // mov rax, [rbp-8]
    out = push(out, 73)
    out = push(out, 137)
    out = push(out, 192)  // mov r8, rax
    // r9 = 0 (neg flag)
    out = push(out, 77)
    out = push(out, 49)
    out = push(out, 201)
    // test r8, r8; jns .pos
    out = push(out, 77)
    out = push(out, 133)
    out = push(out, 192)
    out = push(out, 121)
    let jns_p = len(out)
    out = push(out, 0)
    // neg r8; r9=1
    out = push(out, 73)
    out = push(out, 247)
    out = push(out, 216)
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 193)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out[jns_p] = len(out) - jns_p - 1
    // r10 = 0 (digit count)
    out = push(out, 77)
    out = push(out, 49)
    out = push(out, 210)
    // test r8; jnz .convert
    out = push(out, 77)
    out = push(out, 133)
    out = push(out, 192)
    out = push(out, 117)
    let jnz_p = len(out)
    out = push(out, 0)
    // push '0', inc r10, jmp .write
    out = push(out, 106)
    out = push(out, 48)
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 194)
    out = push(out, 235)
    let jmp_w = len(out)
    out = push(out, 0)
    // .convert:
    let cvt = len(out)
    out[jnz_p] = cvt - jnz_p - 1
    out = push(out, 76)
    out = push(out, 137)
    out = push(out, 192)  // mov rax, r8
    out = push(out, 72)
    out = push(out, 49)
    out = push(out, 210)  // xor rdx, rdx
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 193)
    out = push(out, 10)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)    // mov rcx, 10
    out = push(out, 72)
    out = push(out, 247)
    out = push(out, 241)  // div rcx
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 194)
    out = push(out, 48)   // add rdx, 48
    out = push(out, 82)   // push rdx
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 194)  // inc r10
    out = push(out, 73)
    out = push(out, 137)
    out = push(out, 192)  // mov r8, rax
    out = push(out, 77)
    out = push(out, 133)
    out = push(out, 192)  // test r8, r8
    var cd = (cvt - len(out) - 2) % 256
    if cd < 0 {
        cd = cd + 256
    }
    out = push(out, 117)
    out = push(out, cd)
    // .write:
    out[jmp_w] = len(out) - jmp_w - 1
    // total len = r10 + r9
    out = push(out, 76)
    out = push(out, 137)
    out = push(out, 209)  // mov rcx, r10
    out = push(out, 76)
    out = push(out, 1)
    out = push(out, 201)  // add rcx, r9
    // store at [buf]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 69)
    out = push(out, 240)  // mov rax, [rbp-16]
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 8)    // mov [rax], rcx
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 120)
    out = push(out, 8)    // lea rdi, [rax+8]
    // if neg, write '-'
    out = push(out, 77)
    out = push(out, 133)
    out = push(out, 201)
    out = push(out, 116)
    let jz_s = len(out)
    out = push(out, 0)
    out = push(out, 198)
    out = push(out, 7)
    out = push(out, 45)   // mov byte [rdi], '-'
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 199)  // inc rdi
    out[jz_s] = len(out) - jz_s - 1
    // pop digits
    let pl = len(out)
    out = push(out, 77)
    out = push(out, 133)
    out = push(out, 210)  // test r10, r10
    out = push(out, 116)
    let jz_e = len(out)
    out = push(out, 0)
    out = push(out, 88)   // pop rax
    out = push(out, 136)
    out = push(out, 7)    // mov [rdi], al
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 199)  // inc rdi
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 202)  // dec r10
    var pd = (pl - len(out) - 2) % 256
    if pd < 0 {
        pd = pd + 256
    }
    out = push(out, 235)
    out = push(out, pd)
    out[jz_e] = len(out) - jz_e - 1
    // return buf
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 69)
    out = push(out, 240)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 236)
    out = push(out, 93)
    out = push(out, 195)
    return out
}

// --- Runtime: _vx_str_to_int stub ---
fn emit_str_to_int_stub() -> [i64] {
    var out: [i64] = []
    out = push(out, 85)    // push rbp
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)   // mov rbp, rsp
    // rcx = [rdi] = len
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 15)
    // rsi = rdi + 8
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 119)
    out = push(out, 8)
    // rax = 0
    out = push(out, 72)
    out = push(out, 49)
    out = push(out, 192)
    // r8 = 0 (neg)
    out = push(out, 77)
    out = push(out, 49)
    out = push(out, 192)
    // test rcx; jz .done
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 201)
    out = push(out, 116)
    let jz_d = len(out)
    out = push(out, 0)
    // check '-'
    out = push(out, 138)
    out = push(out, 22)   // mov dl, [rsi]
    out = push(out, 128)
    out = push(out, 250)
    out = push(out, 45)   // cmp dl, 45
    out = push(out, 117)
    let jne_l = len(out)
    out = push(out, 0)
    // neg flag
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 198)  // inc rsi
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 201)  // dec rcx
    // .parse:
    let pl2 = len(out)
    out[jne_l] = pl2 - jne_l - 1
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 201)
    out = push(out, 116)
    let jz_n = len(out)
    out = push(out, 0)
    out = push(out, 72)
    out = push(out, 107)
    out = push(out, 192)
    out = push(out, 10)   // imul rax, 10
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 182)
    out = push(out, 22)   // movzx rdx, byte [rsi]
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 234)
    out = push(out, 48)   // sub rdx, 48
    out = push(out, 72)
    out = push(out, 1)
    out = push(out, 208)  // add rax, rdx
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 198)  // inc rsi
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 201)  // dec rcx
    var ld = (pl2 - len(out) - 2) % 256
    if ld < 0 {
        ld = ld + 256
    }
    out = push(out, 235)
    out = push(out, ld)
    // .negate:
    out[jz_n] = len(out) - jz_n - 1
    out = push(out, 77)
    out = push(out, 133)
    out = push(out, 192)
    out = push(out, 116)
    let jz_d2 = len(out)
    out = push(out, 0)
    out = push(out, 72)
    out = push(out, 247)
    out = push(out, 216)  // neg rax
    let done_pos = len(out)
    out[jz_d] = done_pos - jz_d - 1
    out[jz_d2] = done_pos - jz_d2 - 1
    out = push(out, 93)
    out = push(out, 195)
    return out
}

// --- Runtime: _vx_str_char_at stub ---
fn emit_str_char_at_stub() -> [i64] {
    var out: [i64] = []
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 32)
    // save [rbp-8]=str, [rbp-16]=idx
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 117)
    out = push(out, 240)
    // load byte: add rsi, 8; movzx rax, byte [rdi+rsi]; save to [rbp-24]
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 198)
    out = push(out, 8)    // add rsi, 8
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 182)
    out = push(out, 4)
    out = push(out, 55)   // movzx rax, byte [rdi+rsi]  (48 0F B6 04 37)
    // save byte in [rbp-24]
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 232)  // mov [rbp-24], rax
    // alloc 9 bytes
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 9)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = emit_inline_mmap(out)
    // store len=1
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 0)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // load saved byte and store at [rax+8]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 77)
    out = push(out, 232)  // mov rcx, [rbp-24]
    out = push(out, 136)
    out = push(out, 72)
    out = push(out, 8)    // mov [rax+8], cl
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 236)
    out = push(out, 93)
    out = push(out, 195)
    return out
}

// --- Runtime: _vx_str_substr stub ---
fn emit_str_substr_stub() -> [i64] {
    var out: [i64] = []
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 48)
    // [rbp-8]=str, [rbp-16]=start, [rbp-24]=sublen
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 117)
    out = push(out, 240)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 85)
    out = push(out, 232)
    // alloc rdx + 8
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 122)
    out = push(out, 8)    // lea rdi, [rdx+8]
    out = emit_inline_mmap(out)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 224)  // save [rbp-32]
    // store sublen
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 77)
    out = push(out, 232)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 8)    // mov [rax], rcx
    // copy
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 120)
    out = push(out, 8)    // lea rdi, [rax+8]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 117)
    out = push(out, 248)  // mov rsi, [rbp-8]
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 198)
    out = push(out, 8)    // add rsi, 8
    out = push(out, 72)
    out = push(out, 3)
    out = push(out, 117)
    out = push(out, 240)  // add rsi, [rbp-16]
    out = push(out, 243)
    out = push(out, 164)  // rep movsb
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 69)
    out = push(out, 224)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 236)
    out = push(out, 93)
    out = push(out, 195)
    return out
}

// --- Runtime: _vx_str_bytes stub ---
fn emit_str_bytes_stub() -> [i64] {
    var out: [i64] = []
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 32)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)  // [rbp-8]=str
    // len
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 15)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 77)
    out = push(out, 240)  // [rbp-16]=len
    // alloc (len+1)*8
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 193)
    out = push(out, 1)
    out = push(out, 72)
    out = push(out, 193)
    out = push(out, 225)
    out = push(out, 3)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 207)
    out = emit_inline_mmap(out)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 232)  // [rbp-24]=arr
    // store len
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 77)
    out = push(out, 240)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 8)
    // rsi=str+8, rdi=arr+8
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 117)
    out = push(out, 248)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 198)
    out = push(out, 8)
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 120)
    out = push(out, 8)
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 201)
    out = push(out, 116)
    let jz_d3 = len(out)
    out = push(out, 0)
    let lp3 = len(out)
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 182)
    out = push(out, 6)    // movzx rax, byte [rsi]
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 7)    // mov [rdi], rax
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 199)
    out = push(out, 8)
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 198)
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 201)
    var ld3 = (lp3 - len(out) - 2) % 256
    if ld3 < 0 {
        ld3 = ld3 + 256
    }
    out = push(out, 117)
    out = push(out, ld3)
    out[jz_d3] = len(out) - jz_d3 - 1
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 69)
    out = push(out, 232)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 236)
    out = push(out, 93)
    out = push(out, 195)
    return out
}

// --- Runtime: _vx_str_from_bytes stub ---
fn emit_str_from_bytes_stub() -> [i64] {
    var out: [i64] = []
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 32)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)  // [rbp-8]=arr
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 15)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 77)
    out = push(out, 240)  // [rbp-16]=len
    // alloc len + 8
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 121)
    out = push(out, 8)
    out = emit_inline_mmap(out)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 232)  // [rbp-24]=result
    // store len
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 77)
    out = push(out, 240)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 8)
    // rsi=arr+8, rdi=result+8
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 117)
    out = push(out, 248)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 198)
    out = push(out, 8)
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 120)
    out = push(out, 8)
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 201)
    out = push(out, 116)
    let jz_d4 = len(out)
    out = push(out, 0)
    let lp4 = len(out)
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 6)    // mov rax, [rsi]
    out = push(out, 136)
    out = push(out, 7)    // mov [rdi], al
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 198)
    out = push(out, 8)
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 199)
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 201)
    var ld4 = (lp4 - len(out) - 2) % 256
    if ld4 < 0 {
        ld4 = ld4 + 256
    }
    out = push(out, 117)
    out = push(out, ld4)
    out[jz_d4] = len(out) - jz_d4 - 1
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 69)
    out = push(out, 232)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 236)
    out = push(out, 93)
    out = push(out, 195)
    return out
}

// --- Runtime: _vx_exp stub ---
// exp(x) using x87: compute 2^(x * log2(e)) via f2xm1
// rdi = float bits of x, returns float bits in rax
fn emit_exp_stub() -> [i64] {
    var out: [i64] = []
    // push rbp; mov rbp, rsp; sub rsp, 16
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 16)
    // mov [rbp-8], rdi (store x bits)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)
    // fld qword [rbp-8] — load x
    out = push(out, 221)
    out = push(out, 69)
    out = push(out, 248)
    // fldl2e — load log2(e)
    out = push(out, 217)
    out = push(out, 234)
    // fmulp — st(1) = x * log2(e), pop
    out = push(out, 222)
    out = push(out, 201)
    // Now st(0) = x * log2(e) = y
    // Split into integer and fraction: fld st(0), frndint, fsub to get fraction
    // fld st(0): D9 C0
    out = push(out, 217)
    out = push(out, 192)
    // frndint: D9 FC
    out = push(out, 217)
    out = push(out, 252)
    // Now st(0)=round(y), st(1)=y
    // fsubr st(1), st(0) would be tricky; let's use fsub
    // fxch st(1): D9 C9
    out = push(out, 217)
    out = push(out, 201)
    // Now st(0)=y, st(1)=round(y)
    // fsub st(0), st(1): D8 E1
    out = push(out, 216)
    out = push(out, 225)
    // Now st(0)=frac=y-round(y), st(1)=round(y)
    // f2xm1: D9 F0 — st(0) = 2^frac - 1
    out = push(out, 217)
    out = push(out, 240)
    // fld1: D9 E8
    out = push(out, 217)
    out = push(out, 232)
    // faddp: DE C1 — st(0) = 2^frac
    out = push(out, 222)
    out = push(out, 193)
    // fscale: D9 FD — st(0) = 2^frac * 2^round(y) = 2^y = e^x
    out = push(out, 217)
    out = push(out, 253)
    // fstp st(1): DD D9 — pop the round(y) copy
    out = push(out, 221)
    out = push(out, 217)
    // fstp qword [rbp-8]: DD 5D F8
    out = push(out, 221)
    out = push(out, 93)
    out = push(out, 248)
    // mov rax, [rbp-8]: 48 8B 45 F8
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 69)
    out = push(out, 248)
    // leave; ret
    out = push(out, 201)
    out = push(out, 195)
    return out
}

// --- Runtime: _vx_log stub ---
// log(x) using x87: ln(x) = log2(x) / log2(e) = log2(x) * ln(2)
// rdi = float bits of x, returns float bits in rax
fn emit_log_stub() -> [i64] {
    var out: [i64] = []
    // push rbp; mov rbp, rsp; sub rsp, 16
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 16)
    // mov [rbp-8], rdi
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)
    // fldln2: D9 ED — load ln(2)
    out = push(out, 217)
    out = push(out, 237)
    // fld qword [rbp-8]: DD 45 F8 — load x
    out = push(out, 221)
    out = push(out, 69)
    out = push(out, 248)
    // fyl2x: D9 F1 — st(0) = ln(2) * log2(x) = ln(x)
    out = push(out, 217)
    out = push(out, 241)
    // fstp qword [rbp-8]: DD 5D F8
    out = push(out, 221)
    out = push(out, 93)
    out = push(out, 248)
    // mov rax, [rbp-8]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 69)
    out = push(out, 248)
    // leave; ret
    out = push(out, 201)
    out = push(out, 195)
    return out
}

// --- Runtime: _vx_pow stub ---
// pow(base, exp) = 2^(exp * log2(base))
// rdi = base float bits, rsi = exp float bits, returns float bits in rax
fn emit_pow_stub() -> [i64] {
    var out: [i64] = []
    // push rbp; mov rbp, rsp; sub rsp, 16
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 16)
    // mov [rbp-8], rdi (base)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)
    // mov [rbp-16], rsi (exp)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 117)
    out = push(out, 240)
    // fld qword [rbp-16]: DD 45 F0 — load exp
    out = push(out, 221)
    out = push(out, 69)
    out = push(out, 240)
    // fld qword [rbp-8]: DD 45 F8 — load base
    out = push(out, 221)
    out = push(out, 69)
    out = push(out, 248)
    // fyl2x: D9 F1 — st(0) = exp * log2(base)
    out = push(out, 217)
    out = push(out, 241)
    // Now st(0) = y = exp * log2(base)
    // Split into int + frac
    // fld st(0): D9 C0
    out = push(out, 217)
    out = push(out, 192)
    // frndint: D9 FC
    out = push(out, 217)
    out = push(out, 252)
    // fxch st(1): D9 C9
    out = push(out, 217)
    out = push(out, 201)
    // fsub st(0), st(1): D8 E1
    out = push(out, 216)
    out = push(out, 225)
    // f2xm1: D9 F0
    out = push(out, 217)
    out = push(out, 240)
    // fld1: D9 E8
    out = push(out, 217)
    out = push(out, 232)
    // faddp: DE C1
    out = push(out, 222)
    out = push(out, 193)
    // fscale: D9 FD
    out = push(out, 217)
    out = push(out, 253)
    // fstp st(1): DD D9
    out = push(out, 221)
    out = push(out, 217)
    // fstp qword [rbp-8]: DD 5D F8
    out = push(out, 221)
    out = push(out, 93)
    out = push(out, 248)
    // mov rax, [rbp-8]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 69)
    out = push(out, 248)
    // leave; ret
    out = push(out, 201)
    out = push(out, 195)
    return out
}

// --- Runtime: _vx_str_find stub ---
// rdi = haystack (string ptr), rsi = needle (string ptr)
// Returns index in rax, or -1 if not found
// String format: [u64 len][bytes...]
fn emit_str_find_stub() -> [i64] {
    var out: [i64] = []
    // push rbp; mov rbp, rsp; sub rsp, 48
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 48)
    // [rbp-8] = haystack, [rbp-16] = needle
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 117)
    out = push(out, 240)
    // r12 = haystack len = [rdi]
    out = push(out, 76)
    out = push(out, 139)
    out = push(out, 39)
    // r13 = needle len = [rsi]
    out = push(out, 76)
    out = push(out, 139)
    out = push(out, 46)
    // r14 = 0 (outer index i)
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 198)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // if needle len == 0, return 0
    out = push(out, 77)
    out = push(out, 133)
    out = push(out, 237)
    out = push(out, 117)
    out = push(out, 8)
    // return 0
    out = push(out, 72)
    out = push(out, 49)
    out = push(out, 192)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 236)
    out = push(out, 93)
    out = push(out, 195)
    // .outer_loop:
    let outer_loop = len(out)
    // if i + needle_len > haystack_len, not found
    // lea rcx, [r14 + r13]: 4B 8D 0C 2E
    out = push(out, 75)
    out = push(out, 141)
    out = push(out, 12)
    out = push(out, 46)
    // cmp rcx, r12: 4C 39 E1
    out = push(out, 76)
    out = push(out, 57)
    out = push(out, 225)
    // ja .not_found
    out = push(out, 119)
    let ja_nf_pos = len(out)
    out = push(out, 0)  // placeholder
    // r15 = 0 (inner index j)
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // .inner_loop:
    let inner_loop = len(out)
    // cmp r15, r13 (j >= needle_len?)
    out = push(out, 77)
    out = push(out, 57)
    out = push(out, 239)
    // jae .found
    out = push(out, 115)
    let jae_found_pos = len(out)
    out = push(out, 0)  // placeholder
    // load haystack[i+j]: movzx eax, byte [rbp-8]+8+r14+r15
    // mov rdi, [rbp-8]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 125)
    out = push(out, 248)
    // lea rax, [rdi+8+r14]: add rdi,8; add rdi,r14
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 199)
    out = push(out, 8)
    out = push(out, 76)
    out = push(out, 1)
    out = push(out, 247)
    // add rdi, r15
    out = push(out, 76)
    out = push(out, 1)
    out = push(out, 255)
    // movzx eax, byte [rdi]: 0F B6 07
    out = push(out, 15)
    out = push(out, 182)
    out = push(out, 7)
    // load needle[j]: mov rsi, [rbp-16]; lea rsi, [rsi+8+r15]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 117)
    out = push(out, 240)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 198)
    out = push(out, 8)
    out = push(out, 76)
    out = push(out, 1)
    out = push(out, 254)
    // movzx ecx, byte [rsi]: 0F B6 0E
    out = push(out, 15)
    out = push(out, 182)
    out = push(out, 14)
    // cmp al, cl
    out = push(out, 56)
    out = push(out, 200)
    // jne .next
    out = push(out, 117)
    let jne_next_pos = len(out)
    out = push(out, 0)  // placeholder
    // inc r15
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 199)
    // jmp .inner_loop
    let jmp_inner = len(out)
    let inner_delta = inner_loop - jmp_inner - 2
    out = push(out, 235)
    var inner_off = inner_delta % 256
    if inner_off < 0 { inner_off = inner_off + 256 }
    out = push(out, inner_off)
    // .found:
    let found_pos = len(out)
    // patch jae_found
    // return r14 (the index)
    out = push(out, 76)
    out = push(out, 137)
    out = push(out, 240)  // mov rax, r14
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 236)
    out = push(out, 93)
    out = push(out, 195)  // leave; ret
    // .next:
    let next_pos = len(out)
    // inc r14
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 198)
    // jmp .outer_loop
    let jmp_outer = len(out)
    let outer_delta = outer_loop - jmp_outer - 2
    out = push(out, 235)
    var outer_off = outer_delta % 256
    if outer_off < 0 { outer_off = outer_off + 256 }
    out = push(out, outer_off)
    // .not_found:
    let not_found_pos = len(out)
    // mov rax, -1
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 255)
    out = push(out, 255)
    out = push(out, 255)
    out = push(out, 255)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 236)
    out = push(out, 93)
    out = push(out, 195)  // leave; ret

    // Patch jump targets
    // ja_nf_pos -> not_found_pos
    var p1 = not_found_pos - ja_nf_pos - 1
    if p1 < 0 { p1 = p1 + 256 }
    out[ja_nf_pos] = p1
    // jae_found_pos -> found_pos
    var p2 = found_pos - jae_found_pos - 1
    if p2 < 0 { p2 = p2 + 256 }
    out[jae_found_pos] = p2
    // jne_next_pos -> next_pos
    var p3 = next_pos - jne_next_pos - 1
    if p3 < 0 { p3 = p3 + 256 }
    out[jne_next_pos] = p3
    return out
}

// --- Runtime: _vx_trim stub ---
// rdi = string ptr (format: [u64 len][bytes...])
// Returns new trimmed string ptr in rax
fn emit_trim_stub() -> [i64] {
    var out: [i64] = []
    // push rbp; mov rbp, rsp; sub rsp, 48
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 48)
    // [rbp-8] = input string
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)
    // r12 = len = [rdi]
    out = push(out, 76)
    out = push(out, 139)
    out = push(out, 39)
    // r13 = start = 0
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 197)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // r14 = end = len
    out = push(out, 77)
    out = push(out, 137)
    out = push(out, 230)

    // .skip_leading:
    let skip_lead = len(out)
    // cmp r13, r12: if start >= len, done
    out = push(out, 77)
    out = push(out, 57)
    out = push(out, 229)
    out = push(out, 115)  // jae .lead_done
    let jae_ld_pos = len(out)
    out = push(out, 0)
    // load byte: mov rdi, [rbp-8]; movzx eax, byte [rdi+8+r13]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 125)
    out = push(out, 248)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 199)
    out = push(out, 8)
    out = push(out, 76)
    out = push(out, 1)
    out = push(out, 239)
    out = push(out, 15)
    out = push(out, 182)
    out = push(out, 7)
    // cmp al, 32 (space)
    out = push(out, 60)
    out = push(out, 32)
    out = push(out, 116)
    out = push(out, 12)  // je .is_ws (skip 12 bytes to inc)
    // cmp al, 9 (tab)
    out = push(out, 60)
    out = push(out, 9)
    out = push(out, 116)
    out = push(out, 8)
    // cmp al, 10 (newline)
    out = push(out, 60)
    out = push(out, 10)
    out = push(out, 116)
    out = push(out, 4)
    // cmp al, 13 (cr)
    out = push(out, 60)
    out = push(out, 13)
    out = push(out, 117)  // jne .lead_done
    let jne_ld_pos = len(out)
    out = push(out, 0)
    // .is_ws: inc r13; jmp .skip_leading
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 197)
    let jmp_sl = len(out)
    let sl_delta = skip_lead - jmp_sl - 2
    out = push(out, 235)
    var sl_off = sl_delta % 256
    if sl_off < 0 { sl_off = sl_off + 256 }
    out = push(out, sl_off)

    // .lead_done:
    let lead_done = len(out)
    // Patch jae and jne
    var p_ld1 = lead_done - jae_ld_pos - 1
    if p_ld1 < 0 { p_ld1 = p_ld1 + 256 }
    out[jae_ld_pos] = p_ld1
    var p_ld2 = lead_done - jne_ld_pos - 1
    if p_ld2 < 0 { p_ld2 = p_ld2 + 256 }
    out[jne_ld_pos] = p_ld2

    // .skip_trailing:
    let skip_trail = len(out)
    // cmp r14, r13: if end <= start, done
    out = push(out, 77)
    out = push(out, 57)
    out = push(out, 238)
    out = push(out, 118)  // jbe .trail_done
    let jbe_td_pos = len(out)
    out = push(out, 0)
    // load byte at end-1: mov rdi, [rbp-8]; movzx eax, byte [rdi+8+r14-1]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 125)
    out = push(out, 248)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 199)
    out = push(out, 8)
    out = push(out, 76)
    out = push(out, 1)
    out = push(out, 247)
    // movzx eax, byte [rdi-1]: 0F B6 47 FF
    out = push(out, 15)
    out = push(out, 182)
    out = push(out, 71)
    out = push(out, 255)
    // check whitespace
    out = push(out, 60)
    out = push(out, 32)
    out = push(out, 116)
    out = push(out, 12)
    out = push(out, 60)
    out = push(out, 9)
    out = push(out, 116)
    out = push(out, 8)
    out = push(out, 60)
    out = push(out, 10)
    out = push(out, 116)
    out = push(out, 4)
    out = push(out, 60)
    out = push(out, 13)
    out = push(out, 117)  // jne .trail_done
    let jne_td_pos = len(out)
    out = push(out, 0)
    // dec r14; jmp .skip_trailing
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 206)
    let jmp_st = len(out)
    let st_delta = skip_trail - jmp_st - 2
    out = push(out, 235)
    var st_off = st_delta % 256
    if st_off < 0 { st_off = st_off + 256 }
    out = push(out, st_off)

    // .trail_done:
    let trail_done = len(out)
    var p_td1 = trail_done - jbe_td_pos - 1
    if p_td1 < 0 { p_td1 = p_td1 + 256 }
    out[jbe_td_pos] = p_td1
    var p_td2 = trail_done - jne_td_pos - 1
    if p_td2 < 0 { p_td2 = p_td2 + 256 }
    out[jne_td_pos] = p_td2

    // new_len = r14 - r13 (end - start)
    // mov rcx, r14; sub rcx, r13
    out = push(out, 76)
    out = push(out, 137)
    out = push(out, 241)
    out = push(out, 76)
    out = push(out, 41)
    out = push(out, 233)
    // [rbp-16] = new_len
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 77)
    out = push(out, 240)
    // alloc new_len + 8 via mmap: mov rdi, rcx; add rdi, 8
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 207)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 199)
    out = push(out, 8)
    out = emit_inline_mmap(out)
    // [rbp-24] = result ptr
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 232)
    // store len: mov rcx, [rbp-16]; mov [rax], rcx
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 77)
    out = push(out, 240)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 8)
    // copy bytes: src = [rbp-8]+8+r13, dst = rax+8, len = rcx
    // rdi = rax+8
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 120)
    out = push(out, 8)
    // rsi = [rbp-8]+8+r13
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 117)
    out = push(out, 248)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 198)
    out = push(out, 8)
    out = push(out, 76)
    out = push(out, 1)
    out = push(out, 238)
    // rcx = new_len (already in rcx from [rbp-16])
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 77)
    out = push(out, 240)
    // rep movsb: F3 A4
    out = push(out, 243)
    out = push(out, 164)
    // return result ptr
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 69)
    out = push(out, 232)
    // leave; ret
    out = push(out, 201)
    out = push(out, 195)
    return out
}

// --- Runtime: _vx_read_file stub ---
// rdi = path string ptr ([u64 len][bytes...])
// Returns string ptr in rax, or empty string on error
fn emit_read_file_stub() -> [i64] {
    var out: [i64] = []
    // push rbp; mov rbp, rsp; sub rsp, 64
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 64)
    // [rbp-8] = path string
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)

    // Need null-terminated path: alloc len+1, copy, null-terminate
    // r12 = path len = [rdi]
    out = push(out, 76)
    out = push(out, 139)
    out = push(out, 39)
    // alloc r12+1: mov rdi, r12; add rdi, 1
    out = push(out, 76)
    out = push(out, 137)
    out = push(out, 231)
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 199)
    out = emit_inline_mmap(out)
    // [rbp-16] = path buf
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 240)
    // copy path bytes: rdi=buf, rsi=path+8, rcx=r12
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 199)  // mov rdi, rax
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 117)
    out = push(out, 248)  // mov rsi, [rbp-8]
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 198)
    out = push(out, 8)    // add rsi, 8
    out = push(out, 76)
    out = push(out, 137)
    out = push(out, 225)  // mov rcx, r12
    out = push(out, 243)
    out = push(out, 164)  // rep movsb
    // null-terminate: mov byte [rdi], 0
    out = push(out, 198)
    out = push(out, 7)
    out = push(out, 0)

    // open(path_buf, O_RDONLY=0): syscall 2
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 125)
    out = push(out, 240)  // mov rdi, [rbp-16]
    out = push(out, 72)
    out = push(out, 49)
    out = push(out, 246)  // xor rsi, rsi (O_RDONLY=0)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 2)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)  // mov rax, 2
    out = push(out, 15)
    out = push(out, 5)   // syscall
    // if fd < 0, return empty string
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 192)  // test rax, rax
    out = push(out, 121)  // jns .fd_ok
    let jns_ok_pos = len(out)
    out = push(out, 0)
    // return empty string: alloc 8 bytes, store 0 length
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 8)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = emit_inline_mmap(out)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)  // mov qword [rax], 0
    out = push(out, 201)
    out = push(out, 195)  // leave; ret

    // .fd_ok:
    let fd_ok = len(out)
    var p_ok = fd_ok - jns_ok_pos - 1
    if p_ok < 0 { p_ok = p_ok + 256 }
    out[jns_ok_pos] = p_ok

    // [rbp-24] = fd
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 232)
    // alloc read buffer (1MB): mov rdi, 1048576
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 16)
    out = push(out, 0)  // 0x100000 = 1048576
    out = emit_inline_mmap(out)
    // [rbp-32] = read buffer
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 224)

    // read(fd, buf, 1048576): syscall 0
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 125)
    out = push(out, 232)  // mov rdi, [rbp-24] (fd)
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 117)
    out = push(out, 224)  // mov rsi, [rbp-32] (buf)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 194)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 16)
    out = push(out, 0)  // mov rdx, 1048576
    out = push(out, 72)
    out = push(out, 49)
    out = push(out, 192)  // xor rax, rax (SYS_READ=0)
    out = push(out, 15)
    out = push(out, 5)   // syscall
    // [rbp-40] = bytes_read
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 216)

    // close(fd): syscall 3
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 125)
    out = push(out, 232)  // mov rdi, [rbp-24]
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 3)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)  // mov rax, 3
    out = push(out, 15)
    out = push(out, 5)   // syscall

    // Build string: alloc bytes_read + 8, store len, copy data
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 77)
    out = push(out, 216)  // mov rcx, [rbp-40] (bytes_read)
    // if bytes_read <= 0, return empty
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 201)
    out = push(out, 127)  // jg .has_data
    let jg_hd_pos = len(out)
    out = push(out, 0)
    // empty string
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 8)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = emit_inline_mmap(out)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 201)
    out = push(out, 195)

    // .has_data:
    let has_data = len(out)
    var p_hd = has_data - jg_hd_pos - 1
    if p_hd < 0 { p_hd = p_hd + 256 }
    out[jg_hd_pos] = p_hd

    // alloc bytes_read + 8
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 125)
    out = push(out, 216)  // mov rdi, [rbp-40]
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 199)
    out = push(out, 8)    // add rdi, 8
    out = emit_inline_mmap(out)
    // [rbp-48] = result
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 208)
    // store length
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 77)
    out = push(out, 216)  // mov rcx, [rbp-40]
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 8)    // mov [rax], rcx
    // copy: rdi=result+8, rsi=read_buf, rcx=bytes_read
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 120)
    out = push(out, 8)    // lea rdi, [rax+8]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 117)
    out = push(out, 224)  // mov rsi, [rbp-32]
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 77)
    out = push(out, 216)  // mov rcx, [rbp-40]
    out = push(out, 243)
    out = push(out, 164)  // rep movsb
    // return result
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 69)
    out = push(out, 208)  // mov rax, [rbp-48]
    out = push(out, 201)
    out = push(out, 195)  // leave; ret
    return out
}

// --- Runtime: _vx_write_file stub ---
// rdi = path string ptr, rsi = content string ptr
fn emit_write_file_stub() -> [i64] {
    var out: [i64] = []
    // push rbp; mov rbp, rsp; sub rsp, 48
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 48)
    // [rbp-8] = path, [rbp-16] = content
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 117)
    out = push(out, 240)

    // Null-terminate path
    // r12 = path len
    out = push(out, 76)
    out = push(out, 139)
    out = push(out, 39)  // mov r12, [rdi]
    out = push(out, 76)
    out = push(out, 137)
    out = push(out, 231)  // mov rdi, r12
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 199)  // inc rdi
    out = emit_inline_mmap(out)
    // [rbp-24] = path_buf
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 232)
    // copy path
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 199)  // mov rdi, rax
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 117)
    out = push(out, 248)  // mov rsi, [rbp-8]
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 198)
    out = push(out, 8)    // add rsi, 8
    out = push(out, 76)
    out = push(out, 137)
    out = push(out, 225)  // mov rcx, r12
    out = push(out, 243)
    out = push(out, 164)  // rep movsb
    out = push(out, 198)
    out = push(out, 7)
    out = push(out, 0)    // mov byte [rdi], 0

    // open(path_buf, O_WRONLY|O_CREAT|O_TRUNC = 1+64+512 = 577, 0644 = 420)
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 125)
    out = push(out, 232)  // mov rdi, [rbp-24]
    // mov rsi, 577 (0x241)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 198)
    out = push(out, 65)
    out = push(out, 2)
    out = push(out, 0)
    out = push(out, 0)
    // mov rdx, 420 (0x1A4)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 194)
    out = push(out, 164)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    // mov rax, 2 (SYS_OPEN)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 2)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 15)
    out = push(out, 5)   // syscall

    // [rbp-32] = fd
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 224)

    // write(fd, content+8, [content])
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 199)  // mov rdi, rax (fd)
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 69)
    out = push(out, 240)  // mov rax, [rbp-16] (content)
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 16)   // mov rdx, [rax] (len)
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 112)
    out = push(out, 8)    // lea rsi, [rax+8] (data)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)  // mov rax, 1 (SYS_WRITE)
    out = push(out, 15)
    out = push(out, 5)   // syscall

    // close(fd)
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 125)
    out = push(out, 224)  // mov rdi, [rbp-32]
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 3)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)  // mov rax, 3
    out = push(out, 15)
    out = push(out, 5)   // syscall

    // return 0
    out = push(out, 72)
    out = push(out, 49)
    out = push(out, 192)
    out = push(out, 201)
    out = push(out, 195)  // leave; ret
    return out
}

// --- Runtime: _vx_file_exists stub ---
// rdi = path string ptr
// Returns 1 if exists, 0 otherwise
// Uses access() syscall (21) with F_OK (0)
fn emit_file_exists_stub() -> [i64] {
    var out: [i64] = []
    // push rbp; mov rbp, rsp; sub rsp, 32
    out = push(out, 85)
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 229)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 32)
    // [rbp-8] = path string
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 125)
    out = push(out, 248)

    // Null-terminate path: alloc len+1
    out = push(out, 76)
    out = push(out, 139)
    out = push(out, 39)  // mov r12, [rdi] (len)
    out = push(out, 76)
    out = push(out, 137)
    out = push(out, 231)  // mov rdi, r12
    out = push(out, 72)
    out = push(out, 255)
    out = push(out, 199)  // inc rdi
    out = emit_inline_mmap(out)
    // [rbp-16] = path_buf
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 69)
    out = push(out, 240)
    // copy
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 199)
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 117)
    out = push(out, 248)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 198)
    out = push(out, 8)
    out = push(out, 76)
    out = push(out, 137)
    out = push(out, 225)
    out = push(out, 243)
    out = push(out, 164)
    out = push(out, 198)
    out = push(out, 7)
    out = push(out, 0)

    // access(path_buf, F_OK=0): syscall 21
    out = push(out, 72)
    out = push(out, 139)
    out = push(out, 125)
    out = push(out, 240)  // mov rdi, [rbp-16]
    out = push(out, 72)
    out = push(out, 49)
    out = push(out, 246)  // xor rsi, rsi (F_OK=0)
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 21)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)  // mov rax, 21
    out = push(out, 15)
    out = push(out, 5)   // syscall

    // if rax == 0, return 1; else return 0
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 192)  // test rax, rax
    // sete al: 0F 94 C0
    out = push(out, 15)
    out = push(out, 148)
    out = push(out, 192)
    // movzx rax, al: 48 0F B6 C0
    out = push(out, 72)
    out = push(out, 15)
    out = push(out, 182)
    out = push(out, 192)
    out = push(out, 201)
    out = push(out, 195)  // leave; ret
    return out
}

// --- Runtime: _vx_print_int_no_nl stub ---
// Like _vx_print_int but without trailing newline
// rdi = integer value
fn emit_print_int_no_nl_stub() -> [i64] {
    var out: [i64] = []
    // sub rsp, 32 (buffer space)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 236)
    out = push(out, 32)
    // Save rdi
    out = push(out, 72)
    out = push(out, 137)
    out = push(out, 248)  // mov rax, rdi

    // Handle negative: save sign in r14
    // push r14
    out = push(out, 65)
    out = push(out, 86)
    // xor r14, r14
    out = push(out, 77)
    out = push(out, 49)
    out = push(out, 246)
    // test rax, rax
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 192)
    // jns .positive
    out = push(out, 121)
    out = push(out, 5)
    // neg rax; mov r14, 1
    out = push(out, 72)
    out = push(out, 247)
    out = push(out, 216)
    // mov r14d, 1: 41 BE 01 00 00 00
    out = push(out, 65)
    out = push(out, 190)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)

    // .positive:
    // Use buffer at [rsp+8..rsp+31] for digits
    // r12 = pointer to end of buffer
    // push r12
    out = push(out, 65)
    out = push(out, 84)
    // lea r12, [rsp+31]: 4C 8D 64 24 1F  -- wait, we pushed r14 and r12, so rsp shifted
    // Actually let's use rsp+39 (32 + 8 for r14 push) -- this is getting complex
    // Simpler: use stack buffer directly
    // r12 points to end of digit area (rsp + 23 after pushes)
    out = push(out, 76)
    out = push(out, 141)
    out = push(out, 100)
    out = push(out, 36)
    out = push(out, 38)   // lea r12, [rsp+38]

    // Handle 0 case
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 192)
    out = push(out, 117)
    out = push(out, 6)  // jnz .nonzero
    // mov byte [r12], '0'
    out = push(out, 65)
    out = push(out, 198)
    out = push(out, 4)
    out = push(out, 36)
    out = push(out, 48)
    // jmp .print
    out = push(out, 235)
    let jmp_print_pos = len(out)
    out = push(out, 0)

    // .nonzero: convert digits
    let nonzero = len(out)
    // mov r8, 10: 49 C7 C0 0A 00 00 00
    out = push(out, 73)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 10)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)

    // .digit_loop:
    let digit_loop = len(out)
    // xor rdx, rdx; div r8
    out = push(out, 72)
    out = push(out, 49)
    out = push(out, 210)
    out = push(out, 73)
    out = push(out, 247)
    out = push(out, 240)
    // add dl, '0'
    out = push(out, 128)
    out = push(out, 194)
    out = push(out, 48)
    // mov [r12], dl
    out = push(out, 65)
    out = push(out, 136)
    out = push(out, 20)
    out = push(out, 36)
    // dec r12
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 204)
    // test rax, rax; jnz .digit_loop
    out = push(out, 72)
    out = push(out, 133)
    out = push(out, 192)
    let jnz_dl_pos = len(out)
    let dl_delta = digit_loop - jnz_dl_pos - 2
    out = push(out, 117)
    var dl_off = dl_delta % 256
    if dl_off < 0 { dl_off = dl_off + 256 }
    out = push(out, dl_off)

    // If negative, write '-'
    out = push(out, 77)
    out = push(out, 133)
    out = push(out, 246)
    out = push(out, 121)
    out = push(out, 8)  // jns .print
    out = push(out, 65)
    out = push(out, 198)
    out = push(out, 4)
    out = push(out, 36)
    out = push(out, 45)  // mov byte [r12], '-'
    out = push(out, 73)
    out = push(out, 255)
    out = push(out, 204)  // dec r12

    // .print:
    let print_pos = len(out)
    // patch jmp_print
    var p_pp = print_pos - jmp_print_pos - 1
    if p_pp < 0 { p_pp = p_pp + 256 }
    out[jmp_print_pos] = p_pp

    // write(1, r12+1, end-r12)
    // lea rsi, [r12+1]
    out = push(out, 73)
    out = push(out, 141)
    out = push(out, 116)
    out = push(out, 36)
    out = push(out, 1)
    // lea rdx, [rsp+39] -- end of buffer
    // Actually compute: rsp+39 - rsi = len
    out = push(out, 72)
    out = push(out, 141)
    out = push(out, 84)
    out = push(out, 36)
    out = push(out, 39)  // lea rdx, [rsp+39]
    out = push(out, 72)
    out = push(out, 41)
    out = push(out, 242)  // sub rdx, rsi
    // mov rax, 1
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 192)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // mov rdi, 1
    out = push(out, 72)
    out = push(out, 199)
    out = push(out, 199)
    out = push(out, 1)
    out = push(out, 0)
    out = push(out, 0)
    out = push(out, 0)
    // syscall
    out = push(out, 15)
    out = push(out, 5)

    // pop r12; pop r14; add rsp, 32; ret
    out = push(out, 65)
    out = push(out, 92)
    out = push(out, 65)
    out = push(out, 94)
    out = push(out, 72)
    out = push(out, 131)
    out = push(out, 196)
    out = push(out, 32)
    out = push(out, 195)
    return out
}

// --- Program compiler ---
fn compile_program(fns: [String]) -> [i64] {
    var code: [i64] = []

    // Reset all state
    _label_counter = 0
    _fixup_positions = []
    _fixup_labels = []
    _label_names = []
    _label_addrs = []
    _func_names = []
    _func_addrs = []
    _string_data = []
    _string_offsets = []
    _string_lengths = []
    _loop_break_labels = []
    _loop_continue_labels = []
    _global_names = []
    _global_types = []
    _compiling_globals = 0

    // First: emit _start that calls main then does exit(rax)
    // We'll register it and emit it first, then compile user functions

    // _start stub: call _vx_init_globals, call main, mov rdi rax, mov rax 60, syscall
    register_function("_start", 0)
    // call _vx_init_globals
    code = emit_u8(code, 232)
    add_fixup(len(code), "_vx_init_globals")
    code = emit_u32_le(code, 0)
    // call main (will be fixed up)
    code = emit_u8(code, 232)
    add_fixup(len(code), "main")
    code = emit_u32_le(code, 0)
    // mov rdi, rax (exit code = return value of main)
    code = emit_mov_reg_reg(code, REG_RDI(), REG_RAX())
    // mov rax, 60 (SYS_EXIT)
    code = emit_mov_reg_imm64(code, REG_RAX(), 60)
    // syscall
    code = emit_syscall_inst(code)

    // Now emit _vx_print_int runtime stub
    let print_int_code = emit_print_int_stub()
    register_function("_vx_print_int", len(code))
    var pi = 0
    while pi < len(print_int_code) {
        code = push(code, print_int_code[pi])
        pi = pi + 1
    }

    // Emit _vx_print_str runtime stub
    let print_str_code = emit_print_str_stub()
    register_function("_vx_print_str", len(code))
    var psi = 0
    while psi < len(print_str_code) {
        code = push(code, print_str_code[psi])
        psi = psi + 1
    }

    // Emit _vx_alloc runtime stub
    let alloc_code = emit_alloc_stub()
    register_function("_vx_alloc", len(code))
    var ali = 0
    while ali < len(alloc_code) {
        code = push(code, alloc_code[ali])
        ali = ali + 1
    }

    // Emit _vx_arr_push runtime stub
    let arr_push_code = emit_arr_push_stub()
    register_function("_vx_arr_push", len(code))
    var api = 0
    while api < len(arr_push_code) {
        code = push(code, arr_push_code[api])
        api = api + 1
    }

    // Emit _vx_print_float runtime stub
    let print_float_code = emit_print_float_stub()
    register_function("_vx_print_float", len(code))
    var pfi = 0
    while pfi < len(print_float_code) {
        code = push(code, print_float_code[pfi])
        pfi = pfi + 1
    }

    // Emit _vx_println_str runtime stub
    let println_str_code = emit_println_str_stub()
    register_function("_vx_println_str", len(code))
    var plsi = 0
    while plsi < len(println_str_code) {
        code = push(code, println_str_code[plsi])
        plsi = plsi + 1
    }

    // Emit _vx_str_eq runtime stub
    let str_eq_code = emit_str_eq_stub()
    register_function("_vx_str_eq", len(code))
    var sei = 0
    while sei < len(str_eq_code) {
        code = push(code, str_eq_code[sei])
        sei = sei + 1
    }

    // Emit _vx_str_concat runtime stub
    let str_concat_code = emit_str_concat_stub()
    register_function("_vx_str_concat", len(code))
    var sci = 0
    while sci < len(str_concat_code) {
        code = push(code, str_concat_code[sci])
        sci = sci + 1
    }

    // Emit _vx_to_string runtime stub
    let to_string_code = emit_to_string_stub()
    register_function("_vx_to_string", len(code))
    var tsi = 0
    while tsi < len(to_string_code) {
        code = push(code, to_string_code[tsi])
        tsi = tsi + 1
    }

    // Emit _vx_str_to_int runtime stub
    let str_to_int_code = emit_str_to_int_stub()
    register_function("_vx_str_to_int", len(code))
    var stii = 0
    while stii < len(str_to_int_code) {
        code = push(code, str_to_int_code[stii])
        stii = stii + 1
    }

    // Emit _vx_str_char_at runtime stub
    let str_char_at_code = emit_str_char_at_stub()
    register_function("_vx_str_char_at", len(code))
    var scai = 0
    while scai < len(str_char_at_code) {
        code = push(code, str_char_at_code[scai])
        scai = scai + 1
    }

    // Emit _vx_str_substr runtime stub
    let str_substr_code = emit_str_substr_stub()
    register_function("_vx_str_substr", len(code))
    var ssi = 0
    while ssi < len(str_substr_code) {
        code = push(code, str_substr_code[ssi])
        ssi = ssi + 1
    }

    // Emit _vx_str_bytes runtime stub
    let str_bytes_code = emit_str_bytes_stub()
    register_function("_vx_str_bytes", len(code))
    var sbi = 0
    while sbi < len(str_bytes_code) {
        code = push(code, str_bytes_code[sbi])
        sbi = sbi + 1
    }

    // Emit _vx_str_from_bytes runtime stub
    let str_from_bytes_code = emit_str_from_bytes_stub()
    register_function("_vx_str_from_bytes", len(code))
    var sfbi = 0
    while sfbi < len(str_from_bytes_code) {
        code = push(code, str_from_bytes_code[sfbi])
        sfbi = sfbi + 1
    }

    // Emit _vx_exp runtime stub
    let exp_code = emit_exp_stub()
    register_function("_vx_exp", len(code))
    var exi = 0
    while exi < len(exp_code) {
        code = push(code, exp_code[exi])
        exi = exi + 1
    }

    // Emit _vx_log runtime stub
    let log_code = emit_log_stub()
    register_function("_vx_log", len(code))
    var lgi = 0
    while lgi < len(log_code) {
        code = push(code, log_code[lgi])
        lgi = lgi + 1
    }

    // Emit _vx_pow runtime stub
    let pow_code = emit_pow_stub()
    register_function("_vx_pow", len(code))
    var pwi = 0
    while pwi < len(pow_code) {
        code = push(code, pow_code[pwi])
        pwi = pwi + 1
    }

    // Emit _vx_str_find runtime stub
    let str_find_code = emit_str_find_stub()
    register_function("_vx_str_find", len(code))
    var sfi = 0
    while sfi < len(str_find_code) {
        code = push(code, str_find_code[sfi])
        sfi = sfi + 1
    }

    // Emit _vx_trim runtime stub
    let trim_code = emit_trim_stub()
    register_function("_vx_trim", len(code))
    var tri = 0
    while tri < len(trim_code) {
        code = push(code, trim_code[tri])
        tri = tri + 1
    }

    // Emit _vx_read_file runtime stub
    let read_file_code = emit_read_file_stub()
    register_function("_vx_read_file", len(code))
    var rfi = 0
    while rfi < len(read_file_code) {
        code = push(code, read_file_code[rfi])
        rfi = rfi + 1
    }

    // Emit _vx_write_file runtime stub
    let write_file_code = emit_write_file_stub()
    register_function("_vx_write_file", len(code))
    var wfi = 0
    while wfi < len(write_file_code) {
        code = push(code, write_file_code[wfi])
        wfi = wfi + 1
    }

    // Emit _vx_file_exists runtime stub
    let file_exists_code = emit_file_exists_stub()
    register_function("_vx_file_exists", len(code))
    var fei = 0
    while fei < len(file_exists_code) {
        code = push(code, file_exists_code[fei])
        fei = fei + 1
    }

    // Emit _vx_print_int_no_nl runtime stub
    let print_int_no_nl_code = emit_print_int_no_nl_stub()
    register_function("_vx_print_int_no_nl", len(code))
    var pinni = 0
    while pinni < len(print_int_no_nl_code) {
        code = push(code, print_int_no_nl_code[pinni])
        pinni = pinni + 1
    }

    // Pre-register global variables so all functions can see them
    // Scan for _vx_init_globals and register its var/let names
    var gi = 0
    while gi < len(fns) {
        if fns[gi][1] == "_vx_init_globals" {
            let gbody = fns[gi][3]
            var gs = 0
            while gs < len(gbody) {
                let gstmt = gbody[gs]
                if gstmt[0] == "var" {
                    globals_add(gstmt[1])
                }
                if gstmt[0] == "let" {
                    globals_add(gstmt[1])
                }
                gs = gs + 1
            }
        }
        gi = gi + 1
    }

    // Compile user functions
    var fi = 0
    while fi < len(fns) {
        code = compile_function(code, fns[fi])
        fi = fi + 1
    }

    // Emit string data section after code
    // Each string: [u64 length][bytes...]
    var sdi = 0
    while sdi < len(_string_data) {
        let str_label = "_str_" + to_string(sdi)
        add_label(str_label, len(code))
        let slen = _string_lengths[sdi]
        // Emit u64 length
        code = emit_u64_le(code, slen)
        // Emit string bytes
        let s = _string_data[sdi]
        let sbytes = str_bytes(s)
        var sbi = 0
        while sbi < len(sbytes) {
            code = emit_u8(code, int(sbytes[sbi]))
            sbi = sbi + 1
        }
        sdi = sdi + 1
    }

    // Resolve all fixups
    // Add function addresses to labels
    var f = 0
    while f < len(_func_names) {
        add_label(_func_names[f], _func_addrs[f])
        f = f + 1
    }

    // Patch all fixups
    var i = 0
    while i < len(_fixup_positions) {
        let pos = _fixup_positions[i]
        let target_name = _fixup_labels[i]
        // Find target address
        var target_addr = 0 - 1
        var j = 0
        while j < len(_label_names) {
            if _label_names[j] == target_name {
                target_addr = _label_addrs[j]
            }
            j = j + 1
        }
        if target_addr < 0 {
            println("linker error: unresolved symbol '" + target_name + "'")
        } else {
            // rel32 = target - (pos + 4)
            var rel = target_addr - (pos + 4)
            var v = rel
            if v < 0 {
                v = v + 4294967296
            }
            code[pos] = v % 256
            v = v / 256
            code[pos + 1] = v % 256
            v = v / 256
            code[pos + 2] = v % 256
            v = v / 256
            code[pos + 3] = v % 256
        }
        i = i + 1
    }

    return code
}

// ============================================================
// PHASE 5: ELF Output (inline from elf.vx)
// ============================================================

fn make_elf(code: [i64]) -> [i64] {
    let code_len = len(code)
    let num_globals = len(_global_names)
    let bss_size = num_globals * 8
    // 2 program headers if globals exist, 1 otherwise
    var phnum = 1
    if num_globals > 0 {
        phnum = 2
    }
    let header_size = 64 + phnum * 56
    let total_size = header_size + code_len
    let base_addr = 4194304
    let entry = base_addr + header_size

    var buf: [i64] = []

    // === ELF Header (64 bytes) ===
    // e_ident magic
    buf = emit_u8(buf, 127)
    buf = emit_u8(buf, 69)
    buf = emit_u8(buf, 76)
    buf = emit_u8(buf, 70)
    // EI_CLASS=2, EI_DATA=1, EI_VERSION=1, EI_OSABI=0
    buf = emit_u8(buf, 2)
    buf = emit_u8(buf, 1)
    buf = emit_u8(buf, 1)
    buf = emit_u8(buf, 0)
    // 8 bytes padding
    var pad = 0
    while pad < 8 {
        buf = emit_u8(buf, 0)
        pad = pad + 1
    }
    // e_type = ET_EXEC (2)
    buf = emit_u16_le(buf, 2)
    // e_machine = x86-64 (62)
    buf = emit_u16_le(buf, 62)
    // e_version = 1
    buf = emit_u32_le(buf, 1)
    // e_entry
    buf = emit_u64_le(buf, entry)
    // e_phoff = 64
    buf = emit_u64_le(buf, 64)
    // e_shoff = 0
    buf = emit_u64_le(buf, 0)
    // e_flags = 0
    buf = emit_u32_le(buf, 0)
    // e_ehsize = 64
    buf = emit_u16_le(buf, 64)
    // e_phentsize = 56
    buf = emit_u16_le(buf, 56)
    // e_phnum
    buf = emit_u16_le(buf, phnum)
    // e_shentsize = 0
    buf = emit_u16_le(buf, 0)
    // e_shnum = 0
    buf = emit_u16_le(buf, 0)
    // e_shstrndx = 0
    buf = emit_u16_le(buf, 0)

    // === Program Header 1: code (56 bytes) ===
    // p_type = PT_LOAD (1)
    buf = emit_u32_le(buf, 1)
    // p_flags = PF_R | PF_W | PF_X (7)
    buf = emit_u32_le(buf, 7)
    // p_offset = 0
    buf = emit_u64_le(buf, 0)
    // p_vaddr = base_addr
    buf = emit_u64_le(buf, base_addr)
    // p_paddr = base_addr
    buf = emit_u64_le(buf, base_addr)
    // p_filesz = total_size
    buf = emit_u64_le(buf, total_size)
    // p_memsz = total_size
    buf = emit_u64_le(buf, total_size)
    // p_align = 0x1000
    buf = emit_u64_le(buf, 4096)

    // === Program Header 2: .bss for globals (56 bytes) ===
    if num_globals > 0 {
        let glob_base = GLOBAL_BASE_ADDR()
        let glob_memsz = bss_size + 4096
        // p_type = PT_LOAD (1)
        buf = emit_u32_le(buf, 1)
        // p_flags = PF_R | PF_W (6)
        buf = emit_u32_le(buf, 6)
        // p_offset = 0
        buf = emit_u64_le(buf, 0)
        // p_vaddr = glob_base
        buf = emit_u64_le(buf, glob_base)
        // p_paddr = glob_base
        buf = emit_u64_le(buf, glob_base)
        // p_filesz = 0 (bss, no file content)
        buf = emit_u64_le(buf, 0)
        // p_memsz = glob_memsz
        buf = emit_u64_le(buf, glob_memsz)
        // p_align = 0x1000
        buf = emit_u64_le(buf, 4096)
    }

    // === Append code ===
    var ci = 0
    while ci < code_len {
        buf = push(buf, code[ci])
        ci = ci + 1
    }

    return buf
}

// ============================================================
// MAIN: Compile test program and produce binary
// ============================================================

fn main() {
    println("=== Vortex Compiler (vxc) ===")

    var source = ""
    var output_path = "/tmp/vortex_out"
    var source_path = ""
    if file_exists("/tmp/vx_compile_args") {
        let args = trim(read_file("/tmp/vx_compile_args"))
        let sp = unwrap_or(str_find(args, " "), -1)
        if sp > 0 { source_path = str_substr(args, 0, sp) output_path = str_substr(args, sp + 1, len(args) - sp - 1) } else { source_path = args }
    }
    if len(source_path) == 0 { source_path = "/tmp/test_compile.vx" }
    println("Reading " + source_path + "...")
    source = read_source(source_path)
    if len(source) == 0 {
        // Fallback: hardcoded test program with string and array tests
        println("No source file found, using built-in test program")
        source = "fn main() {\n  println(42)\n}\n"
    }

    println("Source:")
    println(source)

    // Phase 2: Lex
    println("Lexing...")
    let tokens = lex(source)
    println("Tokens: " + to_string(len(tokens)))

    // Phase 3: Parse
    println("Parsing...")
    _tokens = tokens
    _tpos = 0
    let fns = parse_program()
    println("Functions: " + to_string(len(fns)))

    // Phase 4: Codegen
    println("Generating x86-64...")
    let code = compile_program(fns)
    println("Code size: " + to_string(len(code)) + " bytes")

    // Phase 5: ELF
    println("Building ELF...")
    let elf = make_elf(code)
    println("ELF size: " + to_string(len(elf)) + " bytes")

    // Write to disk
    let ok = write_binary(output_path, elf)
    if ok {
        println("Written to " + output_path)
        println("Run: " + output_path)
    } else {
        println("ERROR: failed to write binary")
    }

    println("=== vxc done ===")
}
