// bytecode_compiler.vx — Compiles Vortex AST to bytecode instructions
// Pipeline: AST (from parser.vx) -> bytecode string instructions -> VM execution
// Self-contained: includes compiler + inline VM for testing
//
// Instead of encoding AST as strings, we build bytecode directly using
// helper functions that append to a code array. Tests construct AST by
// calling compiler functions directly.

// ── Helpers ───────────────────────────────────────────────────────────────────

fn _nl() -> String { return str_from_bytes([10]) }

fn sw(s: String, prefix: String) -> bool {
    if len(s) < len(prefix) { return false }
    return str_substr(s, 0, len(prefix)) == prefix
}

fn after(s: String, n: i64) -> String {
    return str_substr(s, n, len(s))
}

fn find_idx(haystack: String, needle: String) -> i64 {
    return unwrap_or(str_find(haystack, needle), -1)
}

// ── Label generation ─────────────────────────────────────────────────────────

var _label_id = 0

fn new_label(prefix: String) -> String {
    _label_id = _label_id + 1
    return prefix + "_" + to_string(_label_id)
}

// ── Bytecode emitter helpers ─────────────────────────────────────────────────

fn emit(code: [String], instr: String) -> [String] {
    return push(code, instr)
}

// ── Expression compilers (append to code array, return updated code) ─────────

fn emit_int(code: [String], n: i64) -> [String] {
    return emit(code, "PUSH_INT " + to_string(n))
}

fn emit_str(code: [String], s: String) -> [String] {
    return emit(code, "PUSH_STRING " + s)
}

fn emit_load(code: [String], name: String) -> [String] {
    return emit(code, "LOAD " + name)
}

fn emit_store(code: [String], name: String) -> [String] {
    return emit(code, "STORE " + name)
}

fn emit_add(code: [String]) -> [String] { return emit(code, "ADD") }
fn emit_sub(code: [String]) -> [String] { return emit(code, "SUB") }
fn emit_mul(code: [String]) -> [String] { return emit(code, "MUL") }
fn emit_div(code: [String]) -> [String] { return emit(code, "DIV") }
fn emit_mod(code: [String]) -> [String] { return emit(code, "MOD") }
fn emit_neg(code: [String]) -> [String] { return emit(code, "NEG") }
fn emit_not(code: [String]) -> [String] { return emit(code, "NOT") }
fn emit_eq(code: [String]) -> [String] { return emit(code, "EQ") }
fn emit_neq(code: [String]) -> [String] { return emit(code, "NEQ") }
fn emit_lt(code: [String]) -> [String] { return emit(code, "LT") }
fn emit_gt(code: [String]) -> [String] { return emit(code, "GT") }
fn emit_le(code: [String]) -> [String] { return emit(code, "LTEQ") }
fn emit_ge(code: [String]) -> [String] { return emit(code, "GTEQ") }
fn emit_and(code: [String]) -> [String] { return emit(code, "AND") }
fn emit_or(code: [String]) -> [String] { return emit(code, "OR") }

fn emit_call(code: [String], fname: String, argc: i64) -> [String] {
    return emit(code, "CALL " + fname + " " + to_string(argc))
}

fn emit_ret(code: [String]) -> [String] { return emit(code, "RET") }
fn emit_pop(code: [String]) -> [String] { return emit(code, "POP") }
fn emit_halt(code: [String]) -> [String] { return emit(code, "HALT") }
fn emit_label(code: [String], lbl: String) -> [String] { return emit(code, "LABEL " + lbl) }
fn emit_jmp(code: [String], lbl: String) -> [String] { return emit(code, "JMP " + lbl) }
fn emit_jz(code: [String], lbl: String) -> [String] { return emit(code, "JZ " + lbl) }
fn emit_fn_start(code: [String], name: String) -> [String] { return emit(code, "FN_START " + name) }
fn emit_fn_end(code: [String]) -> [String] { return emit(code, "FN_END") }

// ══════════════════════════════════════════════════════════════════════════════
// INLINE VM (core from vm.vx for self-contained testing)
// ══════════════════════════════════════════════════════════════════════════════

fn make_int(n: i64) -> String   { return "i:" + to_string(n) }
fn make_str_val(s: String) -> String { return "s:" + s }
fn make_bool(b: bool) -> String {
    if b { return "b:true" }
    return "b:false"
}

fn val_display(v: String) -> String {
    if sw(v, "i:")    { return after(v, 2) }
    if sw(v, "f:")    { return after(v, 2) }
    if sw(v, "s:")    { return after(v, 2) }
    if v == "b:true"  { return "true" }
    if v == "b:false" { return "false" }
    if v == "void"    { return "()" }
    return v
}

fn val_is_truthy(v: String) -> bool {
    if v == "b:true"  { return true }
    if v == "b:false" { return false }
    if v == "void"    { return false }
    if sw(v, "i:") { return after(v, 2) != "0" }
    if sw(v, "s:") { return len(after(v, 2)) > 0 }
    return true
}

fn val_as_int(v: String) -> i64 {
    if sw(v, "i:") { return int(after(v, 2)) }
    return 0
}

fn val_add(a: String, b: String) -> String {
    if sw(a, "s:") { return make_str_val(val_display(a) + val_display(b)) }
    if sw(b, "s:") { return make_str_val(val_display(a) + val_display(b)) }
    return make_int(val_as_int(a) + val_as_int(b))
}
fn val_sub(a: String, b: String) -> String { return make_int(val_as_int(a) - val_as_int(b)) }
fn val_mul(a: String, b: String) -> String { return make_int(val_as_int(a) * val_as_int(b)) }
fn val_div(a: String, b: String) -> String {
    var d = val_as_int(b)
    if d == 0 { return "i:0" }
    return make_int(val_as_int(a) / d)
}
fn val_mod_op(a: String, b: String) -> String {
    var d = val_as_int(b)
    if d == 0 { return "i:0" }
    return make_int(val_as_int(a) % d)
}
fn val_neg(a: String) -> String { return make_int(0 - val_as_int(a)) }
fn val_not(a: String) -> String {
    if val_is_truthy(a) { return "b:false" }
    return "b:true"
}

fn val_cmp(a: String, b: String, op: String) -> String {
    var ai = val_as_int(a)
    var bi = val_as_int(b)
    if op == "EQ"   { return make_bool(ai == bi) }
    if op == "NEQ"  { return make_bool(ai != bi) }
    if op == "LT"   { return make_bool(ai < bi) }
    if op == "GT"   { return make_bool(ai > bi) }
    if op == "LTEQ" { return make_bool(ai <= bi) }
    if op == "GTEQ" { return make_bool(ai >= bi) }
    return "b:false"
}

fn val_and(a: String, b: String) -> String {
    if val_is_truthy(a) {
        if val_is_truthy(b) { return "b:true" }
    }
    return "b:false"
}
fn val_or(a: String, b: String) -> String {
    if val_is_truthy(a) { return "b:true" }
    if val_is_truthy(b) { return "b:true" }
    return "b:false"
}

fn stack_pop(stack: [String]) -> [String] {
    var ns: [String] = []
    var i = 0
    while i < len(stack) - 1 {
        ns = push(ns, stack[i])
        i = i + 1
    }
    return ns
}

fn stack_pop2(stack: [String]) -> [String] {
    var ns: [String] = []
    var i = 0
    while i < len(stack) - 2 {
        ns = push(ns, stack[i])
        i = i + 1
    }
    return ns
}

fn stack_top(stack: [String]) -> String {
    if len(stack) == 0 { return "void" }
    return stack[len(stack) - 1]
}

fn stack_second(stack: [String]) -> String {
    if len(stack) < 2 { return "void" }
    return stack[len(stack) - 2]
}

fn instr_op(instr: String) -> String {
    var idx = find_idx(instr, " ")
    if idx < 0 { return instr }
    return str_substr(instr, 0, idx)
}

fn rest_after_space(s: String) -> String {
    var idx = find_idx(s, " ")
    if idx < 0 { return "" }
    return str_substr(s, idx + 1, len(s))
}

fn instr_arg1(instr: String) -> String {
    var rest = rest_after_space(instr)
    var idx = find_idx(rest, " ")
    if idx < 0 { return rest }
    return str_substr(rest, 0, idx)
}

fn instr_arg2(instr: String) -> String {
    var rest = rest_after_space(instr)
    return rest_after_space(rest)
}

fn vars_get(vars: [String], name: String) -> String {
    var i = len(vars) - 2
    while i >= 0 {
        if vars[i] == name { return vars[i + 1] }
        i = i - 2
    }
    return "void"
}

fn vars_set(vars: [String], name: String, val: String) -> [String] {
    var i = len(vars) - 2
    while i >= 0 {
        if vars[i] == name {
            vars[i + 1] = val
            return vars
        }
        if vars[i] == "##SCOPE##" {
            vars = push(vars, name)
            vars = push(vars, val)
            return vars
        }
        i = i - 2
    }
    vars = push(vars, name)
    vars = push(vars, val)
    return vars
}

fn vars_push_scope(vars: [String]) -> [String] {
    vars = push(vars, "##SCOPE##")
    vars = push(vars, "##SCOPE##")
    return vars
}

fn vars_pop_scope(vars: [String]) -> [String] {
    while len(vars) >= 2 {
        var top_name = vars[len(vars) - 2]
        var nv: [String] = []
        var j = 0
        while j < len(vars) - 2 {
            nv = push(nv, vars[j])
            j = j + 1
        }
        vars = nv
        if top_name == "##SCOPE##" { return vars }
    }
    return vars
}

fn table_get(table: [String], key: String) -> i64 {
    var i = 0
    while i < len(table) - 1 {
        if table[i] == key { return int(table[i + 1]) }
        i = i + 2
    }
    return -1
}

fn table_set(table: [String], key: String, val: i64) -> [String] {
    table = push(table, key)
    table = push(table, to_string(val))
    return table
}

fn preprocess_labels(instrs: [String]) -> [String] {
    var labels: [String] = []
    var i = 0
    while i < len(instrs) {
        var op = instr_op(instrs[i])
        if op == "LABEL" {
            var name = instr_arg1(instrs[i])
            labels = table_set(labels, name, i)
        }
        i = i + 1
    }
    return labels
}

fn preprocess_fns(instrs: [String]) -> [String] {
    var fns: [String] = []
    var i = 0
    while i < len(instrs) {
        var op = instr_op(instrs[i])
        if op == "FN_START" {
            var name = instr_arg1(instrs[i])
            fns = table_set(fns, name, i)
        }
        i = i + 1
    }
    return fns
}

fn call_builtin(name: String, argc: i64, stack: [String]) -> [String] {
    var top = stack_top(stack)

    if name == "println" {
        var ns = stack_pop(stack)
        print(val_display(top) + _nl())
        ns = push(ns, "void")
        return ns
    }
    if name == "print" {
        var ns = stack_pop(stack)
        print(val_display(top))
        ns = push(ns, "void")
        return ns
    }

    var ns: [String] = []
    var start = len(stack) - argc
    var i = 0
    while i < start {
        ns = push(ns, stack[i])
        i = i + 1
    }
    ns = push(ns, "void")
    return ns
}

fn vm_exec(instrs: [String]) -> String {
    var stack: [String] = []
    var vars: [String] = []
    var call_stack: [String] = []
    var labels = preprocess_labels(instrs)
    var fns = preprocess_fns(instrs)

    var ip = 0
    var status = "running"
    var result = "void"

    var main_ip = table_get(fns, "main")
    if main_ip >= 0 {
        ip = main_ip + 1
        vars = vars_push_scope(vars)
    }

    while status == "running" {
        if ip >= len(instrs) { status = "halted" }
        if status == "running" {
            var instr = instrs[ip]
            var op = instr_op(instr)

            if op == "HALT" {
                status = "halted"
                result = stack_top(stack)
            }

            if op == "PUSH_INT" {
                stack = push(stack, make_int(int(instr_arg1(instr))))
                ip = ip + 1
            }
            if op == "PUSH_STRING" {
                stack = push(stack, make_str_val(instr_arg1(instr)))
                ip = ip + 1
            }
            if op == "PUSH_BOOL" {
                var arg = instr_arg1(instr)
                if arg == "true" { stack = push(stack, "b:true") }
                if arg != "true" { stack = push(stack, "b:false") }
                ip = ip + 1
            }

            if op == "LOAD" {
                stack = push(stack, vars_get(vars, instr_arg1(instr)))
                ip = ip + 1
            }
            if op == "STORE" {
                var val = stack_top(stack)
                stack = stack_pop(stack)
                vars = vars_set(vars, instr_arg1(instr), val)
                ip = ip + 1
            }

            if op == "POP" {
                if len(stack) > 0 { stack = stack_pop(stack) }
                ip = ip + 1
            }
            if op == "DUP" {
                if len(stack) > 0 { stack = push(stack, stack_top(stack)) }
                ip = ip + 1
            }

            if op == "ADD" {
                var b = stack_top(stack)
                var a = stack_second(stack)
                stack = stack_pop2(stack)
                stack = push(stack, val_add(a, b))
                ip = ip + 1
            }
            if op == "SUB" {
                var b = stack_top(stack)
                var a = stack_second(stack)
                stack = stack_pop2(stack)
                stack = push(stack, val_sub(a, b))
                ip = ip + 1
            }
            if op == "MUL" {
                var b = stack_top(stack)
                var a = stack_second(stack)
                stack = stack_pop2(stack)
                stack = push(stack, val_mul(a, b))
                ip = ip + 1
            }
            if op == "DIV" {
                var b = stack_top(stack)
                var a = stack_second(stack)
                stack = stack_pop2(stack)
                stack = push(stack, val_div(a, b))
                ip = ip + 1
            }
            if op == "MOD" {
                var b = stack_top(stack)
                var a = stack_second(stack)
                stack = stack_pop2(stack)
                stack = push(stack, val_mod_op(a, b))
                ip = ip + 1
            }
            if op == "NEG" {
                var a = stack_top(stack)
                stack = stack_pop(stack)
                stack = push(stack, val_neg(a))
                ip = ip + 1
            }

            var is_cmp = false
            if op == "EQ"   { is_cmp = true }
            if op == "NEQ"  { is_cmp = true }
            if op == "LT"   { is_cmp = true }
            if op == "GT"   { is_cmp = true }
            if op == "LTEQ" { is_cmp = true }
            if op == "GTEQ" { is_cmp = true }
            if is_cmp {
                var b = stack_top(stack)
                var a = stack_second(stack)
                stack = stack_pop2(stack)
                stack = push(stack, val_cmp(a, b, op))
                ip = ip + 1
            }

            if op == "AND" {
                var b = stack_top(stack)
                var a = stack_second(stack)
                stack = stack_pop2(stack)
                stack = push(stack, val_and(a, b))
                ip = ip + 1
            }
            if op == "OR" {
                var b = stack_top(stack)
                var a = stack_second(stack)
                stack = stack_pop2(stack)
                stack = push(stack, val_or(a, b))
                ip = ip + 1
            }
            if op == "NOT" {
                var a = stack_top(stack)
                stack = stack_pop(stack)
                stack = push(stack, val_not(a))
                ip = ip + 1
            }

            if op == "JMP" {
                var lbl = instr_arg1(instr)
                var target = table_get(labels, lbl)
                if target >= 0 { ip = target + 1 }
                if target < 0 {
                    status = "error"
                    print("VM error: unknown label " + lbl + _nl())
                }
            }

            if op == "JZ" {
                var lbl = instr_arg1(instr)
                var cond_val = stack_top(stack)
                stack = stack_pop(stack)
                if val_is_truthy(cond_val) {
                    ip = ip + 1
                } else {
                    var target = table_get(labels, lbl)
                    if target >= 0 { ip = target + 1 }
                    if target < 0 {
                        status = "error"
                        print("VM error: unknown label " + lbl + _nl())
                    }
                }
            }

            if op == "LABEL" { ip = ip + 1 }

            if op == "FN_START" {
                var depth = 1
                ip = ip + 1
                while depth > 0 {
                    if ip >= len(instrs) { depth = 0 }
                    if depth > 0 {
                        var skip_op = instr_op(instrs[ip])
                        if skip_op == "FN_START" { depth = depth + 1 }
                        if skip_op == "FN_END"   { depth = depth - 1 }
                        ip = ip + 1
                    }
                }
            }

            if op == "FN_END" {
                if len(call_stack) >= 1 {
                    var ret_ip = int(call_stack[len(call_stack) - 1])
                    call_stack = stack_pop(call_stack)
                    vars = vars_pop_scope(vars)
                    ip = ret_ip
                } else {
                    status = "halted"
                    result = stack_top(stack)
                }
            }

            if op == "RET" {
                var ret_val = "void"
                if len(stack) > 0 {
                    ret_val = stack_top(stack)
                    stack = stack_pop(stack)
                }
                if len(call_stack) >= 1 {
                    var ret_ip = int(call_stack[len(call_stack) - 1])
                    call_stack = stack_pop(call_stack)
                    vars = vars_pop_scope(vars)
                    stack = push(stack, ret_val)
                    ip = ret_ip
                } else {
                    result = ret_val
                    status = "halted"
                }
            }

            if op == "CALL" {
                var fn_name = instr_arg1(instr)
                var argc = int(instr_arg2(instr))
                var is_builtin = false
                if fn_name == "println" { is_builtin = true }
                if fn_name == "print"   { is_builtin = true }
                if is_builtin {
                    stack = call_builtin(fn_name, argc, stack)
                    ip = ip + 1
                } else {
                    var fn_ip = table_get(fns, fn_name)
                    if fn_ip < 0 {
                        status = "error"
                        print("VM error: undefined function " + fn_name + _nl())
                    } else {
                        call_stack = push(call_stack, to_string(ip + 1))
                        vars = vars_push_scope(vars)
                        ip = fn_ip + 1
                    }
                }
            }
        }
    }

    if result == "void" { result = stack_top(stack) }
    return result
}

// ══════════════════════════════════════════════════════════════════════════════
// TESTS: Build bytecode with compiler helpers, then execute with VM
// ══════════════════════════════════════════════════════════════════════════════

fn main() {
    print("=== Vortex Bytecode Compiler ===" + _nl())
    print("AST -> bytecode -> VM execution" + _nl())
    print(_nl())

    // ── Test 1: println(40 + 2) → should print 42 ──
    print("Test 1: println(40 + 2)" + _nl())
    var c1: [String] = []
    c1 = emit_fn_start(c1, "main")
    c1 = emit_int(c1, 40)
    c1 = emit_int(c1, 2)
    c1 = emit_add(c1)
    c1 = emit_call(c1, "println", 1)
    c1 = emit_halt(c1)
    c1 = emit_fn_end(c1)
    print("  Bytecode (" + to_string(len(c1)) + " instrs): ")
    var di = 0
    while di < len(c1) {
        print("[" + c1[di] + "] ")
        di = di + 1
    }
    print(_nl())
    print("  Output: ")
    vm_exec(c1)
    print(_nl())

    // ── Test 2: let x = 10; println(x * 3) → 30 ──
    print("Test 2: let x = 10; println(x * 3)" + _nl())
    var c2: [String] = []
    c2 = emit_fn_start(c2, "main")
    c2 = emit_int(c2, 10)
    c2 = emit_store(c2, "x")
    c2 = emit_load(c2, "x")
    c2 = emit_int(c2, 3)
    c2 = emit_mul(c2)
    c2 = emit_call(c2, "println", 1)
    c2 = emit_halt(c2)
    c2 = emit_fn_end(c2)
    print("  Output: ")
    vm_exec(c2)
    print(_nl())

    // ── Test 3: if 1 > 0 { println(1) } else { println(0) } → 1 ──
    print("Test 3: if 1 > 0 { println(1) } else { println(0) }" + _nl())
    var c3: [String] = []
    c3 = emit_fn_start(c3, "main")
    c3 = emit_int(c3, 1)
    c3 = emit_int(c3, 0)
    c3 = emit_gt(c3)
    var else_lbl = new_label("else")
    var end_lbl = new_label("endif")
    c3 = emit_jz(c3, else_lbl)
    // then
    c3 = emit_int(c3, 1)
    c3 = emit_call(c3, "println", 1)
    c3 = emit_jmp(c3, end_lbl)
    // else
    c3 = emit_label(c3, else_lbl)
    c3 = emit_int(c3, 0)
    c3 = emit_call(c3, "println", 1)
    c3 = emit_label(c3, end_lbl)
    c3 = emit_halt(c3)
    c3 = emit_fn_end(c3)
    print("  Output: ")
    vm_exec(c3)
    print(_nl())

    // ── Test 4: while loop: sum = 0; i = 1; while i <= 5 { sum += i; i += 1 }; println(sum) → 15 ──
    print("Test 4: while loop sum 1..5 = 15" + _nl())
    var c4: [String] = []
    c4 = emit_fn_start(c4, "main")
    // var sum = 0
    c4 = emit_int(c4, 0)
    c4 = emit_store(c4, "sum")
    // var i = 1
    c4 = emit_int(c4, 1)
    c4 = emit_store(c4, "i")
    // while i <= 5
    var loop_lbl = new_label("loop")
    var endloop_lbl = new_label("endloop")
    c4 = emit_label(c4, loop_lbl)
    c4 = emit_load(c4, "i")
    c4 = emit_int(c4, 5)
    c4 = emit_le(c4)
    c4 = emit_jz(c4, endloop_lbl)
    // sum = sum + i
    c4 = emit_load(c4, "sum")
    c4 = emit_load(c4, "i")
    c4 = emit_add(c4)
    c4 = emit_store(c4, "sum")
    // i = i + 1
    c4 = emit_load(c4, "i")
    c4 = emit_int(c4, 1)
    c4 = emit_add(c4)
    c4 = emit_store(c4, "i")
    c4 = emit_jmp(c4, loop_lbl)
    c4 = emit_label(c4, endloop_lbl)
    // println(sum)
    c4 = emit_load(c4, "sum")
    c4 = emit_call(c4, "println", 1)
    c4 = emit_halt(c4)
    c4 = emit_fn_end(c4)
    print("  Output: ")
    vm_exec(c4)
    print(_nl())

    // ── Test 5: function call — square(9) → 81 ──
    print("Test 5: fn square(n) { return n * n }; println(square(9))" + _nl())
    var c5: [String] = []
    // main function
    c5 = emit_fn_start(c5, "main")
    c5 = emit_int(c5, 9)
    c5 = emit_call(c5, "square", 1)
    c5 = emit_call(c5, "println", 1)
    c5 = emit_halt(c5)
    c5 = emit_fn_end(c5)
    // square function
    c5 = emit_fn_start(c5, "square")
    c5 = emit_store(c5, "n")
    c5 = emit_load(c5, "n")
    c5 = emit_load(c5, "n")
    c5 = emit_mul(c5)
    c5 = emit_ret(c5)
    c5 = emit_fn_end(c5)
    print("  Output: ")
    vm_exec(c5)
    print(_nl())

    // ── Test 6: nested expression — (3 + 4) * (10 - 2) → 56 ──
    print("Test 6: (3 + 4) * (10 - 2) = 56" + _nl())
    var c6: [String] = []
    c6 = emit_fn_start(c6, "main")
    c6 = emit_int(c6, 3)
    c6 = emit_int(c6, 4)
    c6 = emit_add(c6)
    c6 = emit_int(c6, 10)
    c6 = emit_int(c6, 2)
    c6 = emit_sub(c6)
    c6 = emit_mul(c6)
    c6 = emit_call(c6, "println", 1)
    c6 = emit_halt(c6)
    c6 = emit_fn_end(c6)
    print("  Output: ")
    vm_exec(c6)
    print(_nl())

    // ── Test 7: string output ──
    print("Test 7: println(hello_world)" + _nl())
    var c7: [String] = []
    c7 = emit_fn_start(c7, "main")
    c7 = emit_str(c7, "hello_world")
    c7 = emit_call(c7, "println", 1)
    c7 = emit_halt(c7)
    c7 = emit_fn_end(c7)
    print("  Output: ")
    vm_exec(c7)
    print(_nl())

    // ── Test 8: two-function pipeline — add(a, b) called from main ──
    print("Test 8: fn add(a, b) { return a + b }; println(add(17, 25)) = 42" + _nl())
    var c8: [String] = []
    c8 = emit_fn_start(c8, "main")
    c8 = emit_int(c8, 17)
    c8 = emit_int(c8, 25)
    c8 = emit_call(c8, "add_fn", 2)
    c8 = emit_call(c8, "println", 1)
    c8 = emit_halt(c8)
    c8 = emit_fn_end(c8)
    c8 = emit_fn_start(c8, "add_fn")
    c8 = emit_store(c8, "b")
    c8 = emit_store(c8, "a")
    c8 = emit_load(c8, "a")
    c8 = emit_load(c8, "b")
    c8 = emit_add(c8)
    c8 = emit_ret(c8)
    c8 = emit_fn_end(c8)
    print("  Output: ")
    vm_exec(c8)
    print(_nl())

    print("=== All tests complete ===" + _nl())
}
