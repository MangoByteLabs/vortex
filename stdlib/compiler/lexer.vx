// Vortex Self-Hosting Lexer
// Tokenizes Vortex source code into a token stream.
// Part of the self-hosting compiler pipeline: lexer -> parser -> codegen
//
// Tokens are [type, value, line, col] arrays.
// Token types are string constants returned by helper functions.

// Special character helpers (Vortex strings do not process escape sequences)
fn _nl() -> String { return str_from_bytes([10]) }
fn _tab() -> String { return str_from_bytes([9]) }
fn _quote() -> String { return str_from_bytes([34]) }
fn _backslash() -> String { return str_from_bytes([92]) }

fn keywords() -> [String] {
    return [
        "fn", "let", "var", "if", "else", "for", "while", "in",
        "return", "true", "false", "struct", "enum", "impl", "trait",
        "match", "import", "break", "continue", "pub", "mut", "self"
    ]
}

fn is_keyword(word: String) -> bool {
    let kws = keywords()
    for i in range(0, len(kws)) {
        if kws[i] == word {
            return true
        }
    }
    return false
}

// Token constructor: returns [type, value, line, col]
fn token(typ: String, value: String, line: i64, col: i64) -> [String] {
    return [typ, value, str(line), str(col)]
}

fn tok_type(t: [String]) -> String { return t[0] }
fn tok_value(t: [String]) -> String { return t[1] }

// --- Main lexer ---
fn lex(source: String) -> [String] {
    var tokens = []
    var pos = 0
    var line = 1
    var col = 1
    let src_len = len(source)

    while pos < src_len {
        let ch = str_char_at(source, pos)

        // Skip whitespace
        if str_is_ascii_whitespace(ch) {
            if ch == _nl() {
                line = line + 1
                col = 1
            } else {
                col = col + 1
            }
            pos = pos + 1
            continue
        }

        // Skip line comments
        if ch == "/" {
            if pos + 1 < src_len {
                let next = str_char_at(source, pos + 1)
                if next == "/" {
                    pos = pos + 2
                    col = col + 2
                    while pos < src_len {
                        let cc = str_char_at(source, pos)
                        if cc == _nl() {
                            break
                        }
                        pos = pos + 1
                        col = col + 1
                    }
                    continue
                }
            }
        }

        // Numbers (integer or float)
        if str_is_ascii_digit(ch) {
            let start = pos
            let start_col = col
            while pos < src_len {
                let c = str_char_at(source, pos)
                if str_is_ascii_digit(c) {
                    pos = pos + 1
                    col = col + 1
                } else {
                    break
                }
            }
            // Check for float
            if pos < src_len {
                let c = str_char_at(source, pos)
                if c == "." {
                    if pos + 1 < src_len {
                        let after_dot = str_char_at(source, pos + 1)
                        if str_is_ascii_digit(after_dot) {
                            pos = pos + 1
                            col = col + 1
                            while pos < src_len {
                                let d = str_char_at(source, pos)
                                if str_is_ascii_digit(d) {
                                    pos = pos + 1
                                    col = col + 1
                                } else {
                                    break
                                }
                            }
                            let val = str_substr(source, start, pos - start)
                            tokens = push(tokens, token("FLOAT", val, line, start_col))
                            continue
                        }
                    }
                }
            }
            let val = str_substr(source, start, pos - start)
            tokens = push(tokens, token("INT", val, line, start_col))
            continue
        }

        // Identifiers and keywords
        if str_is_ascii_alpha(ch) {
            let start = pos
            let start_col = col
            while pos < src_len {
                let c = str_char_at(source, pos)
                if str_is_ascii_alpha(c) {
                    pos = pos + 1
                    col = col + 1
                } else if str_is_ascii_digit(c) {
                    pos = pos + 1
                    col = col + 1
                } else if c == "_" {
                    pos = pos + 1
                    col = col + 1
                } else {
                    break
                }
            }
            let word = str_substr(source, start, pos - start)
            if is_keyword(word) {
                tokens = push(tokens, token("KEYWORD", word, line, start_col))
            } else {
                let interned = str_intern(word)
                tokens = push(tokens, token("IDENT", word, line, start_col))
            }
            continue
        }

        // Underscore-leading identifiers
        if ch == "_" {
            let start = pos
            let start_col = col
            pos = pos + 1
            col = col + 1
            while pos < src_len {
                let c = str_char_at(source, pos)
                if str_is_ascii_alpha(c) {
                    pos = pos + 1
                    col = col + 1
                } else if str_is_ascii_digit(c) {
                    pos = pos + 1
                    col = col + 1
                } else if c == "_" {
                    pos = pos + 1
                    col = col + 1
                } else {
                    break
                }
            }
            let word = str_substr(source, start, pos - start)
            let interned = str_intern(word)
            tokens = push(tokens, token("IDENT", word, line, start_col))
            continue
        }

        // String literals
        if ch == _quote() {
            let start_col = col
            pos = pos + 1
            col = col + 1
            var buf = ""
            while pos < src_len {
                let c = str_char_at(source, pos)
                if c == _backslash() {
                    pos = pos + 1
                    col = col + 1
                    if pos < src_len {
                        let esc = str_char_at(source, pos)
                        if esc == "n" {
                            buf = buf + _nl()
                        } else if esc == "t" {
                            buf = buf + _tab()
                        } else if esc == _backslash() {
                            buf = buf + _backslash()
                        } else if esc == _quote() {
                            buf = buf + _quote()
                        } else {
                            buf = buf + esc
                        }
                        pos = pos + 1
                        col = col + 1
                    }
                } else if c == _quote() {
                    pos = pos + 1
                    col = col + 1
                    break
                } else {
                    if c == _nl() {
                        line = line + 1
                        col = 1
                    } else {
                        col = col + 1
                    }
                    buf = buf + c
                    pos = pos + 1
                }
            }
            tokens = push(tokens, token("STRING", buf, line, start_col))
            continue
        }

        // Two-character operators
        if pos + 1 < src_len {
            let two = str_substr(source, pos, 2)
            if two == "==" {
                tokens = push(tokens, token("EQEQ", "==", line, col))
                pos = pos + 2
                col = col + 2
                continue
            }
            if two == "!=" {
                tokens = push(tokens, token("NEQ", "!=", line, col))
                pos = pos + 2
                col = col + 2
                continue
            }
            if two == "<=" {
                tokens = push(tokens, token("LTEQ", "<=", line, col))
                pos = pos + 2
                col = col + 2
                continue
            }
            if two == ">=" {
                tokens = push(tokens, token("GTEQ", ">=", line, col))
                pos = pos + 2
                col = col + 2
                continue
            }
            if two == "&&" {
                tokens = push(tokens, token("AND", "&&", line, col))
                pos = pos + 2
                col = col + 2
                continue
            }
            if two == "||" {
                tokens = push(tokens, token("OR", "||", line, col))
                pos = pos + 2
                col = col + 2
                continue
            }
            if two == "->" {
                tokens = push(tokens, token("ARROW", "->", line, col))
                pos = pos + 2
                col = col + 2
                continue
            }
        }

        // Single-character tokens
        let start_col = col
        if ch == "+" {
            tokens = push(tokens, token("PLUS", "+", line, start_col))
        } else if ch == "-" {
            tokens = push(tokens, token("MINUS", "-", line, start_col))
        } else if ch == "*" {
            tokens = push(tokens, token("STAR", "*", line, start_col))
        } else if ch == "/" {
            tokens = push(tokens, token("SLASH", "/", line, start_col))
        } else if ch == "%" {
            tokens = push(tokens, token("PERCENT", "%", line, start_col))
        } else if ch == "=" {
            tokens = push(tokens, token("EQ", "=", line, start_col))
        } else if ch == "<" {
            tokens = push(tokens, token("LT", "<", line, start_col))
        } else if ch == ">" {
            tokens = push(tokens, token("GT", ">", line, start_col))
        } else if ch == "!" {
            tokens = push(tokens, token("NOT", "!", line, start_col))
        } else if ch == "(" {
            tokens = push(tokens, token("LPAREN", "(", line, start_col))
        } else if ch == ")" {
            tokens = push(tokens, token("RPAREN", ")", line, start_col))
        } else if ch == "{" {
            tokens = push(tokens, token("LBRACE", "{", line, start_col))
        } else if ch == "}" {
            tokens = push(tokens, token("RBRACE", "}", line, start_col))
        } else if ch == "[" {
            tokens = push(tokens, token("LBRACKET", "[", line, start_col))
        } else if ch == "]" {
            tokens = push(tokens, token("RBRACKET", "]", line, start_col))
        } else if ch == "," {
            tokens = push(tokens, token("COMMA", ",", line, start_col))
        } else if ch == "." {
            tokens = push(tokens, token("DOT", ".", line, start_col))
        } else if ch == ":" {
            tokens = push(tokens, token("COLON", ":", line, start_col))
        } else if ch == "|" {
            tokens = push(tokens, token("PIPE", "|", line, start_col))
        } else if ch == "?" {
            tokens = push(tokens, token("QUESTION", "?", line, start_col))
        } else {
            println("lexer: unexpected character '" + ch + "' at line " + str(line))
        }

        pos = pos + 1
        col = col + 1
    }

    tokens = push(tokens, token("EOF", "", line, col))
    return tokens
}

// --- Test ---
fn main() {
    let source = "fn add(a: i64, b: i64) -> i64 { return a + b }"
    let tokens = lex(source)
    for i in range(0, len(tokens)) {
        let t = tokens[i]
        println(tok_type(t) + ": " + tok_value(t))
    }
}
