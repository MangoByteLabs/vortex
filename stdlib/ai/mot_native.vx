// MatrixOfThought (MoT) — Native 5D Cognitive Reasoning Space
// Dimensions: [batch, heads, layers, seq_len, dim]
// Representation: ["mot", batch, heads, layers, seq, dim, ...data_as_strings...]
// Header is 6 elements, data starts at index 6

// ─── Math Helpers ───

fn _abs(x: f64) -> f64 {
    if x < 0.0 {
        return 0.0 - x
    }
    return x
}

fn _sqrt(x: f64) -> f64 {
    if x <= 0.0 {
        return 0.0
    }
    var guess = x / 2.0
    if guess < 1.0 {
        guess = 1.0
    }
    var i = 0
    while i < 80 {
        let next = (guess + x / guess) / 2.0
        if _abs(next - guess) < 1.0e-15 * _abs(next) {
            return next
        }
        guess = next
        i = i + 1
    }
    return guess
}

fn _exp(x: f64) -> f64 {
    let ln2 = 0.6931471805599453
    let k = int(x / ln2)
    let r = x - float(k) * ln2
    var term = 1.0
    var sum = 1.0
    var n = 1
    while n < 50 {
        term = term * r / float(n)
        sum = sum + term
        if _abs(term) < 1.0e-17 {
            return sum * _pow2(k)
        }
        n = n + 1
    }
    return sum * _pow2(k)
}

fn _pow2(k: i64) -> f64 {
    var result = 1.0
    if k >= 0 {
        var i = 0
        while i < k {
            result = result * 2.0
            i = i + 1
        }
    } else {
        var i = 0
        var nk = 0 - k
        while i < nk {
            result = result * 2.0
            i = i + 1
        }
        result = 1.0 / result
    }
    return result
}

// ─── MoT Core ───

fn mot_new(batch: i64, heads: i64, layers: i64, seq_len: i64, dim: i64) -> [String] {
    var m = ["mot"]
    m = push(m, to_string(batch))
    m = push(m, to_string(heads))
    m = push(m, to_string(layers))
    m = push(m, to_string(seq_len))
    m = push(m, to_string(dim))
    let total = batch * heads * layers * seq_len * dim
    var i = 0
    while i < total {
        m = push(m, "0.0")
        i = i + 1
    }
    m
}

fn mot_shape(m: [String]) -> [i64] {
    var s = [int(m[1])]
    s = push(s, int(m[2]))
    s = push(s, int(m[3]))
    s = push(s, int(m[4]))
    s = push(s, int(m[5]))
    s
}

fn mot_size(m: [String]) -> i64 {
    int(m[1]) * int(m[2]) * int(m[3]) * int(m[4]) * int(m[5])
}

// Flat index into data region (starts at offset 6)
fn _mot_idx(m: [String], b: i64, h: i64, l: i64, s: i64, d: i64) -> i64 {
    let heads = int(m[2])
    let layers = int(m[3])
    let seq = int(m[4])
    let dim = int(m[5])
    6 + b * (heads * layers * seq * dim) + h * (layers * seq * dim) + l * (seq * dim) + s * dim + d
}

// ─── Read/Write Thoughts ───

fn mot_get(m: [String], b: i64, h: i64, l: i64, s: i64, d: i64) -> f64 {
    let idx = _mot_idx(m, b, h, l, s, d)
    float(m[idx])
}

fn mot_set(m: [String], b: i64, h: i64, l: i64, s: i64, d: i64, val: f64) -> [String] {
    let idx = _mot_idx(m, b, h, l, s, d)
    var result = []
    var i = 0
    let n = len(m)
    while i < n {
        if i == idx {
            result = push(result, to_string(val))
        } else {
            result = push(result, m[i])
        }
        i = i + 1
    }
    result
}

fn mot_get_thought(m: [String], b: i64, h: i64, l: i64, s: i64) -> [f64] {
    let dim = int(m[5])
    var t = []
    var d = 0
    while d < dim {
        t = push(t, mot_get(m, b, h, l, s, d))
        d = d + 1
    }
    t
}

fn mot_set_thought(m: [String], b: i64, h: i64, l: i64, s: i64, thought: [f64]) -> [String] {
    let dim = int(m[5])
    var result = m
    var d = 0
    while d < dim {
        result = mot_set(result, b, h, l, s, d, thought[d])
        d = d + 1
    }
    result
}

// ─── Cognitive Operations ───

fn _dot(a: [f64], b: [f64]) -> f64 {
    var sum = 0.0
    var i = 0
    let n = len(a)
    while i < n {
        sum = sum + a[i] * b[i]
        i = i + 1
    }
    sum
}

fn mot_thought_magnitude(t: [f64]) -> f64 {
    _sqrt(_dot(t, t))
}

fn mot_thought_distance(a: [f64], b: [f64]) -> f64 {
    let ma = mot_thought_magnitude(a)
    let mb = mot_thought_magnitude(b)
    if ma < 1.0e-12 {
        return 0.0
    }
    if mb < 1.0e-12 {
        return 0.0
    }
    return _dot(a, b) / (ma * mb)
}

fn mot_attend(m: [String], b: i64, h: i64, l: i64, query_pos: i64) -> [f64] {
    let seq = int(m[4])
    let dim = int(m[5])
    let query = mot_get_thought(m, b, h, l, query_pos)
    let scale = _sqrt(float(dim))

    // Compute scores
    var scores = []
    var max_score = -1.0e30
    var s = 0
    while s < seq {
        let key = mot_get_thought(m, b, h, l, s)
        var score = _dot(query, key) / scale
        scores = push(scores, score)
        if score > max_score {
            max_score = score
        }
        s = s + 1
    }

    // Softmax
    var exp_sum = 0.0
    var weights = []
    var s2 = 0
    while s2 < seq {
        let w = _exp(scores[s2] - max_score)
        weights = push(weights, w)
        exp_sum = exp_sum + w
        s2 = s2 + 1
    }

    // Weighted sum of values
    var result = []
    var d = 0
    while d < dim {
        result = push(result, 0.0)
        d = d + 1
    }
    var s3 = 0
    while s3 < seq {
        let w = weights[s3] / exp_sum
        let val = mot_get_thought(m, b, h, l, s3)
        var d2 = 0
        while d2 < dim {
            result = _set_f(result, d2, result[d2] + w * val[d2])
            d2 = d2 + 1
        }
        s3 = s3 + 1
    }
    result
}

fn _set_f(arr: [f64], idx: i64, val: f64) -> [f64] {
    var result = []
    var i = 0
    let n = len(arr)
    while i < n {
        if i == idx {
            result = push(result, val)
        } else {
            result = push(result, arr[i])
        }
        i = i + 1
    }
    result
}

fn mot_cross_layer(m: [String], b: i64, h: i64, s: i64) -> [f64] {
    let layers = int(m[3])
    let dim = int(m[5])
    var result = []
    var d = 0
    while d < dim {
        result = push(result, 0.0)
        d = d + 1
    }
    var l = 0
    while l < layers {
        let t = mot_get_thought(m, b, h, l, s)
        var d2 = 0
        while d2 < dim {
            result = _set_f(result, d2, result[d2] + t[d2])
            d2 = d2 + 1
        }
        l = l + 1
    }
    var d3 = 0
    let fl = float(layers)
    while d3 < dim {
        result = _set_f(result, d3, result[d3] / fl)
        d3 = d3 + 1
    }
    result
}

fn mot_cross_head(m: [String], b: i64, l: i64, s: i64) -> [f64] {
    let heads = int(m[2])
    let dim = int(m[5])
    var result = []
    var d = 0
    while d < dim {
        result = push(result, 0.0)
        d = d + 1
    }
    var h = 0
    while h < heads {
        let t = mot_get_thought(m, b, h, l, s)
        var d2 = 0
        while d2 < dim {
            result = _set_f(result, d2, result[d2] + t[d2])
            d2 = d2 + 1
        }
        h = h + 1
    }
    var d3 = 0
    let fh = float(heads)
    while d3 < dim {
        result = _set_f(result, d3, result[d3] / fh)
        d3 = d3 + 1
    }
    result
}

fn mot_broadcast(m: [String], b: i64, h: i64, l: i64, s: i64, thought: [f64]) -> [String] {
    let heads = int(m[2])
    var result = m
    var hi = 0
    while hi < heads {
        result = mot_set_thought(result, b, hi, l, s, thought)
        hi = hi + 1
    }
    result
}

fn mot_layer_norm_dim(m: [String], b: i64, h: i64, l: i64, s: i64) -> [String] {
    let dim = int(m[5])
    let t = mot_get_thought(m, b, h, l, s)
    // Compute mean
    var sum = 0.0
    var d = 0
    while d < dim {
        sum = sum + t[d]
        d = d + 1
    }
    let mean = sum / float(dim)
    // Compute variance
    var var_sum = 0.0
    var d2 = 0
    while d2 < dim {
        let delta = t[d2] - mean
        var_sum = var_sum + delta * delta
        d2 = d2 + 1
    }
    let std = _sqrt(var_sum / float(dim) + 1.0e-8)
    // Normalize
    var normed = []
    var d3 = 0
    while d3 < dim {
        normed = push(normed, (t[d3] - mean) / std)
        d3 = d3 + 1
    }
    mot_set_thought(m, b, h, l, s, normed)
}

// ─── Reasoning Patterns ───

fn mot_chain_of_thought(m: [String], b: i64, h: i64, start_layer: i64, end_layer: i64, s: i64) -> [f64] {
    let dim = int(m[5])
    var current = mot_get_thought(m, b, h, start_layer, s)
    var l = start_layer + 1
    while l <= end_layer {
        let layer_t = mot_get_thought(m, b, h, l, s)
        // Residual connection: add current to layer thought
        var next = []
        var d = 0
        while d < dim {
            next = push(next, current[d] + layer_t[d])
            d = d + 1
        }
        current = next
        l = l + 1
    }
    current
}

fn mot_parallel_think(m: [String], b: i64, l: i64, s: i64) -> [f64] {
    let heads = int(m[2])
    let dim = int(m[5])
    // Each head produces its thought, concatenate all
    var result = []
    var h = 0
    while h < heads {
        let t = mot_get_thought(m, b, h, l, s)
        var d = 0
        while d < dim {
            result = push(result, t[d])
            d = d + 1
        }
        h = h + 1
    }
    result
}

fn mot_merge_thoughts(thoughts: [String]) -> [f64] {
    // thoughts is a flat array of f64-as-strings, groups of equal size
    // We assume all thought vectors are same dim, packed consecutively
    // First, figure out how many thoughts (stored as: "n_thoughts,dim,v0,v1,...")
    // Simpler: just take the array as flat f64 strings and compute weighted average
    let n = len(thoughts)
    if n == 0 {
        return []
    }
    // Parse all values
    var vals = []
    var i = 0
    while i < n {
        vals = push(vals, float(thoughts[i]))
        i = i + 1
    }
    // Compute magnitude-weighted average
    // Assume it's a single merged vector (caller handles grouping)
    vals
}

// ─── Multi-Model Communication ───

fn mot_serialize(m: [String]) -> [i64] {
    let batch = int(m[1])
    let heads = int(m[2])
    let layers = int(m[3])
    let seq = int(m[4])
    let dim = int(m[5])
    let total = batch * heads * layers * seq * dim
    var result = [48879]  // magic number
    result = push(result, batch)
    result = push(result, heads)
    result = push(result, layers)
    result = push(result, seq)
    result = push(result, dim)
    var i = 0
    while i < total {
        // Store f64 as i64 bits (approximation: multiply by 1e9 and truncate)
        let val = float(m[6 + i])
        let bits = int(val * 1000000000.0)
        result = push(result, bits)
        i = i + 1
    }
    result
}

fn mot_deserialize(data: [i64]) -> [String] {
    let batch = data[1]
    let heads = data[2]
    let layers = data[3]
    let seq = data[4]
    let dim = data[5]
    let total = batch * heads * layers * seq * dim
    var m = ["mot"]
    m = push(m, to_string(batch))
    m = push(m, to_string(heads))
    m = push(m, to_string(layers))
    m = push(m, to_string(seq))
    m = push(m, to_string(dim))
    var i = 0
    while i < total {
        let bits = data[6 + i]
        let val = float(bits) / 1000000000.0
        m = push(m, to_string(val))
        i = i + 1
    }
    m
}

fn mot_merge_spaces(a: [String], b: [String]) -> [String] {
    let total = mot_size(a)
    var m = ["mot"]
    m = push(m, a[1])
    m = push(m, a[2])
    m = push(m, a[3])
    m = push(m, a[4])
    m = push(m, a[5])
    var i = 0
    while i < total {
        let va = float(a[6 + i])
        let vb = float(b[6 + i])
        m = push(m, to_string((va + vb) / 2.0))
        i = i + 1
    }
    m
}

fn mot_diff_spaces(a: [String], b: [String]) -> [String] {
    let total = mot_size(a)
    var m = ["mot"]
    m = push(m, a[1])
    m = push(m, a[2])
    m = push(m, a[3])
    m = push(m, a[4])
    m = push(m, a[5])
    var i = 0
    while i < total {
        let va = float(a[6 + i])
        let vb = float(b[6 + i])
        m = push(m, to_string(va - vb))
        i = i + 1
    }
    m
}

// ─── Expert Types ───

fn mot_expert_gate(m: [String], b: i64, l: i64, s: i64, n_experts: i64) -> [f64] {
    let heads = int(m[2])
    let dim = int(m[5])
    // Use first n_experts dimensions of cross-head aggregation as logits
    let agg = mot_cross_head(m, b, l, s)
    var logits = []
    var max_logit = -1.0e30
    var e = 0
    while e < n_experts {
        let ei = e mod dim
        let logit = agg[ei]
        logits = push(logits, logit)
        if logit > max_logit {
            max_logit = logit
        }
        e = e + 1
    }
    // Softmax
    var exp_sum = 0.0
    var exps = []
    var e2 = 0
    while e2 < n_experts {
        let v = _exp(logits[e2] - max_logit)
        exps = push(exps, v)
        exp_sum = exp_sum + v
        e2 = e2 + 1
    }
    var result = []
    var e3 = 0
    while e3 < n_experts {
        result = push(result, exps[e3] / exp_sum)
        e3 = e3 + 1
    }
    result
}

fn mot_expert_apply(m: [String], expert_id: i64, b: i64, l: i64, s: i64, weight: [f64]) -> [String] {
    let heads = int(m[2])
    let dim = int(m[5])
    // Scale the thought at head=expert_id by the gating weight
    let gate_val = weight[expert_id]
    var h = expert_id
    if h >= heads {
        h = 0
    }
    let t = mot_get_thought(m, b, h, l, s)
    var scaled = []
    var d = 0
    while d < dim {
        scaled = push(scaled, t[d] * gate_val)
        d = d + 1
    }
    mot_set_thought(m, b, h, l, s, scaled)
}

// ─── Tests ───

fn _make_thought(dim: i64, val: f64) -> [f64] {
    var t = []
    var d = 0
    while d < dim {
        t = push(t, val)
        d = d + 1
    }
    t
}

fn _make_thought_idx(dim: i64) -> [f64] {
    var t = []
    var d = 0
    while d < dim {
        t = push(t, float(d) + 1.0)
        d = d + 1
    }
    t
}

fn main() {
    var pass_count = 0
    var fail_count = 0

    // 1. Create 5D MoT space [1,2,3,4,8]
    println("--- Test 1: Create MoT space ---")
    var m = mot_new(1, 2, 3, 4, 8)
    let shape = mot_shape(m)
    let sz = mot_size(m)
    if shape[0] == 1 && shape[1] == 2 && shape[2] == 3 && shape[3] == 4 && shape[4] == 8 && sz == 192 {
        println("PASS: shape=[1,2,3,4,8] size=192")
        pass_count = pass_count + 1
    } else {
        println("FAIL: shape or size mismatch")
        fail_count = fail_count + 1
    }

    // 2. Set and get thoughts — round-trip
    println("--- Test 2: Set/Get thought round-trip ---")
    let thought_in = _make_thought_idx(8)
    m = mot_set_thought(m, 0, 1, 2, 3, thought_in)
    let thought_out = mot_get_thought(m, 0, 1, 2, 3)
    var t2_ok = true
    var d = 0
    while d < 8 {
        if _abs(thought_out[d] - thought_in[d]) > 1.0e-9 {
            t2_ok = false
        }
        d = d + 1
    }
    if t2_ok {
        println("PASS: thought round-trip")
        pass_count = pass_count + 1
    } else {
        println("FAIL: thought round-trip")
        fail_count = fail_count + 1
    }

    // Also test single value set/get
    m = mot_set(m, 0, 0, 0, 0, 3, 42.5)
    let v = mot_get(m, 0, 0, 0, 0, 3)
    if _abs(v - 42.5) < 1.0e-9 {
        println("PASS: single value set/get")
        pass_count = pass_count + 1
    } else {
        println("FAIL: single value set/get")
        fail_count = fail_count + 1
    }

    // 3. Attention over sequence
    println("--- Test 3: Attention ---")
    // Put some non-zero thoughts in layer 0
    var s = 0
    while s < 4 {
        let t = _make_thought(8, float(s) + 1.0)
        m = mot_set_thought(m, 0, 0, 0, s, t)
        s = s + 1
    }
    let attn = mot_attend(m, 0, 0, 0, 0)
    if len(attn) == 8 {
        println("PASS: attention produces dim=8 output")
        pass_count = pass_count + 1
    } else {
        println("FAIL: attention output size " + to_string(len(attn)))
        fail_count = fail_count + 1
    }

    // 4. Cross-layer reasoning
    println("--- Test 4: Cross-layer reasoning ---")
    // Set thoughts across layers at (b=0, h=0, s=0)
    var l = 0
    while l < 3 {
        let t = _make_thought(8, float(l) * 2.0 + 1.0)
        m = mot_set_thought(m, 0, 0, l, 0, t)
        l = l + 1
    }
    let cl = mot_cross_layer(m, 0, 0, 0)
    // Mean of 1.0, 3.0, 5.0 = 3.0
    if _abs(cl[0] - 3.0) < 1.0e-9 {
        println("PASS: cross-layer mean = 3.0")
        pass_count = pass_count + 1
    } else {
        println("FAIL: cross-layer mean = " + to_string(cl[0]))
        fail_count = fail_count + 1
    }

    // 5. Thought distance
    println("--- Test 5: Thought distance ---")
    let ta = _make_thought(8, 1.0)
    let tb = _make_thought(8, 1.0)
    let dist_same = mot_thought_distance(ta, tb)
    if _abs(dist_same - 1.0) < 1.0e-9 {
        println("PASS: identical thoughts cosine = 1.0")
        pass_count = pass_count + 1
    } else {
        println("FAIL: identical thoughts cosine = " + to_string(dist_same))
        fail_count = fail_count + 1
    }

    // Orthogonal: [1,0,0,...] vs [0,1,0,...]
    var orth_a = []
    var orth_b = []
    var di = 0
    while di < 8 {
        if di == 0 {
            orth_a = push(orth_a, 1.0)
            orth_b = push(orth_b, 0.0)
        } else {
            if di == 1 {
                orth_a = push(orth_a, 0.0)
                orth_b = push(orth_b, 1.0)
            } else {
                orth_a = push(orth_a, 0.0)
                orth_b = push(orth_b, 0.0)
            }
        }
        di = di + 1
    }
    let dist_orth = mot_thought_distance(orth_a, orth_b)
    if _abs(dist_orth) < 1.0e-9 {
        println("PASS: orthogonal thoughts cosine = 0.0")
        pass_count = pass_count + 1
    } else {
        println("FAIL: orthogonal thoughts cosine = " + to_string(dist_orth))
        fail_count = fail_count + 1
    }

    // 6. Serialize/deserialize round-trip
    println("--- Test 6: Serialize/Deserialize ---")
    let ser = mot_serialize(m)
    let deser = mot_deserialize(ser)
    let shape2 = mot_shape(deser)
    var t6_ok = shape2[0] == 1 && shape2[1] == 2 && shape2[2] == 3 && shape2[3] == 4 && shape2[4] == 8
    // Check a known value — the thought we set at (0,1,2,3)
    let t_deser = mot_get_thought(deser, 0, 1, 2, 3)
    // Original was [1,2,3,4,5,6,7,8] — check with quantization tolerance
    if _abs(t_deser[0] - 1.0) > 0.001 {
        t6_ok = false
    }
    if _abs(t_deser[7] - 8.0) > 0.001 {
        t6_ok = false
    }
    if t6_ok {
        println("PASS: serialize/deserialize round-trip")
        pass_count = pass_count + 1
    } else {
        println("FAIL: serialize/deserialize round-trip")
        fail_count = fail_count + 1
    }

    // 7. Merge two spaces
    println("--- Test 7: Merge spaces ---")
    var m_a = mot_new(1, 2, 3, 4, 8)
    var m_b = mot_new(1, 2, 3, 4, 8)
    m_a = mot_set(m_a, 0, 0, 0, 0, 0, 10.0)
    m_b = mot_set(m_b, 0, 0, 0, 0, 0, 20.0)
    let merged = mot_merge_spaces(m_a, m_b)
    let merged_val = mot_get(merged, 0, 0, 0, 0, 0)
    if _abs(merged_val - 15.0) < 1.0e-9 {
        println("PASS: merge average = 15.0")
        pass_count = pass_count + 1
    } else {
        println("FAIL: merge average = " + to_string(merged_val))
        fail_count = fail_count + 1
    }

    // 8. Chain of thought across layers
    println("--- Test 8: Chain of thought ---")
    var m2 = mot_new(1, 1, 3, 1, 4)
    m2 = mot_set_thought(m2, 0, 0, 0, 0, [1.0, 0.0, 0.0, 0.0])
    m2 = mot_set_thought(m2, 0, 0, 1, 0, [0.0, 1.0, 0.0, 0.0])
    m2 = mot_set_thought(m2, 0, 0, 2, 0, [0.0, 0.0, 1.0, 0.0])
    let chain = mot_chain_of_thought(m2, 0, 0, 0, 2, 0)
    // Layer 0: [1,0,0,0], +layer1: [1,1,0,0], +layer2: [1,1,1,0]
    if _abs(chain[0] - 1.0) < 1.0e-9 && _abs(chain[1] - 1.0) < 1.0e-9 && _abs(chain[2] - 1.0) < 1.0e-9 && _abs(chain[3] - 0.0) < 1.0e-9 {
        println("PASS: chain of thought = [1,1,1,0]")
        pass_count = pass_count + 1
    } else {
        println("FAIL: chain of thought")
        fail_count = fail_count + 1
    }

    // Summary
    println("")
    println("=== Results: " + to_string(pass_count) + " PASS, " + to_string(fail_count) + " FAIL ===")
    if fail_count == 0 {
        println("ALL TESTS PASSED")
    }
}
