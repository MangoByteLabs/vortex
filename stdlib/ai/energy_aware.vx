// energy_aware.vx — Energy-Aware Computation as a Language Primitive
//
// Every computation has an energy cost. No other language tracks computational
// energy cost at the language level. Vortex does.
//
// Energy model based on real hardware measurements:
//   ~1 pJ per FLOP (modern GPU at scale)
//   ~10 pJ per memory access
//   ~100 pJ per byte transmitted

// ─── Math Helpers ───────────────────────────────────────────────────────────

fn _abs(x: f64) -> f64 {
    if x < 0.0 { 0.0 - x } else { x }
}

fn _sqrt(x: f64) -> f64 {
    if x <= 0.0 { return 0.0 }
    var g = x / 2.0
    if g < 1.0 { g = 1.0 }
    var i = 0
    while i < 40 {
        let nxt = (g + x / g) / 2.0
        if _abs(nxt - g) < 1.0e-15 { return nxt }
        g = nxt
        i = i + 1
    }
    g
}

fn _log(x: f64) -> f64 {
    if x <= 0.0 { return 0.0 - 1.0e30 }
    let ln2 = 0.6931471805599453
    var v = x
    var k = 0
    while v >= 2.0 {
        v = v / 2.0
        k = k + 1
    }
    while v < 0.5 {
        v = v * 2.0
        k = k - 1
    }
    let t = (v - 1.0) / (v + 1.0)
    let t2 = t * t
    var term = t
    var sum = t
    var n = 1
    while n < 60 {
        term = term * t2
        n = n + 2
        let c = term / float(n)
        sum = sum + c
        if _abs(c) < 1.0e-16 { n = 100 }
    }
    2.0 * sum + float(k) * ln2
}

// ─── Energy Units ───────────────────────────────────────────────────────────

fn JOULES_PER_FLOP() -> f64 {
    1.0e-12
}

fn JOULES_PER_MEMOP() -> f64 {
    1.0e-11
}

fn JOULES_PER_BYTE_TX() -> f64 {
    1.0e-10
}

// ─── Energy Meter ───────────────────────────────────────────────────────────
// State: [total_joules, flop_count, memop_count, byte_count]

fn meter_new() -> [f64] {
    let r = [0.0, 0.0, 0.0, 0.0]
    r
}

fn meter_add_flops(m: [f64], n: i64) -> [f64] {
    let en = float(n) * JOULES_PER_FLOP()
    let r = [m[0] + en, m[1] + float(n), m[2], m[3]]
    r
}

fn meter_add_memops(m: [f64], n: i64) -> [f64] {
    let en = float(n) * JOULES_PER_MEMOP()
    let r = [m[0] + en, m[1], m[2] + float(n), m[3]]
    r
}

fn meter_add_bytes(m: [f64], n: i64) -> [f64] {
    let en = float(n) * JOULES_PER_BYTE_TX()
    let r = [m[0] + en, m[1], m[2], m[3] + float(n)]
    r
}

fn meter_total_energy(m: [f64]) -> f64 {
    m[0]
}

fn meter_total_flops(m: [f64]) -> i64 {
    int(m[1])
}

fn meter_report(m: [f64]) -> String {
    let s = "Energy: " + to_string(m[0]) + " J | FLOPs: " + to_string(int(m[1])) + " | MemOps: " + to_string(int(m[2])) + " | Bytes: " + to_string(int(m[3]))
    s
}

// ─── Operation Energy Costs ─────────────────────────────────────────────────

fn energy_matmul(m: i64, k: i64, n: i64) -> f64 {
    float(2 * m * k * n) * JOULES_PER_FLOP()
}

fn energy_softmax(n: i64) -> f64 {
    float(5 * n) * JOULES_PER_FLOP()
}

fn energy_layer_norm(n: i64) -> f64 {
    float(5 * n) * JOULES_PER_FLOP()
}

fn energy_attention(seq_len: i64, dim: i64, n_heads: i64) -> f64 {
    let head_dim = dim / n_heads
    let qkv_energy = 3.0 * energy_matmul(seq_len, dim, dim)
    let score_energy = float(n_heads) * energy_matmul(seq_len, head_dim, seq_len)
    let softmax_energy = float(n_heads * seq_len) * energy_softmax(seq_len)
    let av_energy = float(n_heads) * energy_matmul(seq_len, seq_len, head_dim)
    let out_energy = energy_matmul(seq_len, dim, dim)
    qkv_energy + score_energy + softmax_energy + av_energy + out_energy
}

fn energy_ffn(dim: i64, hidden: i64) -> f64 {
    let up = energy_matmul(1, dim, hidden)
    let down = energy_matmul(1, hidden, dim)
    let act = float(hidden) * JOULES_PER_FLOP()
    up + down + act
}

fn energy_transformer_layer(dim: i64, hidden: i64, n_heads: i64, seq_len: i64) -> f64 {
    let attn = energy_attention(seq_len, dim, n_heads)
    let ffn_e = float(seq_len) * energy_ffn(dim, hidden)
    let norm_e = 2.0 * energy_layer_norm(seq_len * dim)
    attn + ffn_e + norm_e
}

fn energy_full_model(n_layers: i64, dim: i64, hidden: i64, n_heads: i64, seq_len: i64, vocab: i64) -> f64 {
    let embed = float(seq_len * dim) * JOULES_PER_MEMOP()
    var total = embed
    var i = 0
    while i < n_layers {
        total = total + energy_transformer_layer(dim, hidden, n_heads, seq_len)
        i = i + 1
    }
    total = total + energy_layer_norm(seq_len * dim)
    total = total + energy_matmul(seq_len, dim, vocab)
    total
}

// ─── Energy Budget ──────────────────────────────────────────────────────────
// State: [max_joules, spent_joules, is_approximate (0.0 or 1.0)]

fn budget_new(max_joules: f64) -> [f64] {
    let r = [max_joules, 0.0, 0.0]
    r
}

fn budget_spend(b: [f64], joules: f64) -> [f64] {
    let new_spent = b[1] + joules
    var approx = b[2]
    if new_spent > b[0] {
        approx = 1.0
    }
    let r = [b[0], new_spent, approx]
    r
}

fn budget_remaining(b: [f64]) -> f64 {
    let r = b[0] - b[1]
    if r < 0.0 { return 0.0 }
    r
}

fn budget_exceeded(b: [f64]) -> bool {
    b[1] > b[0]
}

fn budget_fraction_used(b: [f64]) -> f64 {
    if b[0] <= 0.0 { return 1.0 }
    b[1] / b[0]
}

// ─── Adaptive Precision ────────────────────────────────────────────────────

fn adaptive_matmul(a: [f64], b: [f64], m: i64, k: i64, n: i64, budget: [f64]) -> [f64] {
    let full_energy = energy_matmul(m, k, n)
    let frac = budget_fraction_used(budget)
    if frac < 0.8 {
        var result = []
        var row = 0
        while row < m {
            var col = 0
            while col < n {
                var sum = 0.0
                var ki = 0
                while ki < k {
                    sum = sum + a[row * k + ki] * b[ki * n + col]
                    ki = ki + 1
                }
                result = push(result, sum)
                col = col + 1
            }
            row = row + 1
        }
        result = push(result, full_energy)
        return result
    }
    var result = []
    var row = 0
    while row < m {
        var col = 0
        while col < n {
            var sum = 0.0
            var ki = 0
            while ki < k {
                sum = sum + a[row * k + ki] * b[ki * n + col]
                ki = ki + 2
            }
            sum = sum * 2.0
            result = push(result, sum)
            col = col + 1
        }
        row = row + 1
    }
    let approx_energy = full_energy * 0.5
    result = push(result, approx_energy)
    result
}

fn adaptive_attention(q: [f64], kk: [f64], v: [f64], seq_len: i64, dim: i64, budget: [f64]) -> [f64] {
    let frac = budget_fraction_used(budget)
    let full_energy = energy_attention(seq_len, dim, 1)
    if frac < 0.8 {
        var scores = []
        var ii = 0
        while ii < seq_len {
            var jj = 0
            while jj < seq_len {
                var dot = 0.0
                var dd = 0
                while dd < dim {
                    dot = dot + q[ii * dim + dd] * kk[jj * dim + dd]
                    dd = dd + 1
                }
                scores = push(scores, dot / _sqrt(float(dim)))
                jj = jj + 1
            }
            ii = ii + 1
        }
        var out = []
        var ii2 = 0
        while ii2 < seq_len {
            var dd = 0
            while dd < dim {
                var sum = 0.0
                var jj2 = 0
                while jj2 < seq_len {
                    sum = sum + scores[ii2 * seq_len + jj2] * v[jj2 * dim + dd]
                    jj2 = jj2 + 1
                }
                out = push(out, sum)
                dd = dd + 1
            }
            ii2 = ii2 + 1
        }
        out = push(out, full_energy)
        return out
    }
    let window = 4
    var out = []
    var ii = 0
    while ii < seq_len {
        var dd = 0
        while dd < dim {
            var sum = 0.0
            var start = ii - window
            if start < 0 { start = 0 }
            var end_pos = ii + window + 1
            if end_pos > seq_len { end_pos = seq_len }
            var jj = start
            while jj < end_pos {
                var dot = 0.0
                var dd2 = 0
                while dd2 < dim {
                    dot = dot + q[ii * dim + dd2] * kk[jj * dim + dd2]
                    dd2 = dd2 + 1
                }
                sum = sum + dot * v[jj * dim + dd]
                jj = jj + 1
            }
            out = push(out, sum)
            dd = dd + 1
        }
        ii = ii + 1
    }
    let approx_energy = full_energy * 0.3
    out = push(out, approx_energy)
    out
}

fn adaptive_softmax(x: [f64], budget: [f64]) -> [f64] {
    let n = len(x)
    let frac = budget_fraction_used(budget)
    let en = energy_softmax(int(n))
    if frac < 0.8 {
        var max_val = x[0]
        var ii = 1
        while ii < n {
            if x[ii] > max_val { max_val = x[ii] }
            ii = ii + 1
        }
        var sum = 0.0
        var exps = []
        var ii2 = 0
        while ii2 < n {
            var dv = x[ii2] - max_val
            var e = 1.0 + dv + dv * dv * 0.5 + dv * dv * dv / 6.0
            if e < 0.0 { e = 0.0001 }
            exps = push(exps, e)
            sum = sum + e
            ii2 = ii2 + 1
        }
        var result = []
        var ii3 = 0
        while ii3 < n {
            result = push(result, exps[ii3] / sum)
            ii3 = ii3 + 1
        }
        result = push(result, en)
        return result
    }
    var max_val = x[0]
    var max_idx = 0
    var ii = 1
    while ii < n {
        if x[ii] > max_val {
            max_val = x[ii]
            max_idx = ii
        }
        ii = ii + 1
    }
    var result = []
    var ii2 = 0
    while ii2 < n {
        if ii2 == max_idx {
            result = push(result, 1.0)
        } else {
            result = push(result, 0.0)
        }
        ii2 = ii2 + 1
    }
    result = push(result, en * 0.2)
    result
}

// ─── Carbon Tracking ────────────────────────────────────────────────────────

fn carbon_from_energy(joules: f64, grid_intensity: f64) -> f64 {
    let kwh = joules / 3600000.0
    kwh * grid_intensity
}

fn carbon_report(joules: f64) -> String {
    let co2 = carbon_from_energy(joules, 400.0)
    let kwh = joules / 3600000.0
    let s = "Energy: " + to_string(joules) + " J (" + to_string(kwh) + " kWh) | CO2: " + to_string(co2) + " g (US avg grid)"
    s
}

// ─── Inference Energy Profiler ──────────────────────────────────────────────

fn profile_inference(n_layers: i64, dim: i64, hidden: i64, n_heads: i64, seq_len: i64, n_tokens: i64) -> [String] {
    let attn_per_token = energy_attention(seq_len, dim, n_heads)
    let ffn_per_token = float(seq_len) * energy_ffn(dim, hidden)
    let norm_per_token = 2.0 * energy_layer_norm(seq_len * dim)
    let embed_per_token = float(seq_len * dim) * JOULES_PER_MEMOP()
    let attn_total = float(n_layers * n_tokens) * attn_per_token
    let ffn_total = float(n_layers * n_tokens) * ffn_per_token
    let norm_total = float(n_layers * n_tokens) * norm_per_token
    let embed_total = float(n_tokens) * embed_per_token
    let total = attn_total + ffn_total + norm_total + embed_total
    let co2 = carbon_from_energy(total, 400.0)
    let charges = total / 40000.0
    var result = []
    result = push(result, to_string(attn_total))
    result = push(result, to_string(ffn_total))
    result = push(result, to_string(norm_total))
    result = push(result, to_string(embed_total))
    result = push(result, to_string(total))
    result = push(result, to_string(co2))
    result = push(result, to_string(charges))
    result
}

// ─── Training Energy Estimator ──────────────────────────────────────────────

fn estimate_training_energy(params_billions: f64, tokens_billions: f64, gpu_efficiency: f64) -> [String] {
    let total_flops = 6.0 * params_billions * 1.0e9 * tokens_billions * 1.0e9
    let total_pflops = total_flops / 1.0e15
    let total_joules = total_flops * JOULES_PER_FLOP() / gpu_efficiency
    let total_kwh = total_joules / 3600000.0
    let co2_kg = carbon_from_energy(total_joules, 400.0) / 1000.0
    let cost_usd = total_kwh * 0.10
    var result = []
    result = push(result, to_string(total_pflops))
    result = push(result, to_string(total_joules))
    result = push(result, to_string(total_kwh))
    result = push(result, to_string(co2_kg))
    result = push(result, to_string(cost_usd))
    result
}

// ─── Architecture Comparison ────────────────────────────────────────────────

fn parse_int_from_config(s: String, start: i64) -> [i64] {
    var val = 0
    var ii = start
    let slen = len(s)
    while ii < slen {
        let ch = str_char_at(s, ii)
        if ch == "," { return [val, ii + 1] }
        if ch == "0" { val = val * 10 }
        if ch == "1" { val = val * 10 + 1 }
        if ch == "2" { val = val * 10 + 2 }
        if ch == "3" { val = val * 10 + 3 }
        if ch == "4" { val = val * 10 + 4 }
        if ch == "5" { val = val * 10 + 5 }
        if ch == "6" { val = val * 10 + 6 }
        if ch == "7" { val = val * 10 + 7 }
        if ch == "8" { val = val * 10 + 8 }
        if ch == "9" { val = val * 10 + 9 }
        ii = ii + 1
    }
    let r = [val, ii]
    r
}

fn compare_architectures(configs: [String]) -> [String] {
    var results = []
    var ci = 0
    let nc = len(configs)
    while ci < nc {
        let cfg = configs[ci]
        let p1 = parse_int_from_config(cfg, 0)
        let layers = p1[0]
        let p2 = parse_int_from_config(cfg, p1[1])
        let dim_val = p2[0]
        let p3 = parse_int_from_config(cfg, p2[1])
        let hidden_dim = p3[0]
        let p4 = parse_int_from_config(cfg, p3[1])
        let heads = p4[0]
        let p5 = parse_int_from_config(cfg, p4[1])
        let seq = p5[0]
        let en = energy_full_model(layers, dim_val, hidden_dim, heads, seq, 50257)
        let co2 = carbon_from_energy(en, 400.0)
        let line = "Config(" + cfg + "): " + to_string(en) + " J, " + to_string(co2) + " gCO2"
        results = push(results, line)
        ci = ci + 1
    }
    results
}

// ─── Main: Tests ────────────────────────────────────────────────────────────

fn main() {
    var pass = 0
    var fail = 0

    // Test 1: Meter tracks FLOPs correctly
    var m = meter_new()
    m = meter_add_flops(m, 1000)
    if meter_total_flops(m) == 1000 {
        println("PASS test 1: meter tracks FLOPs")
        pass = pass + 1
    } else {
        println("FAIL test 1: meter tracks FLOPs, got " + to_string(meter_total_flops(m)))
        fail = fail + 1
    }

    // Test 2: Matmul energy = 2*m*k*n * JOULES_PER_FLOP
    let e2 = energy_matmul(64, 128, 32)
    let expected2 = float(2 * 64 * 128 * 32) * JOULES_PER_FLOP()
    if _abs(e2 - expected2) < 1.0e-20 {
        println("PASS test 2: matmul energy correct")
        pass = pass + 1
    } else {
        println("FAIL test 2: matmul energy, got " + to_string(e2) + " expected " + to_string(expected2))
        fail = fail + 1
    }

    // Test 3: Budget tracking
    var b = budget_new(1.0)
    let rem_before = budget_remaining(b)
    b = budget_spend(b, 0.3)
    let rem_after = budget_remaining(b)
    if _abs(rem_before - 1.0) < 1.0e-10 {
        if rem_after < rem_before {
            println("PASS test 3: budget tracking")
            pass = pass + 1
        } else {
            println("FAIL test 3: budget did not decrease")
            fail = fail + 1
        }
    } else {
        println("FAIL test 3: budget initial wrong")
        fail = fail + 1
    }

    // Test 4: Budget exceeded flag
    var b4 = budget_new(0.5)
    b4 = budget_spend(b4, 0.3)
    if budget_exceeded(b4) == false {
        b4 = budget_spend(b4, 0.3)
        if budget_exceeded(b4) == true {
            println("PASS test 4: budget exceeded flag")
            pass = pass + 1
        } else {
            println("FAIL test 4: should be exceeded after 0.6 spent on 0.5 budget")
            fail = fail + 1
        }
    } else {
        println("FAIL test 4: should not be exceeded after 0.3 spent on 0.5 budget")
        fail = fail + 1
    }

    // Test 5: Adaptive matmul full precision
    let a5 = [1.0, 2.0, 3.0, 4.0]
    let b5 = [5.0, 6.0, 7.0, 8.0]
    let big_budget = budget_new(1000.0)
    let r5 = adaptive_matmul(a5, b5, 2, 2, 2, big_budget)
    if _abs(r5[0] - 19.0) < 0.01 {
        if _abs(r5[3] - 50.0) < 0.01 {
            println("PASS test 5: adaptive matmul full precision")
            pass = pass + 1
        } else {
            println("FAIL test 5: element [3] wrong")
            fail = fail + 1
        }
    } else {
        println("FAIL test 5: element [0] wrong, got " + to_string(r5[0]))
        fail = fail + 1
    }

    // Test 6: Adaptive matmul approximate mode
    var tight_budget = budget_new(1.0)
    tight_budget = budget_spend(tight_budget, 0.9)
    let r6 = adaptive_matmul(a5, b5, 2, 2, 2, tight_budget)
    if _abs(r6[0] - 19.0) > 0.01 {
        println("PASS test 6: adaptive matmul approximate mode")
        pass = pass + 1
    } else {
        println("FAIL test 6: adaptive matmul should use approximate mode")
        fail = fail + 1
    }

    // Test 7: Carbon tracking
    let joules7 = 3600000.0
    let co2_7 = carbon_from_energy(joules7, 400.0)
    if _abs(co2_7 - 400.0) < 0.01 {
        println("PASS test 7: carbon tracking")
        pass = pass + 1
    } else {
        println("FAIL test 7: carbon tracking, got " + to_string(co2_7))
        fail = fail + 1
    }

    // Test 8: Profile inference for GPT-2
    let prof = profile_inference(12, 768, 3072, 12, 1024, 1)
    if len(prof) == 7 {
        println("PASS test 8: profile inference returns 7 fields for GPT-2")
        pass = pass + 1
    } else {
        println("FAIL test 8: profile inference returned " + to_string(len(prof)) + " fields")
        fail = fail + 1
    }

    // Test 9: Training energy estimate for 7B model, 2T tokens
    let train_est = estimate_training_energy(7.0, 2.0, 0.3)
    if len(train_est) == 5 {
        println("PASS test 9: training energy returns 5 fields for 7B/2T")
        pass = pass + 1
    } else {
        println("FAIL test 9: training energy returned " + to_string(len(train_est)) + " fields")
        fail = fail + 1
    }

    // Test 10: Compare two architectures
    var cfgs = []
    cfgs = push(cfgs, "12,768,3072,12,1024")
    cfgs = push(cfgs, "24,1024,4096,16,2048")
    let cmp = compare_architectures(cfgs)
    if len(cmp) == 2 {
        if cmp[0] != cmp[1] {
            println("PASS test 10: architectures have different energy costs")
            pass = pass + 1
        } else {
            println("FAIL test 10: architectures should differ")
            fail = fail + 1
        }
    } else {
        println("FAIL test 10: compare returned " + to_string(len(cmp)) + " entries")
        fail = fail + 1
    }

    println("")
    println("Results: " + to_string(pass) + " PASS, " + to_string(fail) + " FAIL out of 10 tests")
}
