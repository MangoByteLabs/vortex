// Vortex Tensor Library

fn zeros(n) {
    let result = []
    for i in 0..n { push(result, 0.0) }
    result
}

fn ones(n) {
    let result = []
    for i in 0..n { push(result, 1.0) }
    result
}

fn full(n, val) {
    let result = []
    for i in 0..n { push(result, val) }
    result
}

fn linspace(start, end, n) {
    let result = []
    let step = (end - start) / (n - 1)
    for i in 0..n { push(result, start + i * step) }
    result
}

fn arange(start, end, step) {
    let result = []
    let x = start
    while x < end {
        push(result, x)
        x = x + step
    }
    result
}

fn matmul_2d(a, b, m, n, k) {
    // a is m x k, b is k x n, result is m x n (flattened)
    let result = zeros(m * n)
    for i in 0..m {
        for j in 0..n {
            let s = 0.0
            for p in 0..k {
                s = s + a[i * k + p] * b[p * n + j]
            }
            result[i * n + j] = s
        }
    }
    result
}

fn transpose(a, rows, cols) {
    let result = zeros(rows * cols)
    for i in 0..rows {
        for j in 0..cols {
            result[j * rows + i] = a[i * cols + j]
        }
    }
    result
}

fn flatten(nested_array) {
    let result = []
    for i in 0..len(nested_array) {
        for j in 0..len(nested_array[i]) {
            push(result, nested_array[i][j])
        }
    }
    result
}

fn reshape(flat, rows, cols) {
    let result = []
    for i in 0..rows {
        let row = []
        for j in 0..cols {
            push(row, flat[i * cols + j])
        }
        push(result, row)
    }
    result
}

fn eye(n) {
    let result = zeros(n * n)
    for i in 0..n { result[i * n + i] = 1.0 }
    result
}
