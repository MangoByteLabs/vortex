// Vortex Standard Library — OS Interface
// Wraps Linux x86-64 syscalls and libc FFI for OS-level operations.
//
// Syscall numbers (x86-64 Linux):
//   SYS_READ      = 0
//   SYS_WRITE     = 1
//   SYS_OPEN      = 2
//   SYS_CLOSE     = 3
//   SYS_GETCWD    = 79
//   SYS_CHDIR     = 80
//   SYS_GETPID    = 39
//   SYS_GETUID    = 102
//   SYS_EXIT      = 60
//   SYS_FORK      = 57
//   SYS_EXECVE    = 59
//   SYS_CLOCK_GETTIME = 228
//   SYS_WAITPID   = 61  (wait4 = 61)
//   SYS_GETGID    = 104

// ---- syscall number constants ----
fn SYS_READ()          -> i64 { return 0 }
fn SYS_WRITE()         -> i64 { return 1 }
fn SYS_OPEN()          -> i64 { return 2 }
fn SYS_CLOSE()         -> i64 { return 3 }
fn SYS_GETPID()        -> i64 { return 39 }
fn SYS_FORK()          -> i64 { return 57 }
fn SYS_EXECVE()        -> i64 { return 59 }
fn SYS_EXIT()          -> i64 { return 60 }
fn SYS_WAIT4()         -> i64 { return 61 }
fn SYS_GETCWD()        -> i64 { return 79 }
fn SYS_CHDIR()         -> i64 { return 80 }
fn SYS_GETUID()        -> i64 { return 102 }
fn SYS_GETGID()        -> i64 { return 104 }
fn SYS_CLOCK_GETTIME() -> i64 { return 228 }

fn CLOCK_MONOTONIC()   -> i64 { return 1 }
fn CLOCK_REALTIME()    -> i64 { return 0 }

// ---- Process identity ----

fn getpid() -> i64 {
    return syscall0(SYS_GETPID())
}

fn getuid() -> i64 {
    return syscall0(SYS_GETUID())
}

fn getgid() -> i64 {
    return syscall0(SYS_GETGID())
}

// ---- Process control ----

fn exit(code: i64) {
    syscall1(SYS_EXIT(), code)
}

// fork: returns 0 in child, child PID in parent, -1 on error
fn fork() -> i64 {
    return syscall0(SYS_FORK())
}

// ---- Working directory ----

// getcwd: return current working directory as String
fn getcwd() -> String {
    let buf_size = 4096
    let buf = mem_alloc(buf_size)
    let ret = syscall2(SYS_GETCWD(), buf, buf_size)
    if ret <= 0 {
        mem_free(buf)
        return ""
    }
    // Read bytes until null terminator
    var byte_arr = []
    var i = 0
    var cont = true
    while cont && i < buf_size {
        let b = mem_read_u8(buf, i)
        if b == 0 {
            cont = false
        } else {
            byte_arr = push(byte_arr, b)
            i = i + 1
        }
    }
    mem_free(buf)
    return str_from_bytes(byte_arr)
}

// chdir: change working directory, return 0 on success or negative errno
fn chdir(path: String) -> i64 {
    let bytes = str_bytes(path)
    let n = len(bytes)
    // Need null-terminated C string
    let buf = mem_alloc(n + 1)
    for i in range(0, n) {
        mem_write_u8(buf, i, int(bytes[i]))
    }
    mem_write_u8(buf, n, 0)
    let ret = syscall1(SYS_CHDIR(), buf)
    mem_free(buf)
    return ret
}

// ---- Environment variables (via FFI libc) ----

// env_get: get environment variable by name, returns "" if not set
fn env_get(name: String) -> String {
    let libc = ffi_open("libc.so.6")
    if ptr_to_int(libc) == 0 {
        return ""
    }
    let getenv_fn = ffi_sym(libc, "getenv")
    if getenv_fn == 0 {
        return ""
    }
    let name_bytes = str_bytes(name)
    let nlen = len(name_bytes)
    let name_buf = mem_alloc(nlen + 1)
    for i in range(0, nlen) {
        mem_write_u8(name_buf, i, int(name_bytes[i]))
    }
    mem_write_u8(name_buf, nlen, 0)
    let result_ptr = ffi_call(getenv_fn, [name_buf])
    mem_free(name_buf)
    if result_ptr == 0 {
        return ""
    }
    // Read C string from result_ptr
    var byte_arr = []
    var i = 0
    var cont = true
    while cont && i < 4096 {
        let b = mem_read_u8(result_ptr, i)
        if b == 0 {
            cont = false
        } else {
            byte_arr = push(byte_arr, b)
            i = i + 1
        }
    }
    return str_from_bytes(byte_arr)
}

// env_set: set environment variable via FFI setenv
fn env_set(name: String, value: String) {
    let libc = ffi_open("libc.so.6")
    if ptr_to_int(libc) == 0 {
        return
    }
    let setenv_fn = ffi_sym(libc, "setenv")
    if setenv_fn == 0 {
        return
    }
    let name_bytes = str_bytes(name)
    let nlen = len(name_bytes)
    let name_buf = mem_alloc(nlen + 1)
    for i in range(0, nlen) {
        mem_write_u8(name_buf, i, int(name_bytes[i]))
    }
    mem_write_u8(name_buf, nlen, 0)
    let val_bytes = str_bytes(value)
    let vlen = len(val_bytes)
    let val_buf = mem_alloc(vlen + 1)
    for i in range(0, vlen) {
        mem_write_u8(val_buf, i, int(val_bytes[i]))
    }
    mem_write_u8(val_buf, vlen, 0)
    // setenv(name, value, overwrite=1)
    ffi_call(setenv_fn, [name_buf, val_buf, 1])
    mem_free(name_buf)
    mem_free(val_buf)
}

// ---- Time ----

// time_ms: return monotonic time in milliseconds
fn time_ms() -> i64 {
    // struct timespec { time_t tv_sec (8B); long tv_nsec (8B) }
    let ts = mem_alloc(16)
    mem_write_u8(ts, 0, 0)
    let ret = syscall2(SYS_CLOCK_GETTIME(), CLOCK_MONOTONIC(), ts)
    if ret < 0 {
        mem_free(ts)
        return -1
    }
    // Read tv_sec (bytes 0-7) and tv_nsec (bytes 8-11) little-endian
    let b0 = mem_read_u8(ts, 0)
    let b1 = mem_read_u8(ts, 1)
    let b2 = mem_read_u8(ts, 2)
    let b3 = mem_read_u8(ts, 3)
    let b4 = mem_read_u8(ts, 4)
    let b5 = mem_read_u8(ts, 5)
    let b6 = mem_read_u8(ts, 6)
    let b7 = mem_read_u8(ts, 7)
    let sec = b0 + b1 * 256 + b2 * 65536 + b3 * 16777216 +
              b4 * 4294967296 + b5 * 1099511627776 + b6 * 281474976710656 + b7 * 72057594037927936
    let n0 = mem_read_u8(ts, 8)
    let n1 = mem_read_u8(ts, 9)
    let n2 = mem_read_u8(ts, 10)
    let n3 = mem_read_u8(ts, 11)
    let nsec = n0 + n1 * 256 + n2 * 65536 + n3 * 16777216
    mem_free(ts)
    return sec * 1000 + nsec / 1000000
}

// ---- Process execution ----

// exec: fork, then execve("/bin/sh", ["/bin/sh", "-c", cmd, NULL], NULL)
// returns child PID on success, -1 on error
fn exec(cmd: String) -> i64 {
    let pid = fork()
    if pid < 0 {
        return -1
    }
    if pid == 0 {
        // Child: exec /bin/sh -c <cmd>
        let sh_path = "/bin/sh"
        let sh_bytes = str_bytes(sh_path)
        let sh_len = len(sh_bytes)
        let sh_buf = mem_alloc(sh_len + 1)
        for i in range(0, sh_len) {
            mem_write_u8(sh_buf, i, int(sh_bytes[i]))
        }
        mem_write_u8(sh_buf, sh_len, 0)

        let arg_c = "-c"
        let arg_c_bytes = str_bytes(arg_c)
        let ac_len = len(arg_c_bytes)
        let ac_buf = mem_alloc(ac_len + 1)
        for i in range(0, ac_len) {
            mem_write_u8(ac_buf, i, int(arg_c_bytes[i]))
        }
        mem_write_u8(ac_buf, ac_len, 0)

        let cmd_bytes = str_bytes(cmd)
        let cmd_len = len(cmd_bytes)
        let cmd_buf = mem_alloc(cmd_len + 1)
        for i in range(0, cmd_len) {
            mem_write_u8(cmd_buf, i, int(cmd_bytes[i]))
        }
        mem_write_u8(cmd_buf, cmd_len, 0)

        // argv = [sh_buf, ac_buf, cmd_buf, NULL]  (pointer array, 4 * 8 bytes)
        let argv = mem_alloc(32)
        // We encode pointer values as bytes — this requires the interpreter to
        // support pointer-width writes; for now we pass sh_buf as the argv pointer
        // and rely on the syscall ABI to treat the pointer array correctly.
        // NOTE: a production implementation would write 8-byte pointers here.
        syscall3(SYS_EXECVE(), sh_buf, argv, 0)
        // execve returns only on error
        exit(127)
        return -1
    }
    return pid
}

// waitpid: wait for child process to finish, return exit status
fn waitpid(pid: i64) -> i64 {
    let status_buf = mem_alloc(4)
    mem_write_u8(status_buf, 0, 0)
    mem_write_u8(status_buf, 1, 0)
    mem_write_u8(status_buf, 2, 0)
    mem_write_u8(status_buf, 3, 0)
    // wait4(pid, &status, 0, NULL)
    syscall4(SYS_WAIT4(), pid, status_buf, 0, 0)
    let s0 = mem_read_u8(status_buf, 0)
    let s1 = mem_read_u8(status_buf, 1)
    mem_free(status_buf)
    return s0 + s1 * 256
}

// ---- /proc/self/cmdline ----

// args: read /proc/self/cmdline, split on null bytes, return argv as [String]
fn args() -> [String] {
    // open /proc/self/cmdline
    let path_str = "/proc/self/cmdline"
    let path_bytes = str_bytes(path_str)
    let plen = len(path_bytes)
    let path_buf = mem_alloc(plen + 1)
    for i in range(0, plen) {
        mem_write_u8(path_buf, i, int(path_bytes[i]))
    }
    mem_write_u8(path_buf, plen, 0)
    // O_RDONLY = 0
    let fd = syscall2(SYS_OPEN(), path_buf, 0)
    mem_free(path_buf)
    if fd < 0 {
        return []
    }
    let buf_size = 4096
    let buf = mem_alloc(buf_size)
    let n = syscall3(SYS_READ(), fd, buf, buf_size)
    syscall1(SYS_CLOSE(), fd)
    if n <= 0 {
        mem_free(buf)
        return []
    }
    // Split on null bytes
    var result = []
    var cur_bytes = []
    for i in range(0, n) {
        let b = mem_read_u8(buf, i)
        if b == 0 {
            if len(cur_bytes) > 0 {
                result = push(result, str_from_bytes(cur_bytes))
                cur_bytes = []
            }
        } else {
            cur_bytes = push(cur_bytes, b)
        }
    }
    if len(cur_bytes) > 0 {
        result = push(result, str_from_bytes(cur_bytes))
    }
    mem_free(buf)
    return result
}

// ---- Demo ----

fn main() {
    println("=== OS Demo ===")
    println("")

    let pid = getpid()
    println("PID: " + str(pid))

    let uid = getuid()
    println("UID: " + str(uid))

    let gid = getgid()
    println("GID: " + str(gid))
    println("")

    let cwd = getcwd()
    println("CWD: " + cwd)
    println("")

    let t0 = time_ms()
    sleep_ms(10)
    let t1 = time_ms()
    println("time_ms() before sleep: " + str(t0))
    println("time_ms() after 10ms sleep: " + str(t1))
    println("elapsed: " + str(t1 - t0) + " ms")
    println("")

    println("CPU count: " + str(cpu_count()))
    println("")

    println("Process args:")
    let argv = args()
    if len(argv) == 0 {
        println("  (none or could not read /proc/self/cmdline)")
    } else {
        for i in range(0, len(argv)) {
            println("  argv[" + str(i) + "] = " + argv[i])
        }
    }
    println("")

    let path_var = env_get("PATH")
    println("PATH env var (first 60 chars): " + str_substr(path_var, 0, 60))
    println("")

    println("=== OS Demo complete ===")
}
